[{"id":0,"href":"/docs/example/","title":"Example Site","section":"Docs","content":"Introduction #  Ferre hinnitibus erat accipitrem dixi Troiae tollens #  Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\n Pedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret  Est simul fameque tauri qua ad #  Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol #  Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo;  Trepident sitimque #  Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"},{"id":1,"href":"/docs/example/table-of-contents/with-toc/","title":"Linux 进程调度","section":"Table of Contents","content":"Linux 进程调度 #  前言 #  在计算机科学中，调度就是一种将任务（Work）分配给资源的方法。任务可能是虚拟的计算任务，例如线程、进程或者数据流，这些任务会被调度到硬件资源上执行，例如：处理器 CPU 等设备。调度器或调度算法的设计与实现最终都会归结到一个问题上，即如何对有限的资源进行分配以实现资源利用率的最大化并满足特定的需求。\n调度器是操作系统中的重要组件，操作系统中有进程调度器（Process Scheduler）、网络调度器（Network Scheduler）和 I/O 调度器（I/O Scheduler）等组件，本文介绍的是进程调度器。\n进程调度器负责给系统中的所有进程分配有限的 CPU 时间资源。只有通过合理的调度算法，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。\n进程调度算法总是追求达到以下目标：\n 公平：保证每个进程得到合理的 CPU 时间，避免进程的饥饿现象。 高效：尽量充分使用 CPU，使 CPU 保持忙碌状态。 快速的响应时间：使交互用户的响应时间应尽可能短。 周转时间：使批处理用户等待输出的时间尽可能短。 吞吐量：单位时间内处理的进程数量尽可能多。  但是很显然，这几个目标是相互冲突的，不可能同时达到。因此只能在这几个方面进行取舍，从而确定自己的调度算法。\n进程调度器将进程分为三类：\n  交互式进程(Interactive process)：这些进程经常与用户进行交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如命令行 shell、文本编辑程序。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。\n  批处理进程(Batch process)：这些进程一般在后台运行，不必与用户交互，需要占用大量的系统资源。但是能够忍受响应延迟。典型的批处理程序如编译程序、数据库搜索引擎等。\n  实时进程(Real-time process)：这些进程对调度延迟的要求最高，往往执行非常重要的操作，要求立即响应并执行。典型的实时程序比如视频播放软件、或飞机飞行控制系统，很明显这类程序不能容忍长时间的调度延迟。\n  根据进程的不同分类 Linux 采用不同的调度策略。\n对于实时进程，采用 FIFO 或者 Round Robin 的调度策略。\n对于普通进程，则需要区分交互式和批处理式的不同。传统 Linux 调度器提高交互式应用的优先级，使得它们能更快地被调度。而 CFS 和 RSDL 等新的调度器的核心思想是“完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。\n以下列出了 Linux 不同版本调度器的历史：\n 初始调度器 · v0.01 ~ v2.4  由几十行代码实现，功能非常简陋； 同时最多处理 64 个任务；   O(n) 调度器 · v2.4 ~ v2.6  调度时需要遍历全部任务； 当待执行的任务较多时，同一个任务两次执行的间隔很长，会有比较严重的饥饿问题；   O(1) 调度器 · v2.6.0 ~ v2.6.22  通过引入运行队列和优先级数组实现 O(1) 的时间复杂度; 使用本地运行队列替代全局运行队列增强在对称多处理器的扩展性； 通过负载均衡保证多个运行队列中任务的平衡；   完全公平调度器 · v2.6.23 ~ 至今  引入红黑树和运行时间保证调度的公平性； 引入调度类实现不同任务类型的不同调度策略；    本文会详细介绍从最初的调度器到今天复杂的完全公平调度器（Completely Fair Scheduler，CFS）的演变过程。\nLinux 初始的调度算法 #  Linux 最初的进程调度器仅由 sched.h 和 sched.c 两个文件构成。你可能很难想象 Linux 早期版本使用只有几十行的 schedule 函数负责了操作系统进程的调度：\nvoid schedule(void) {  int i,next,c;  struct task_struct ** p;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) {  ...  }  while (1) {  c = -1;  next = 0;  i = NR_TASKS;  p = \u0026amp;task[NR_TASKS];  while (--i) {  if (!*--p) continue;  if ((*p)-\u0026gt;state == TASK_RUNNING \u0026amp;\u0026amp; (*p)-\u0026gt;counter \u0026gt; c)  c = (*p)-\u0026gt;counter, next = i;  }  if (c) break;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p)  if (*p)  (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority;  }  switch_to(next); } 无论是进程还是线程，在 Linux 中都被看做是 task_struct 结构体，所有的调度进程都存储在上限仅为 64 的数组中，调度器能够处理的进程上限也只有 64 个。\n上述函数会先唤醒获得信号的可中断进程，然后从队列倒序查找计数器 counter 最大的可执行进程，counter 是进程能够占用的时间切片数量，该函数会根据时间切片的值执行不同的逻辑：\n 如果最大的 counter 时间切片大于 0，调用汇编语言的实现的 switch_to 切换进程； 如果最大的 counter 时间切片等于 0，意味着所有进程的可执行时间都为 0，那么所有进程都会获得新的时间切片；  Linux 操作系统的计时器会每隔 10ms 触发一次 do_timer 将当前正在运行进程的 counter 减一，当前进程的计数器归零时就会重新触发调度。\nO(n) 调度算法 #  数据结构：进程描述符 #  每个进程都有一个 task_struct 结构。该结构定义在 \u0026lt;include/linux/sched.h\u0026gt; 文件中，其中部分与进程调度相关的字段说明如下：\n  need_resched：调度标志，决定是否调用 schedule() 函数。\n  counter：进程处于可运行状态时所剩于的时钟节拍数。每次时钟中断到来时，update_process_times()对该值减 1。\n 创建新进程时，do_fork()以下列方式设置 current(父)和 p(子)进程的 counter 字段：current-\u0026gt;counter \u0026gt;\u0026gt;=1; p-\u0026gt;counter = current-\u0026gt;counter. 也就是说，父进程剩余的节拍数被分为两部分，一部分给父进程，一部分给子进程。这样做时为了防止通过 fork 子进程的方法无限制地使用 CPU 的时间。    rt_priority：实时进程的实时优先级。取值范围 1-99。\n  nice: 进程的静态优先级，它的值决定了 counter 的初值。nice 的取值范围是-20(优先级高)~19(优先级低)，缺省为 0。该值可通过 nice 系统调用改变。\n  policy： 本进程的调度策：\n SCHED_RR 和 SCHED_FIFO 用于实时进程。SCHED_RR 和 SCHED_FIFO 的调度策略在 rt_priority 不同的时候，都是谁的优先级高谁先执行，唯一的不同是相同优先级的处理： SCHED_RR 是时间片轮转的实时进程。当多个进程具有同一优先级时，采用时间片轮转轮流调度运行。适用于实时性要求较高但每次运行耗时较长的进程。 SCHED_FIFO 是先入先出的实时进程，先占有 CPU 的进程会持续执行，直到退出或者阻塞的时候才会让出 CPU。也只有这时候，其他同优先级的实时进程才有机会执行。适应于实时性要求比较强、而每次运行的耗时又比较短的进程。 SCHED_OTHER 用于普通的分时进程。  除了上面描述的三种调度策略，policy 成员也可以设定 SCHED_YIELD 的标记，它和调度策略无关，主要处理 sched_yield 系统调用的。\n  state: 表示进程当前运行状态：\n  TASK_RUNNING ：该状态表示这个进程可被调度执行而成为当前进程，是进程表达了希望被调度运行的意愿，内核会将该进程的 task_struct 结构加入可运行队列。\n  TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE ：这两个状态都表示进程处于睡眠状态。前者表示浅度睡眠，可被信号唤醒；后者表示深度睡眠。sleep_on 和 wake_up 用于深度睡眠；而 interruptible_sleep_on 和 interruptible_wake_up 则用于浅度睡眠。\n  TASK_ZOMBIE 表示已退出而暂时没有被父进程收回资源的\u0026quot;僵尸\u0026quot;进程。\n  TASK_STOPPED 主要用于调试目的。进程接收到一个 SIGSTOP 信号后就将运行状态改成 TASK_STOPPED 而进入挂起状态，然后在接收到一个 SIGCONT 信号时又恢复继续运行。\n    调度的时机 #  Linux 的调度程序是一个叫 schedule()的函数，由它来执行具体的调度算法。调用 schedule()的时机主要包括：\n直接调用 #    进程入睡时主动调用 schedule()：当现运行进程请求资源被阻塞时，会调用 sleep_on()或 interruptible_sleep_on()进入睡眠状态，这时会执行以下步骤：\n  把当前进程 current 插入到合适的等待队列中。\n  把当前进程 current 的状态修改为 TASK_INTERUPTIBLE 或 TASK_UNINTERUPTIBLE。\n  调用 schedule() 函数。\n  检查那个资源是否可用。如果不，转到第 2 步。\n  一旦那个资源成为可用的，把 current 从等待队列中删除。\n    进程终止时主动调用 schedule()：当现运行进程终止时，会调用 exit() 终止运行，这时会主动调用 schedule() 函数。\n  设备驱动程序执行长而重复的任务时，主动调用 schedule()：驱动程序在每次循环中，都会去检查调度标志 need_resched 的值，如果必要，就调用 schedule()主动放弃 CPU。\n  创建新进程：在 do_fork()中也会调用 schedule() 函数。\n  延迟调用 #  延迟调用是指当系统需要调度时，通过置现运行进程 need_resched 标志为 1。然后在从中断、异常、系统调用等从内核返回用户态时，对该标志进行检测，如果该标志为 1，则调用 schedule()。主要包括以下情况：\n  在中断处理过程中，发现 current 用完了时间片，置 need_resched 标志为 1。\n  一个进程被唤醒，且它的优先级比现运行进程更高，置 need_resched 标志为 1。\n  当父进程 fork 子进程时，其时间片会均分到父子进程。\n 如果只剩下一个 tick，这个 tick 会分配给子进程，而父进程的时间片则被清零，这时候等同于情况 1。 否则，父子进程的时间片都不为 0，这时等同于情况 2。    一个进程通过系统调用改变调度政策(sched_setscheduler)或表示礼让(sched_yield)时，会设置 need_resched 标志为 1。\n  如何计算优先级：godness() #  调度算法的核心是在可运行队列链表中的所有进程中确定优先级最高的进程。goodness() 就是用来计算进程优先级。它接受两个输入参数：prev(前一个运行进程)和 p(要评估的进程)，返回一个整数值 c，表示进程 p 的“值得运行的程度(goodness)”。\ngoodness()函数将实时进程和普通进程区分计算。流程如下：\n 如果该进程的 policy 被置 SCHED_YIELD 标志为，直接返回 -1。表示进程愿意“礼让”。 如果该进程是 SCHED_FIFO 或 SCHED_RR，直接返回：1000+ p-\u0026gt;rt_priority。可以看出，实时进程的优先级很高，且与 counter 和 nice 无关，至少为 1000，保证了实时进程会完全优先于普通进程的调度。 如果该进程是 SCHED_OTHER： 如果 p-\u0026gt;counter 为 0，直接返回 0。即该进程已用完时间片。 否则，返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice。 此外，在 2 的情况下，如果候选进程 p 是内核进程（无用户空间），或者 p 的用户空间与当前进程 prev 的用户空间相同，则返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice + 1。因为如果 p 正好在 prev 之后运行，它们将使用同一页表。  调度流程：schedule() #  可以将 schedule()函数大致分为以下三个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作  具体过程如下：\n初始化部分 #   current 的值保存在 prev 局部变量中, 将 prev-\u0026gt;need_resched 字段设为 0 判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。 prev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));  检查 prev 的状态，  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒:  prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。    确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。 检查候选进程 next：  如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。   检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。  进程切换之后的操作 #  执行__schedule_tail()，置 prev-\u0026gt;police 的 SCHED_YIELD 为 0。 函数返回。  如何重新分配时间片 #  在上一小节提到，当 c 为 0 时，说明可运行队列中没有实时进程，只有普通进程，且队列中所有普通进程的时间片都已用完，这时需要重新系统中所有进程的时间片（而不仅仅是可运行队列中的进程），计算方法为：\nfor_each_task(p)  p-\u0026gt;counter = (p-\u0026gt;counter \u0026gt;\u0026gt; 1) + NICE_TO_TICKS(p-\u0026gt;nice); 宏 NICE_TO_TICKS 的定义如下。以 HZ 为 200 为例，每秒中断 200 次，那么一个时钟滴答 tick 为 5ms，20 - nice 的取值为[1 ,40]，缺省为 20，将 20 右移 1 位即除以 2 为 10，10 个滴答即 50ms。当时钟频率 HZ 越高，每个滴答所代表的时间越短，NICE_TO_TICKS 分配的滴答数越多，但最大只是 20 – nice 的值左移 2 位即乘以 4，最大值为 160，仍小于实时进程的 1000。\n#if HZ \u0026lt; 200 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 2) #elif HZ \u0026lt; 400 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 1) #elif HZ \u0026lt; 800 #define TICK_SCALE(x) (x) #elif HZ \u0026lt; 1600 #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 1) #else #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 2) #endif #define NICE_TO_TICKS(nice) (TICK_SCALE(20-(nice))+1) 可以发现，经过重新计算后，那些不在可运行队列中的普通进程，会获得较高的时间配额，在将来的调度中会占一定的优势。但即使无数次更新方之后，counter 的值也不会超过两倍的 NICE_TO_TICKS，也不会超过实时进程的优先级。\nSMP 系统下的调度程序 #  Linux 为了支持对称多处理器(SMP)体系结构，必须对 Linux 的调度程序稍作修改。实际上，每个处理器运行它自己的 schedule()函数，但是，处理器间必须交换信息以提高系统性能。\n数据结构 #  schedule_data 结构体 #  如下所示，schedule_data 结构体用来很快的获得当前进程的描述符，每个 CPU 上都有一个该结构体。该结构体包含：\n 该 CPU 上现运行进程的描述符 task_struct。 现运行进程上台的时刻，即 schedule()是什么时候选 curr 作为运行进程。  struct schedule_data{  struct task_struct *curr;  unsigned long last_schedule; } struct schedule_data aligned_data[NR_CPUS]; task_struct 进程描述符 #  除了在上文提到的一些与进程调度相关的字段外，task_struct 还包含了几个与 SMP 相关的字段，包括：\n processor：表示该进程上一次运行在哪个 CPU 上。 avg_slice：表示该进程的平均时间片，即每次运行时间的期望值。  cacheflush_time 变量 #  cacheflush_time 变量表示对硬件高速缓存内容全部重写所需要花费的时间。这个值只是一个估值，大约不到 100 微秒。计算公式为：以 kHZ 为单位的 CPU 频率*以 KB 大小为单位的缓存容量/5000 在后面将看到，当现运行进程的 avg_slice – (time – last_schedule) \u0026lt; cacheflush_time，就不会执行进行的抢占。\nSMP 系统下调度流程：schedule() #  具体过程如下：\n  current 的值保存在 prev 局部变量中。prev-\u0026gt;processor 的值存放在 this_cpu 局部变量中。aligned_data[this_cpu]的值存放在 sched_data 局部变量中。将 prev-\u0026gt;need_resched 字段设为 0。\nprev = current; this_cpu = prev-\u0026gt;processor; sched_data = aligned_data[this_cpu];   判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。\nprev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));   检查 prev 的状态:\n   如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒: prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。  确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。在 goodness 函数中，检查进程的 processor 字段，并对最后在 this_cpu CPU 上执行的进程给与一定奖赏(PROC_CHANGE_PENALTY，通常为 15). 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。除此之外，做一些跟 CPU 相关的操作：   把 sched_data-\u0026gt;curr 置为 next。 next-\u0026gt;has_cpu 置为 1，next-\u0026gt;processor 置为 this_cpu。 在 t 局部变量中存放 current 时间标记寄存器的值，并执行： this_slice = t – sched_data-\u0026gt;last_schedule; sched_data-\u0026gt;last_schedule = t; prev-\u0026gt;avg_slice = (prev-\u0026gt;avg_slice + this_slice) / 2   检查候选进程 next：   如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。  检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。 进程切换之后的操作 当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 schedule()时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。如果 prev(即为 prev_new)还依然是可运行的，并且不是这个 CPU 的空任务，那么，对 prev 调用 reschedule_idle()函数。 把 prev 的 has_cpu 字段清 0。 函数返回。  SMP 系统下的 reschedule_idle() #  当进程 p 变为可运行时，执行 reschedule_idle()函数决定进程是否应该抢占某一 CPU 上的当前进程。具体过程如下：\n 如果 p 是实时进程，总会试图抢占，转到 3。 如果有一个 CPU 上的当前进程满足下列两个条件，则立即返回(不试图抢占)：  cacheflush_time 大于当前进程的平均时间片。防止高速缓存变得太“脏”。 为了存取某一临界内核数据结构，p 和当前进程都需要全局内核锁。   接下来执行 CPU 选择算法：  如果 p-\u0026gt;processor (即 p 最后运行的 CPU)是空闲的，选它。 遍历所有 CPU，对其上正在运行的任务 tsk，计算以下差值：goodness(tsk, p) - goodness(tsk, tsk), 如果这个差值为正，就选择差值最大的 CPU。   如果选择了某个 CPU，给选中的 CPU 的正在运行进程的 need_resched 字段置 1，并向这个 CPU 发处理器间中断：RESCHEDULE_VECTOR interprocessor interrupt。  O(1) 调度算法 #  O(n) 调度算法缺陷 #  Linux2.4 之前的版本，用较为简单的调度算法实现了进程调度。但是该算法存在以下问题：\n  算法复杂度问题。遍历运行队列的算法复杂度为 O(n)，意味着队列越长，选中一个进程所需要的时间就越长。此外，每次调度周期结束后，为每一个进程计算其时间片的过程太耗费时间。\n  多处理器问题。多个处理器上的进程放在一个就绪队列中，使得这个就绪队列成为临界资源，为了实现内核同步机制，需要对其上自旋锁，降低了系统效率。\n  CPU 空转问题。在 runqueue 队列中的全部进程时间片被耗尽之前，系统总会处于这样一个状态：最后的一组尚存时间片的进程分分别调度到各个 CPU 上去。我们以 4 个 CPU 为例，T0 ～ T3 分别运行在 CPU0~CPU3 上。随着系统的运行，CPU2 上的 T2 首先耗尽了其时间片，但是这时候，其实 CPU2 上也是无法进行调度的，因为遍历 runqueue 链表，找不到适合的进程调度运行，因此它只能是处于 idle 状态。也许随后 T0 和 T3 也耗尽其时间片，从而导致 CPU0 和 CPU3 也进入了 idle 状态。现在只剩下最后一个进程 T1 仍然在 CPU1 上运行，而其他系统中的处理器处于 idle 状态，白白的浪费资源。唯一能改变这个状态的是 T1 耗尽其时间片，从而启动一个重新计算时间片的过程，这时候，正常的调度就可以恢复了。随着系统中 CPU 数目的加大，资源浪费会越来越严重。\n  SMP 亲和力问题。在一个新的周期开后，runqueue 中的进程时间片都是满满的，在各个 CPU 上调度进程的时候，它可选择的比较多，再加上调度器倾向于调度上次运行在本 CPU 的进程，因此调度器有很大的机会把上次运行的进程调度到同一个处理器上。但是随着 runqueue 中的进程一个个的耗尽其时间片，cpu 可选择的余地在不断的压缩，从而导致进程执行在一个和它亲和性不大的处理器（例如上次该进程运行在 CPU0，但是这个将其调度到 CPU1 执行，但是实际上该进程和 CPU0 的亲和性更大些）。\n  实时进程调度性能问题。实时进程和普通进程挂在一个链表中，当调度实时进程的时候，我们需要遍历整个 runqueue 列表，扫描并计算所有进程的优先级，再从中选择出最终要调度的实时进程，在这过程中，一些时间片已经耗完的进程在不可能参与调度的情况下，依然会参与调度选择的过程。此外，整个 linux 内核不是抢占式内核，对于一些比较耗时的系统调用或者中断处理，必须返回用户空间才启动调度，大大降低了实时进程的调度性能。\n  交互式普通进程的调度延迟问题。O（n）并不区分交互式进程和批处理进程，它只是奖励经常睡眠的那些进程。但是有些批处理进程也属于 IO-bound 进程，例如数据库服务进程，它本身是一个后台进程，对调度延迟不敏感，但是由于它需要和磁盘打交道，因此也会经常阻塞在 disk IO 上。对这样的后台进程进行动态优先级的升高其实是没有意义的，会增大其他交互式进程的调度延迟。\n  虽然 O（n）调度器存在不少的问题，但是社区的人还是基本认可这套算法的，因 此在设计新的调度器的时候并不是完全推翻 O（n）调度器的设计，而是针对 O（n）调度器的问题进行改进。\n从以上分析中可以看出，单运行队列是影响调度性能的主要问题之一，因此改进运行队列就成为改进调度算法的入口点。\n基于此，O(1)调度器为每个 CPU 设置一个运行队列，并且为每个运行队列再设置两个队列：活动队列和时间片过期队列。每个队列中的元素以优先级再进行分类，相同优先级的进程为一个队列，最多可以有 140 个优先级。为了快速选中要运行的进程，设置以优先级为序的队列位图，位图的每一位对应一个队列，只要队列中有一个可运行进程，该位置 1，否则置 0。这样，无需遍历所有队列，而只要遍历位图，找到有可运行进程的队列，该队列的第一个进程就是被选中的进程。该算法的复杂度为 O(1). 如图所示：\n通过将单链表变成多个链表，可以解决上述大部分问题：\n 算法复杂度问题：O(1)调度器算法通过优先级位图，以及活动队列与过期队列指针交换，实现了 O(1)的复杂度，而不是遍历运行队列，并重新计算所有进程的时间片。 多处理器问题：由于每个 CPU 都有一个运行队列，因此 O(1)调度器就不需要全局运行队列的自旋锁，而只需要把这个自旋锁放入到每个 CPU 的运行队列数据结构中，通过把一个大锁细分成小锁，可以大大降低调度延迟，提升系统响应时间。。 CPU 空转问题：O(1)调度器每个 CPU 都有一个运行队列，当一个进程的时间片耗尽，在被移动到过期数组之前，会重新计算其时间片，而不是等到一个调度周期结束再重新计算进程时间片，因此解决了 CPU 空转问题。 SMP 亲和力问题：O(1)调度器设置了较为合理的负载均衡算法，只有在需要平衡任务队列大小时才在 CPU 之间移动进程。 实时进程与交互式调度性能问题：为了提高交互时进程和实时进程的响应时间，当前进程的时间片为 0 时，判断当前进程的类型，如果时交互式进程或实时进程，则重置其时间片并重新插入活动队列，否则插入过期队列，这样交互式进程和实时进程总能优先获得 CPU。然而当这些进程已经占用 CPU 时间超过一个固定值后，也会被移到过期队列中，避免其他进程产生饥饿现象。  数据结构 #  runqueue 数据结构 #  runqueue 可执行队列是调度程序中最基本的数据结构。定义于 kernel/sched.c 中。如上所述，每个 CPU 包含一个可执行队列；每个就绪进程都唯一地归属于某一个可执行队列。此外，可执行队列中还包含着每个 CPU 的调度信息。其包含的字段如下图所示：\n优先级数组 #  如上所述，每个运行队列有活动队列和过期队列两个优先级数组，每个数组是一个 prio_array 类型的结构体。优先级数组使得该调度算法复杂度为 O(1)。\n 计数器 nr_active 是一个计数器，保存可运行进程数目。 bitmap 是优先级位图数组。其中 BITMAP_SIZE 是位图数组的大小，类型为 unsigned long 长整型，长 32 位，每一位包含一个优先级，140 个优先级需要 5 个长整型数表示。bitmap 一开始所有的位都被置 0。当某个进程状态变为 TASK_RUNNING 时，对应的位被置 1。这样，查找系统中最高的优先级就变成了查找位图中被设置的第一个位。 queue 是优先级链表数组，一个链表对应一种优先级。每个链表包含了该 CPU 上相应优先级的全部可运行进程。其中 MAX_PRIO 定义了系统拥有的优先级个数，默认为 140。  进程描述符 #  与 linux 2.4 的进程描述符有些差异，其与调度相关的字段如下：\n进程的优先级 #  普通进程 #  静态优先级 #  普通进程的静态优先级保存在 static_prio 成员中，取值范围是 100（优先级最高）～ 139（优先级最低），分别对应 nice 值的-20 ～ 19。静态优先级本质上决定了进程的基本时间片，对应公式如下：\n由该公式得到一些普通进程优先级的典型值如下：\n动态优先级 #  在实际调度的时候使用的是动态优先级。普通进程的动态优先级保存在进程描述符的 prio 成员中。取值范围是 100（优先级最高）～ 139（优先级最低），和静态优先级一致。动态优先级根据以下公式得出：\n其中，bonus 取值范围 0~10，值小于 5 表示惩罚，大于 5 表示奖赏。bonus 的取值与进程的平均睡眠时间相关，如下表。需要说明的是，平均睡眠时间是进程在睡眠状态所消耗的平均纳秒数，但不是对过去时间的求平均值操作。例如，在 TASK_INTERRUPTIBLE 状态与在 TASK_UNINTERRUPTIBLE 状态所计算出的平均睡眠时间是不同的。而且，平均睡眠时间永远不会大于 1s.\n平均睡眠时间也被调度程序用来确定一个给定进程是交互式进程还是批处理进程。如果满足下列公式，则被看作是交互式进程：\n其中，静态优先级/4-28 被称为交互时的 δ。可以推出，高优先级的进程比低优先级的进程更容易成为交互式进程。例如，最高静态优先级(100)的进程，当他的 bonus 值超过 2，即睡眠时间超过 200ms 时，就被看作是交互式进程。\n实时进程 #  实时进程的实时优先级，存在进程描述符的 rt_priority 成员中，取值范围是 1（优先级最低）～ 99（优先级最高）。需要注意的是，当系统调用 nice()和 setpriority()用于基于时间片轮转的实时进程时，不改变实时进程的优先级，而会改变其基本时间片的长度。也就是说，基于时间片轮转的实时进程的基本时间片的长度与实时进程的优先级无关，而依赖于进程的静态优先级，它们的关系同普通进程下的公式一样。\n普通进程采用复杂的公式计算动态优先级，而实时进程不计算动态优先级，保证了给定优先级别的实时进程总能抢占优先级比它低的进程。\n调度程序所使用的函数 #  调度程序使用几个函数来完成调度工作，其中最重要的函数说明如下：\nscheduler_tick() #  每次时钟节拍到来时，scheduler_tick()被调用，执行以下步骤：\n 把转换为纳秒的 TSC 的当前值存到本地运行队列的 timestamp_last_tick 字段。这个时间戳是从 sched_clock()函数得到。 检查当前进程是不是本地 CPU 的 swapper 进程，如果是，则检查本地运行队列除了 swagger 进程外，是不是还有另外的可运行进程，如果是，就设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。之所以会出现这种情况，是因为如果内核支持超线程技术，那么只要一个逻辑 CPU 运行队列中的所有进程都比另一个逻辑 CPU 上已经在执行的进程优先级低得多，而两个逻辑 CPU 是对应同一个物理 CPU 的，因此，前一个逻辑 CPU 就可能空闲，即使它的运行队列中也有可运行的进程。执行完上述检查后，直接跳到第 7 步，因为不需要更新 swagger 进程的时间片。 检查 current-\u0026gt;array 是否指向本地运行队列的活动链表，如果不是，说明进程已经过期但还没有被替换，则设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。然后直接跳到第 7 步。 获得 this_rq()-\u0026gt;lock 自旋锁 根据进程不同类型执行不同操作：    如果当前进程是 FIFO 的实时进程，则什么也不做，跳到 6。\n  当前进程是基于时间片轮转的实时进程：递减当前进程时间片，如果时间片已经用完，则：\n 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice= 0。该字段是在 fork()系统调用服务例程中的 copy_process()中设置，并在进程的第一个时间片用完时清 0。 调用 set_tsk_need_resched()设置进程的 TIF_NEED_RESCHED 字段。 iv. 把当前进程移到当前的运行队列尾部。    当前进程是普通进程：递减当前进程时间片，如果时间片已经用完：\n 将当前进程从活动队列(this_rq()-\u0026gt;active)中移除。 调用 set_tsk_need_resched() 设置进程的 TIF_NEED_RESCHED 字段。 更新当前进程的动态优先级。current-\u0026gt;prio = effective_prio(current). 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice 清 0。 如果 this_rq()-\u0026gt;expired_timestamp 字段为 0（表示过期队列为空），把当前进程的时钟节拍 jiffies 赋值给 this_rq()-\u0026gt;expired_timestamp。 把当前进程插入活动队列或过期队列：  if (!TASK_INTERACTIVE(current) || EXPIRED_STARVING(this_rq()))  enqueue_task(current, this_rq()-\u0026gt;expired); else  enqueue_task(current, this_rq()-\u0026gt;active); 其中, TASK_INTERACTIVE 宏用于识别一个进程是不是交互式进程。EXPIRED_STARVING 宏负责检查过期队列中的进程是否处于饥饿状态：如果已经有相对较长时间没有发生数组切换了，那么再把当前的进程放置到活动数组，则会加重过期队列中进程的饥饿状态。\n否则，如果时间片没有用完，检查当前进程的剩余时间片是否太长：\nif (TASK_INTERACTIVE(p) \u0026amp;\u0026amp; !((task_timeslice(p) – p-\u0026gt;time_slice) %TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;time_slice \u0026gt;= TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;array == rq-\u0026gt;active)) {  list_del(\u0026amp;current-\u0026gt;run_list);  list_add_tail(\u0026amp;current -\u0026gt; run_list, this_rq()-\u0026gt;active-\u0026gt;queue+current-\u0026gt;prio);  set_tsk_need_resched(p); } 其中，宏 TIMESLICE_GRANULARITY 产生两个数的乘积给当前进程的 bonus，其中一个数为系统中 CPU 的数量，另一个为成比例的常量。基本上，具有高静态优先级的交互式进程，其时间片被分成大小为 TIMESLICE_GRANULARITY 的几个片段，以使这些进程不会独占 CPU。\n  释放 this_rq()-\u0026gt;lock 自旋锁。 调用 rebalance_tick()函数，保证不同 CPU 的运行队列包含数量基本相同的可运行进程。  从第 5 步中可以看出，对于 O(1)调度器，时间片的重新赋值是分散处理的，在各个进程耗尽其时间片之后立刻进行的。修正了 O(n)调度器一次性的遍历系统所有进程，重新为时间片赋值的过程。\n唤醒：try_to_wake_up() #  该函数通过把进程状态设置为 TASK_RUNNING，并调用 activate_task()函数将此进程放入对应的可运行队列中来唤醒睡眠或停止的进程。\n该函数接受的参数有：\n 被唤醒进程的描述符指针 p. 可以被唤醒的进程状态掩码(state)。 一个标志(syn)，用来禁止被唤醒的进程抢占本地 CPU 上正在运行的进程。  该函数执行以下操作：\n 禁本地中断，并获得最后执行该进程的 CPU 的运行队列的锁。 检查进程状态 p-\u0026gt;state == state。如果不是，直接跳到 9 终止函数。 如果 p-\u0026gt;arrray != NULL ,说明该进程已经属于某个运行队列，跳到 8. 确定目标 CPU：  如果有空闲的 CPU，就选空闲的 CPU。 如果先前执行进程的 CPU 的工作量远小于本地 CPU 的工作量，选前者。 如果进程最近被执行过，就选这个老的运行队列。 如果把进程迁移到本地 CPU 可以缓解 CPU 之间的不平衡，则选本地 CPU。   如果进程处于 TASK_UNINTERRUPTIBLE 状态，则递减目标运行队列的 nr_uninterruptible 字段，并把 p-\u0026gt;activated 字段置为-1。 调用 activate_task()函数，执行：  调用 sched_clock()获取以纳秒为单位的当前时间戳。如果目标 CPU 不是本地 CPU，就要补偿本地时钟中断的偏差：now=(shced_clock()–this_rq()-\u0026gt;timesamp_last_tick)+rq-\u0026gt;timestamp_last_tick 调用 recalc_task_prio()。 设置 p-\u0026gt;activated 字段的值。 使用 now 设置 p-\u0026gt;timestamp 字段。 把进程描述符插入活动队列，且 rq-\u0026gt;nr_running++。   如果目标 CPU 不是本地 CPU，或者没有设置 sync 标志，则，如果该进程优先级更高 p-\u0026gt;prio \u0026gt; rq-\u0026gt;curr-\u0026gt;prio，就调用 resched_task()抢占 rq-\u0026gt;curr。  单处理器系统，设置 rq-\u0026gt;curr 进程的 TIF_NEED_RESCHED 标志。 多处理器系统，如果 TIF_NEED_RESCHED 旧值为 0，且目标 CPU 没有轮询进程 TIF_NEED_RESCHED 标志的值，则发送处理器间中断 IPI，强制目标 CPU 重新调度。   把当前进程 p-\u0026gt;state 字段设为 TASK_RUNNING。 开 rq 运行队列的锁，打开本地中断。 如果成功唤醒返回 1，否则返回 0.  计算动态优先级：recalc_task_prio() #  recalc_task_prio() 函数更新进程的平均睡眠时间和动态优先级。\n该函数接受的参数有：\n 进程描述符指针 p。 当前时间戳 now。  该函数执行以下操作：\n 把 min(now – p-\u0026gt;timestamp, 109)的结果赋值给局部变量 sleep_time，表示进程消耗在睡眠状态的纳秒数。如果超过 1 秒，就设为 1 秒. 如果 sleep_time 不大于 0，直接跳到 8. 检查进程是不是内核线程、进程是否从 TASK_UNINTERRUPTIBLE 状态（即 p-\u0026gt;activated 为-1）被唤醒、进程连续睡眠的时间是否超过给定的睡眠时间期限。如果这三个条件都满足，把 p-\u0026gt;sleep_avg 字段设置位相当于 900 个时钟节拍的值（用最大平均睡眠时间减去一个标准进程的基本时间片长度获得的一个经验值）。然后跳到 8. 计算进程原来的平均睡眠时间的 bonus 值。如果 10-bonus\u0026gt;0,则把 sleep_time 乘以 10-bonus。所以原来的 p-\u0026gt;sleep_avg 越小，bonus 值越小，10-bonus 越大，sleep_time 越大，最终的 p-\u0026gt;sleep_avg 增加的就越快。 如果进程处于 TASK_UNINTERRUPTIBLE 状态而且不是内核线程：  检查平均睡眠时间 p-\u0026gt;sleep_avg 是否大于等于进程的睡眠时间极限。如果是，把 sleep_time 置为 0，直接跳到 6. 如果 sleep_time + p-\u0026gt;sleep_avg 大于等于睡眠时间极限，把 p-\u0026gt;sleep_avg 设为睡眠时间极限并把 sleep_time 置为 0 通过对进程平均睡眠时间的轻微限制，函数不会对睡眠时间很长的批处理进程给与过多的奖赏。   把 sleep_time 加到进程的平均睡眠时间 p-\u0026gt;sleep_avg 上。 检查 p-\u0026gt;sleep_avg 是否超过 1000 个时钟节拍，如果是，就置为 1000 个时钟节拍。 更新进程的动态优先级。p-\u0026gt;prio = effective_prio(p).  可以看到，在评估用户交互指数上，O(n)调度器仅仅考虑了睡眠进程的剩余时间片，而 O(1)调度器的“平均睡眠时间”算法考虑了更多的因素：在 cpu 上的执行时间、在 runqueue 中的等待时间、睡眠时间、睡眠时候的进程状态（是否可被信号打断），什么上下文唤醒（中断上下文唤醒还是在进程上下文中唤醒），因此 O(1)调度器更好的判断了进程是否属于交互式进程。\n调度流程： #  schedule() 与 O(n) 调度器类似，可以将 schedule() 函数大致分为以下四个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作 具体过程如下： 初始化部分 禁用内核抢占。current 的值保存在 prev 局部变量中，本地 CPU 的运行队列保存在 rq 局部变量中。 preempt_disable(); prev = current; rq = this_rq();  保证 prev 不占用大内核锁。通过进程切换会自动释放和重新获取大内核锁。 if (prev-\u0026gt;lock_dept \u0026gt;= 0)  up(\u0026amp;kernel_sem);  计算 prev 所用的 CPU 时间片长度： now = sched_clock(); run_time = now – prev-\u0026gt;timesamp; if (run_time \u0026gt; 1000000000)  run_time = 1000000000 run_time /= (CURRENT_BONUS(PREV) ? : 1) run_time 用来限制进程对 CPU 的使用，最多 1 秒。不过，当进程有较长睡眠时间时，CURRENT_BONUS()返回值越大，run_time 就会被降低。这是对较长平均睡眠时间的奖赏。 关本地中断，获得运行队列的自旋锁：spin_lock_irq(\u0026amp;rq-\u0026gt;lock) 检查 prev 是不是一个正在被终止的进程： if (prev-\u0026gt;flags \u0026amp; PF_DEAD)  prev-\u0026gt;state = EXIT_DEAD;  检查 prev 的状态，如果不是 TASK_RUNNING 可运行状态，而且没有在内核态被抢占：  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就让其变为可运行状态：prev-\u0026gt;state = TASK_RUNNING 以唤醒这个进程。 否则，调用 deactivate_task()函数从运行队列中删除 prev 进程,。同时，如果该进程状态是 TASK_UNINTERUPTIBLE，则 rq-\u0026gt;nr_uniterruptible++.  rq-\u0026gt;nr_running--; dequeue_task(p, p-\u0026gt;array); p-\u0026gt;array = NULL;  检查运行队列中剩于的可运行进程数。如果有可运行进程，但是当前内核支持超线程技术，且可运行进程比在相同物理 CPU 的某个逻辑 CPU 上运行的兄弟进程优先级低，p-\u0026gt;sleep_avg直接去执行 swapper 进程。 如果没有可运行进程，函数调用 idle_balance()，从其他 CPU 迁移一些可运行进程到本地队列中。如果本地队列还是没有可运行进程，就重新调度空闲 CPU 的可运行进程。如果还是没有，则直接去执行 swapper 进程。 到这里运行队列中一定有可运行进程。检查运行队列中是否至少有一个进程是活动的(rq-\u0026gt;active-\u0026gt;nr_active\u0026gt;0)。如果没有，交换活动队列和过期队列的指针。  确定优先级最高的进程 next #   在优先级数组中查找第一个非 0 的位图对应的链表的第一个进程描述符，并赋值给 next。\n  检查 next-\u0026gt;activate 字段，该字段编码值表示进程在被唤醒时的状态，如下表：\n如果 next 是一个普通进程，并且 activate 为 1 或 2，就把自从进程插入运行队列开始所经过的纳秒数加到进程的平均睡眠时间。但是 1 和 2 的情况还是有区别，在 2 的情况下，增加全部运行队列等待时间，在 1 的情况下，只增加等待时间的部分。这是因为交互式进程更可能被异步事件(如键盘)而不是同步事件唤醒。\nif (next-\u0026gt;prio \u0026gt;= 100 \u0026amp;\u0026amp; next-\u0026gt; activate \u0026gt; 0){  unsigned long long delta = now – next-\u0026gt;timestamp;  if ( next-\u0026gt; activate == 1)  delta = (delta * 38) / 128;  array = next-\u0026gt;array;  dequeue_task(next, array);  recalc_task_prio(next, next-\u0026gt;timestamp + delt- ;  enqueue_task(next, array); } next-\u0026gt; activate = 0;   完成进程切换 #  如果最终的候选进程就是当前进程，释放自旋锁，不做进程切换，直接结束。 否则执行进程切换： next-\u0026gt;timestamp = now; rq-\u0026gt;nr_switches ++; rq-\u0026gt;current = next; prev = context_switch(rq, prev, next) 其中 context_switch()函数建立 next 的地址空间。  如果 next 是内核进程，则借用 prev 的 active_mm。 if ( ! next_mm ){ next-\u0026gt;active_mm = prev-\u0026gt;active_mm; atomic_inc(\u0026amp;prev-\u0026gt;active_mm-\u0026gt;mm_count); enter_lazy_tlb( prev-\u0026gt;active_mm, next) }  如果 next 是普通进程，则执行 switch_mm 切换用户空间，把虚拟内存从上一个进程映射切换到新进程中。 if ( next_mm ){ switch_mm( prev-\u0026gt;active_mm, next-\u0026gt;mm, next); }    如果 prev 是内核进程或正在退出的进程： if ( ! prev_mm ){  rq-\u0026gt;prev_mm = prev-\u0026gt;active_mm;  prev-\u0026gt;active_mm = NULL; }  调用 switch_to()进行真正的进程切换，从上一个进程的处理器状态切换到新进程的处理器状态，包括保存、恢复栈信息和寄存器信息。 switch_to( prev, next, prev);   进程切换之后的操作 #   当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 p-\u0026gt;sleep_avg时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。进程切换后的第一部分指令是：\nbarrier(); finish_task_switch( prev); 其中 finish_task_switch(prev) 函数如下：\nmm = this_rq()-\u0026gt;prev_mm; this_rq()-\u0026gt;prev_mm = NULL; prev_task_flags = prev-\u0026gt;flags; spin_unlock_irq(\u0026amp; this_rq()-\u0026gt;lock); if (mm)  mmdrop(mm) if (prev_task_flags \u0026amp; PF_DEAD)  put_task_struct( prev); 其中 mmdrop()减少内存描述符的使用计数器。如果减到了 0，释放与页表相关的所有描述符和虚拟存储区。put_task_struct()释放进程描述符使用计数器，并撤销所有其余对该进程的引用。\n  p-\u0026gt;sleep_avg函数最后一部分代码如下。包括在需要的时候重新获得大内核锁，重新启用内核抢占，并检查是否一些其他的进程已经设置了当前进程的 TIF_NEED_RESCHED。如果是，则整个 p-\u0026gt;sleep_avg函数重新执行，否则函数结束。\nprev = current; if (prev-\u0026gt;lock_depth \u0026gt;= 0)  __reacquire_kernel_lock(); preempt_enable_no_resched(); if (test_bit(TIF_NEED_RESCHED, \u0026amp;current_thread_info() -\u0026gt; flags))  goto need_resched; return;   多处理器系统中运行队列的平衡 #  从 Linux2.6.7 版本开始，Linux 提出一种基于“调度域”概念的复杂的运行队列平衡算法，从而能够容易适应各种已有的多处理器体系结构。并提供了以下函数：\n  rebalance_tick()函数会在每一次时钟节拍到来时由 scheduler_tick()调用，负责周期性、在需要的时候调用 load_balance()函数。\n  load_balance()函数检查调度域是否处于严重的不平衡状态，如果是，将会尝试调用 move_task()函数把一些进程从一个运行队列迁移到另一个运行队列。\n  move_task()函数负责把进程从源运行队列迁移到本地运行队列。\n  其中比较重要的 load_balance()函数可简单描述为如下操作：\n1、 调用 find_busiest_queue()，找到最繁忙的可运行队列，即该队列中的进程数目最多。如果没有哪个可运行队列中进程的数目比当前队列中的数目多 25%或更多，就返回 NULL，并且 load_balance()函数也返回。否则返回最繁忙的可运行队列。\n2、 从最繁忙的运行队列中选择一个优先级数组以便抽取进程，最好是过期数组，因为那里面的进程已经相当较长一段时间没有运行了，很可能不在 CPU 的高速缓存中。如果过期数组为空，那就只能选活动数组。\n3、 找到含有进程并且优先级最高的链表。\n4、 分析找到的所有这些优先级相同的进程，选择一个不是正在执行，也不会因为 CPU 相关性而不可移动，并且不在高速缓存中的进程。如果有进程满足以上条件，调用 move_task()将其从最繁忙的队列迁移到当前队列。\n5、 只要可运行队列之间仍然不平衡，就重复上面两个步骤，最终达到平衡。此时，解除对当前运行队列的锁定，从 load_balance()返回。\n抢占 #  用户抢占 #  用户抢占是指在内核即将返回用户空间的时候，如果 need_resched 标志被设置，会导致 p-\u0026gt;sleep_avg被调用，此时就发生了用户抢占。与延迟调用小节描述的一样，用户抢占在从系统调用或中断处理程序返回用户空间时发生。\n内核抢占 #  在不支持内核抢占的内核中，内核代码可以一直执行，直到完成返回用户空间或者明显的阻塞为止。也就是说，调度程序没办法在一个内核任务正在执行的时候发起调度。在 2.6 版本的内核中，引入了内核抢占能力，只要重新调度是安全的，即，只要没有持有锁，那么正在执行的代码就是可重新导入的，内核就可以在任何时间抢占正在执行的任务。\n为了支持内核抢占，为每个进程的 thread_info 引入了 preempt_count 计数器。该计数器初始值为 0，每当使用锁的时候加 1，释放锁的时候减 1.当该值为 0 时，表示内核可以抢占。\n因此，从中断返回内核空间的时候，内核会检查 need_resched 和 preempt_count 的值。如果 need_resched 被设置，且 preempt_count 为 0，说明有一个更为重要的任务需要执行并且可以安全的抢占，此时，调度程序就会被调用。此外，如果当前进程持有的所有锁都被释放了，此时会去检查 need_resched 是否被设置，如果是就调用调度程序。\n如果内核中的进程被阻塞了，或它显示地调用 p-\u0026gt;sleep_avg，内核抢占就显式地发生，这种形式的内核抢占一直都是支持的，因为无需额外的逻辑来保证内核可以安全的被抢占。\n楼梯调度算法与 RSDL 调度算法 #  O(1)调度器区分交互式进程和批处理进程的算法与以前虽大有改进，但仍然在很多情况下会失效。有一些著名的程序(如 fiftyp.c, thud.c, chew.c, ring-test.c)总能让该调度器性能下降，导致交互式进程反应缓慢。\n为了解决这些问题，大量难以维护和阅读的复杂代码被加入 Linux2.6.0 的调度器模块，虽然很多性能问题因此得到了解决，可是另外一个严重问题始终困扰着许多内核开发者。那就是代码的复杂度问题。这些不足催生了 Con Kolivas 的楼梯调度算法 SD，为调度器设计提供了一个新的思路。之后的 RSDL 和 CFS 都基于 SD 的许多基本思想。\n楼梯调度算法 #  O(1)调度器算法的主要复杂性来自动态优先级的计算，调度器根据平均睡眠时间和一些很难理解的经验公式来修正进程的优先级以及区分交互式进程。这样的代码很难阅读和维护。\n楼梯调度算法(staircase scheduler)抛弃了动态优先级的概念，而采用了一种完全公平的思路。其思路虽然简单，但是实验证明它对应交互式进程的响应比 O(1)调度器更好，而且极大地简化了代码。\n和 O(1)调度器一样，楼梯算法也同样为每一个优先级维护一个进程队列，并将这些队列组织在 active 数组中。当选取下一个被调度进程时，SD 算法也同样从 active 数组中直接读取。 与 O(1)算法不同在于，当进程用完了自己的时间片后，并不是被移到 expire 数组中。而是被加入 active 数组的低一优先级列表中，即将其降低一个级别。不过请注意这里只是将该任务插入低一级优先级任务列表中，任务本身的优先级并没有改变。当时间片再次用完，任务被再次放入更低一级优先级任务队列中。就像一部楼梯，任务每次用完了自己的时间片之后就下一级楼梯。\n任务下到最低一级楼梯时，如果时间片再次用完，它会回到初始优先级的下一级任务队列中。比如某进程的优先级为 1，当它到达最后一级台阶 140 后，再次用完时间片时将回到优先级为 2 的任务队列中，即第二级台阶。不过此时分配给该任务的 time_slice 将变成原来的 2 倍。比如原来该任务的时间片 time_slice 为 10ms，则现在变成了 20ms。基本的原则是，当任务下到楼梯底部时，再次用完时间片就回到上次下楼梯的起点的下一级台阶。并给予该任务相同于其最初分配的时间片。总结如下：设任务本身优先级为 P，当它从第 N 级台阶开始下楼梯并到达底部后，将回到第 N+1 级台阶。并且赋予该任务 N+1 倍的时间片。\n以上描述的是普通进程的调度算法，实时进程还是采用原来的调度策略，即 FIFO 或者 Round Robin。\n楼梯算法能避免进程饥饿现象，高优先级的进程会最终和低优先级的进程竞争，使得低优先级进程最终获得执行机会。\n对于交互式应用，当进入睡眠状态时，与它同等优先级的其他进程将一步一步地走下楼梯，进入低优先级进程队列。当该交互式进程再次唤醒后，它还留在高处的楼梯台阶上，从而能更快地被调度器选中，加速了响应时间。\n从实现角度看，SD 基本上还是沿用了 O(1)的整体框架，只是删除了 O(1)调度器中动态修改优先级的复杂代码；还淘汰了 expire 数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。\nRSDL 调度算法 #  RSDL（The Rotating Staircase Deadline Schedule）也是由 Con Kolivas 开发的，它是对 SD 算法的改进。核心的思想还是“完全公平”。没有复杂的动态优先级调整策略。\nRSDL 重新引入了 expire 数组。它为每一个优先级都分配了一个 “组时间配额”， 我们将组时间配额标记为 Tg；同一优先级的每个进程都拥有同样的\u0026quot;优先级时间配额\u0026quot;，本文中用 Tp 表示，以便于后续描述。\n当进程用完了自身的 Tp 时，就下降到下一优先级进程组中。这个过程和 SD 相同，在 RSDL 中这个过程叫做 minor rotation。请注意 Tp 不等于进程的时间片，而是小于进程的时间片。下图表示了 minor rotation。进程从 priority1 的队列中一步一步下到 priority140 之后回到 priority2 的队列中，这个过程如下图左边所示，然后从 priority 2 开始再次一步一步下楼，到底后再次反弹到 priority3 队列中。\n在 SD 算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得 CPU。因此低优先级进程的等待时间无法确定。RSDL 中，当高优先级进程组用完了它们的 Tg(即组时间配额)时，无论该组中是否还有进程 Tp 尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是 RSDL 中 Deadline 代表的含义。 进程用完了自己的时间片 time_slice 时（下图中 T2），将放入 expire 数组中它初始的优先级队列中(priority 1)。\n当 active 数组为空，或者所有的进程都降低到最低优先级时就会触发 major rotation：。Major rotation 交换 active 数组和 expire 数组，所有进程都恢复到初始状态，再一次从新开始 minor rotation 的过程。\n和 SD 同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为 minor rotation 而降到了低优先级进程队列中。当它重新进入 RUNNING 状态时，就获得了相对较高的优先级，从而能被迅速响应。\nCFS 完全公平调度算法 #  CFS 是最终被内核采纳的调度器。它从 RSDL/SD 中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS 的算法和实现都相当简单，众多的测试表明其性能也非常优越。\n按照作者 Ingo Molnar 的说法：\u0026ldquo;CFS 百分之八十的工作可以用一句话概括：CFS 在真实的硬件上模拟了完全理想的多任务处理器\u0026rdquo;。在“完全理想的多任务处理器“下，每个进程都能同时获得 CPU 的执行时间。当系统中有两个进程时，CPU 的计算时间被分成两份，每个进程获得 50%。然而在实际的硬件上，当一个进程占用 CPU 时，其它进程就必须等待。这就产生了不公平。\n假设 runqueue 中有 n 个进程，当前进程运行了 10ms。在“完全理想的多任务处理器”中，10ms 应该平分给 n 个进程(不考虑各个进程的 nice 值)，因此当前进程应得的时间是(10/n)ms，但是它却运行了 10ms。所以 CFS 将惩罚当前进程，使其它进程能够在下次调度时尽可能取代当前进程。最终实现所有进程的公平调度。下面将介绍 CFS 实现的一些重要部分，以便深入地理解 CFS 的工作原理[5]。\nCFS 如何选取下一个要调度的进程 #  CFS 抛弃了 active/expire 数组，而使用红黑树选取下一个被调度进程。所有状态为 RUNABLE 的进程都被插入红黑树。在每个调度点，CFS 调度器都会选择红黑树的最左边的叶子节点作为下一个将获得 cpu 的进程。\ntick 中断 #  在 CFS 中，tick 中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记 need_resched 标志，中断返回时就会调用 scheduler()完成进程切换。否则当前进程继续占用 CPU。从这里可以看到 CFS 抛弃了传统的时间片概念。Tick 中断只需更新红黑树，以前的所有调度器都在 tick 中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。\n红黑树键值计算 #  理解 CFS 的关键就是了解红黑树键值的计算方法。该键值由三个因子计算而得：一是进程已经占用的 CPU 时间；二是当前进程的 nice 值；三是当前的 cpu 负载。\n进程已经占用的 CPU 时间对键值的影响最大，其实很大程度上我们在理解 CFS 时可以简单地认为键值就等于进程已占用的 CPU 时间。因此该值越大，键值越大，从而使得当前进程向红黑树的右侧移动。另外 CFS 规定，nice 值为 1 的进程比 nice 值为 0 的进程多获得 10%的 CPU 时间。在计算键值时也考虑到这个因素，因此 nice 值越大，键值也越大。\n在本文中，我们将为每个进程维护的变量称为进程级变量，为每个 CPU 维护的称作 CPU 级变量，为每个 runqueue 维护的称为 runqueue 级变量。\nCFS 为每个进程都维护两个重要变量：fair_clock 和 wait_runtime。进程插入红黑树的键值即为 fair_clock – wait_runtime。\n fair_clock 从其字面含义上讲就是一个进程应获得的 CPU 时间，即等于进程已占用的 CPU 时间除以当前 runqueue 中的进程总数； wait_runtime 是进程的等待时间。它们的差值代表了一个进程的公平程度。该值越大，代表当前进程相对于其它进程越不公平。  对于交互式任务，wait_runtime 长时间得不到更新，因此它能拥有更高的红黑树键值，更靠近红黑树的左边。从而得到快速响应。 红黑树是平衡树，调度器每次总最左边读出一个叶子节点，该读取操作的时间复杂度是 O(LgN)。\n调度器管理器 #  为了支持实时进程，CFS 提供了调度器模块管理器。各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块。2.6.23 中，CFS 实现了两个调度算法，CFS 算法模块和实时调度模块。对应实时进程，将使用实时调度模块。对应普通进程则使用 CFS 算法。Ingo Molnar 还邀请 Con Kolivas 可以将 RSDL/SD 写成一个调度算法模块。\nCFS 源代码分析 #  每次时钟中断会调用 scheduler_tick()函数。它首先更新 runqueue 级变量 clock；然后调用 CFS 的 tick 处理函数 task_tick_fair()。task_tick_fair 主要工作是调用 entity_tick()。函数 entiry_tick 源代码如下：\nstatic void entity_tick(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  struct sched_entity _next;  dequeue_entity(cfs_rq, curr, 0);  enqueue_entity(cfs_rq, curr, 0);  next = **pick_next_entity(cfs_rq);  if (next == curr)  return;  __check_preempt_curr_fair(cfs_rq, next, curr,  sched_granularity(cfs_rq)); } 首先调用 dequeue_entity()函数将当前进程从红黑树中删除，再调用 enqueue_entity()重新插入。这两个动作就调整了当前进程在红黑树中的位置。_pick_next_entity()返回红黑树中最左边的节点，如果不再是当前进程，就调用_check_preempt_curr_fair。该函数设置调度标志，当中断返回时就会调用 p-\u0026gt;sleep_avg进行调度。 函数 enqueue_entity()的源码如下:\nenqueue_entity(struct cfs_rq _cfs_rq, struct sched_entity _se, int wakeup) {  update_curr(cfs_rq);  if (wakeup)  enqueue_sleeper(cfs_rq, se);  update_stats_enqueue(cfs_rq, se);  __enqueue_entity(cfs_rq, se); } 它的第一个工作是更新调度信息。然后将进程插入红黑树中。其中 update_curr()函数是核心。完成调度信息的更新:\nstatic void update_curr(struct cfs_rq _cfs_rq) { struct sched_entity _curr = cfs_rq_curr(cfs_rq); unsigned long delta_exec; if (unlikely(!curr)) return; delta_exec = (unsigned long)(rq_of(cfs_rq)-\u0026gt;clock - curr-\u0026gt;exec_start); curr-\u0026gt;delta_exec += delta_exec; if (unlikely(curr-\u0026gt;delta_exec \u0026gt; sysctl_sched_stat_granularity)) { __update_curr(cfs_rq, curr); curr-\u0026gt;delta_exec = 0; } curr-\u0026gt;exec_start = rq_of(cfs_rq)-\u0026gt;clock; } 该函数首先统计当前进程所获得的 CPU 时间，rq_of(cfs_rq)-\u0026gt;clock 值在 tick 中断中被更新，curr-\u0026gt;exec_start 就是当前进程开始获得 CPU 时的时间戳。两值相减就是当前进程所获得的 CPU 时间。将该变量存入 curr-\u0026gt;delta_exec 中。然后调用__update_curr():\n__update_curr(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  unsigned long delta, delta_exec, delta_fair, delta_mine;  struct load_weight _lw = \u0026amp;cfs_rq-load;  unsigned long load = lw-\u0026gt;weight;  delta_exec = curr-\u0026gt;delta_exec;  schedstat_set(curr-\u0026gt;exec_max, max((u64)delta_exec, curr-\u0026gt;exec_max));  curr-\u0026gt;sum_exec_runtime += delta_exec;  cfs_rq-\u0026gt;exec_clock += delta_exec;  if (unlikely(!load)) return;  delta_fair = calc_delta_fair(delta_exec, lw);  delta_mine = calc_delta_mine(delta_exec, curr-\u0026gt;load.weight, lw);  if (cfs_rq-\u0026gt;sleeper_bonus \u0026gt; sysctl_sched_min_granularity) {  delta = min((u64)delta_mine, cfs_rq-\u0026gt;sleeper_bonus);  delta = min(delta, (unsigned long)((long)sysctl_sched_runtime_limit - curr-\u0026gt;wait_runtime));  cfs_rq-\u0026gt;sleeper_bonus -= delta;  delta_mine -= delta;  }  cfs_rq-\u0026gt;fair_clock += delta_fair;  add_wait_runtime(cfs_rq, curr, delta_mine - delta_exec); } __update_curr()的主要工作就是更新前面提到的 fair_clock 和 wait_runtime。这两个值的差值就是后面进程插入红黑树的键值。变量 Delta_exec 保存了前面获得的当前进程所占用的 CPU 时间。函数 calc_delta_fair()根据 cpu 负载（保存在 lw 变量中），对 delta_exec 进行修正，然后将结果保存到 delta_fair 变量中，随后将 fair_clock 增加 delta_fair。函数 calc_delta_mine()根据 nice 值（保存在 curr-\u0026gt;load.weight 中）和 cpu 负载修正 delta_exec，将结果保存在 delta_mine 中。根据源代码中的注释，delta_mine 就表示当前进程应该获得的 CPU 时间。\n随后将 delta_fair 加给 fair_clock 而将 delta_mine-delta_exec 加给 wait_runtime。函数 add_wait_runtime 中两次将 wait_runtime 减去 delta_mine-delta_exec。由于 calc_delt_xx()函数对 delta_exec 仅做了较小的修改，为了讨论方便，我们可以忽略它们对 delta_exec 的修改。最终的结果可以近似看成 fair_clock 增加了一倍的 delta_exec，而 wait_runtime 减小了两倍的 delta_exec。因此键值 fair_clock-wait_runtime 最终增加了一倍的 delta_exec 值。键值增加，使得当前进程再次插入红黑树中就向右移动了。\nCFS 小结 #  以上的讨论看出 CFS 对以前的调度器进行了很大改动。用红黑树代替优先级数组；用完全公平的策略代替动态优先级策略；引入了模块管理器；它修改了原来 Linux2.6.0 调度器模块 70%的代码。结构更简单灵活，算法适应性更高。相比于 RSDL，虽然都基于完全公平的原理，但是它们的实现完全不同。相比之下，CFS 更加清晰简单，有更好的扩展性。\nCFS 还有一个重要特点，即调度粒度小。CFS 之前的调度器中，除了进程调用了某些阻塞函数而主动参与调度之外，每个进程都只有在用完了时间片或者属于自己的时间配额之后才被抢占。而 CFS 则在每次 tick 都进行检查，如果当前进程不再处于红黑树的左边，就被抢占。在高负载的服务器上，通过调整调度粒度能够获得更好的调度性能。\n在最新版本的 CFS 实现中，内核使用虚拟运行时间 vruntime 替代了等待时间，但是基本的调度原理和排序方式没有太多变化。\n参考资料 #  [1] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核[M]. 中国电力出版社, 2001.\n[2] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核(第三版)[M]. 中国电力出版社, 2007.\n[3] 陈莉君, 康华. Linux 操作系统原理与应用[M]. 清华大学出版社, 2006.\n[4] RobertLove, 洛夫, 陈莉君, et al. Linux 内核设计与实现[M]. 机械工业出版社, 2006.\n[5] Linux 调度器发展简述 https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/\n[6] O(n)、O(1)和 CFS 调度器 http://www.wowotech.net/process_management/scheduler-history.html\n[7] 调度系统设计精要 https://draveness.me/system-design-scheduler/\n[8] 进程调度之 6：进程的调度与切换 https://my.oschina.net/u/3857782/blog/1857556\n"},{"id":2,"href":"/docs/algorithm/search/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"二分查找","section":"搜索查找算法","content":"二分查找 #  1、有序数组，查找一个数搜索一个数，如果存在，返回其索引，否则返回 -1。 #  int binarySearch(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0;  int right = nums.size() - 1; // 注意  while(left \u0026lt;= right) {  int mid = left + (right - left) / 2;  if (nums[mid] \u0026lt; target)  left = mid + 1; // 注意  else if (nums[mid] \u0026gt; target)  right = mid - 1; // 注意  else if(nums[mid] == target)  return mid;  }  return -1; } 1、为什么 while 循环的条件中是 \u0026lt;=，而不是 \u0026lt;？ #  答：因为初始化right的赋值是nums.length - 1，每次进行搜索的区间，相当于两端都闭区间[left, right]。while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。\nwhile(left \u0026lt;= right)的终止条件是left == right + 1，写成区间的形式就是[right + 1, right]，这时候区间为空，所以这时候 while 循环终止是正确的，直接返回 -1 即可。\nwhile(left \u0026lt; right)的终止条件是left == right，写成区间的形式就是[right, right]，或者带个具体的数字进去[2, 2]，这时候区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间[2, 2]被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。\n2、为什么left = mid + 1，right = mid - 1？我看有的代码是right = mid或者left = mid，没有这些加加减减，到底怎么回事，怎么判断？ #  答：本算法的搜索区间是两端都闭的，即[left, right]。那么当我们发现索引mid不是要找的target时，下一步应该去搜索哪里呢？当然是去搜索[left, mid-1]或者[mid+1, right]对不对？因为mid已经搜索过，应该从搜索区间中去除。\n3、此算法有什么缺陷？ #  答：比如说给你有序数组nums = [1,2,2,2,3]，target为 2，此算法返回的索引是 2，没错。但是如果我想得到target的左侧边界，即索引 1，或者我想得到target的右侧边界，即索引 3，这样的话此算法是无法处理的。这样的需求很常见，你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。\n2、有序数组，寻找左侧边界 #  int left_bound(int[] nums, int target) { int left = 0, right = nums.size() - 1;  while (left \u0026lt;= right) {  int mid = left + (right - left) / 2;  if (nums[mid] \u0026lt; target) {  left = mid + 1;  } else{  right = mid - 1;  }  }  // 检查出界情况  if (left \u0026gt;= nums.size() || nums[left] != target)  return -1;  return left; } 1、为什么 while 中是\u0026lt;而不是\u0026lt;=? #  答：每次循环的「搜索区间」是[left, right)左闭右开。 while(left \u0026lt; right)终止的条件是left == right，此时搜索区间[left, left)为空，所以可以正确终止。\n2、如果nums中不存在target这个值，怎么办？ #  左侧边界的特殊含义：nums中小于 target 的元素有 left 个。\n3、为什么left = mid + 1，right = mid？和之前的算法不一样？ #  答：这个很好解释，因为我们的「搜索区间」是[left, right)左闭右开，所以当nums[mid]被检测之后，下一步的搜索区间应该去掉mid分割成两个区间，即[left, mid)或[mid + 1, right)。\n4、为什么该算法能够搜索左侧边界？ #  答：关键在于对于nums[mid] == target这种情况的处理。找到 target 时不要立即返回，而是缩小「搜索区间」的上界right，在区间[left, mid)中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\n3、有序数组，寻找右侧边界 #  int right_bound(int[] nums, int target) { int left = 0, right = nums.size() - 1;  while (left \u0026lt;= right) {  int mid = left + (right - left) / 2;  if (nums[mid] \u0026lt;= target) {  left = mid + 1;  } else {  right = mid - 1;  }  }  if (right \u0026lt; 0 || nums[right] != target)  return -1;  return right; } "},{"id":3,"href":"/docs/algorithm/tree/","title":"二叉树","section":"算法","content":"二叉树 #  1、解题思路 #    遍历：通过遍历一遍树可以完成任务，则用 traverse 函数配合外部变量实现。 =》回溯\n  递归分解：通过子问题/子树的答案得到问题的解，则用 traverse 函数递归，利用返回值。=》 动态规划 =》后序\n  2、关注点 #  单独抽出一个节点，它需要做什么？在前/中/后序什么时候做？\n3、融会贯通 #  3.1、遍历函数 traverse() 的理解 #  迭代/递归遍历数组、链表、树没什么区别！\n数组 #  /* 迭代遍历数组 */ void traverse(int[] arr) {  for (int i = 0; i \u0026lt; arr.length; i++) {   } }  /* 递归遍历数组 */ void traverse(int[] arr, int i) {  if (i == arr.length) {  return;  }  // 前序位置  traverse(arr, i + 1);  // 后序位置 }   链表 #  /* 迭代遍历单链表 */ void traverse(ListNode head) {  for (ListNode p = head; p != null; p = p.next) {   } }  /* 递归遍历单链表 */ void traverse(ListNode head) {  if (head == null) {  return;  }  // 前序位置  traverse(head.next);  // 后序位置 }    3.2、快速排序 -\u0026gt; 前序遍历 #  构造分界点 -\u0026gt; 递归左右  Expand ↕  vector\u0026lt;int\u0026gt; sortArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  quickSort(nums, 0, nums.size()-1);  return nums;  }   void quickSort (vector\u0026lt;int\u0026gt; \u0026amp;nums, int low, int high) {  if (low \u0026lt; high) {  int index = partition(nums,low,high);  quickSort(nums,low,index-1);  quickSort(nums,index+1,high);  }  }   int partition (vector\u0026lt;int\u0026gt; \u0026amp;nums, int low, int high) {  int mid = low + ((high-low) \u0026gt;\u0026gt; 1);  if (nums[low] \u0026gt; nums[high]) swap(nums,low,high);  if (nums[mid] \u0026gt; nums[high]) swap(nums,mid,high);  if (nums[mid] \u0026gt; nums[low]) swap(nums,mid,low);   int pivot = nums[low];  int start = low;   while (low \u0026lt; high) {  while (low \u0026lt; high \u0026amp;\u0026amp; nums[high] \u0026gt;= pivot) high--;  while (low \u0026lt; high \u0026amp;\u0026amp; nums[low] \u0026lt;= pivot) low++;  if (low \u0026gt;= high) break;  swap(nums, low, high);  }  //基准值归位  swap(nums,start,low);  return low;  }     3.3、归并排序 -\u0026gt; 后序遍历 #  先排左右 -\u0026gt; 合并  Expand ↕  // 定义：排序 nums[lo..hi] void sort(int[] nums, int lo, int hi) {  int mid = (lo + hi) / 2;  // 排序 nums[lo..mid]  sort(nums, lo, mid);  // 排序 nums[mid+1..hi]  sort(nums, mid + 1, hi);   /****** 后序位置 ******/  // 合并 nums[lo..mid] 和 nums[mid+1..hi]  merge(nums, lo, mid, hi);  /*********************/ }     4、题目 #    一棵二叉树共有几个节点？\n 普通二叉树  后序遍历 - O(N)   满二叉树  计算树的高度 -\u0026gt; 2^h - 1 ( O(logN)   完全二叉树  记录左、右子树的高度：同，则满；否则普通树 O(logNlogN)：一棵完全二叉树的两棵子树，至少有一棵是满二叉树。因此两个递归只有一个会真的递归下去，满的一定会触发hl == hr，只消耗 O(logN) 的复杂度而不会继续递归。综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logNlogN)。      翻转二叉树\n 前序序或后序遍历    将二叉树展开为链表\n 后序遍历 将原先的右子树接到当前右子树的末端    填充二叉树每个节点的下一个右侧节点指针\n 定义：填充以root为根的树的\u0026hellip;？不符合，不能跨子树 -\u0026gt; 传入左右节点，分别递归 该做：将传入的两个节点连接 前序    构造最大二叉树\n 定义：将给定的子数组构造最大二叉树 该做：找到最大值，作为root, 并赋值左右节点 前序 涉及数组：辅助函数，控制索引    前序和中序遍历结果构造二叉树\n 定义：给定的子数组构造二叉树 该做：找到root节点，确定左右子树的子数组，赋值左右节点。 前序 涉及数组：辅助函数，控制索引，画图    寻找重复子树\n 定义：给定的子树判断重复子树 该做：  以我为root的子树长啥样 其他子树长啥样 描述与对比：二叉树序列化   后序！    二叉树序列化与反序列化\n 序列化：前序遍历（或后序遍历） 反序列化：因为包含了空指针的信息，前序遍历，先左后右即可。（或先右后左） 层次遍历框架：从队列中取根节点，然后把子节点存进队列    剑8：二叉树的下一个节点（给定带父指针二叉树和一个节点，找中序遍历序列的下一个节点）\n 节点有右子树，最左子节点就是 没有右子树  左叶子节点，那父节点就是下一个 右叶子节点，找到一个是它父节点的左孩子的节点      剑26：给两棵二叉树，判断是不是子结构\n 定义：给定的子树有没有包含 该做：判断结构是否相同  定义：判断给定的子树是否相同 该做：值相等？ 前序   前序    剑28：判断一颗二叉树是不是对称的\n 分析：前序遍历和对称前序遍历序列是否一样。1树变2树 定义：给定的两棵树是不是一样的 该做：值相等 前序    剑32：从上到下打印二叉树\n 队列/栈 设置对应的变量    剑34：给一棵二叉树和一个整数，打印和为整数的所有路径\n 定义：给定的子树是否有和为某个整数的路径 该做：加上自己的值。为了打印，遍历时节点入栈，返回父节点之前，在路径上删除当前节点 前序    剑55：求二叉树的深度：知道左和右子树的深度，取最大者就可以\n  二叉搜索树中第k小/大的元素\n 中序遍历即为升序排列的结果    把二叉搜索树转换为累加树\n 利用特性    判断BST的合法性\n 如果当前节点会对下面的子节点有整体影响，使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点    在BST中搜索一个数\n 针对BST的遍历框架    在BST中插入一个数\n 找到空位置，插入新节点    在BST中删除一个数\n 先找，找到后删除 叶子节点 - return null 一个子节点 - 返回该子节点 两个子节点 - 左子树最大 或 右子树最小    给一个正整数n, 计算共有多少种不同结构的BST结构\n 分析：先确定根节点：n种情况，确认后，左子树组合数 * 右子树组合数 定义：计算闭区间 [lo, hi] 组成的BST个数 后序 消除重叠子问题：备忘录    给一个正整数n, 构建所有的BST\n 分析：先穷举根节点的所有可能 - 递归构造子BST - 穷举左右子树的组合 定义：构造闭区间 [lo, hi] 组成的BST，返回根节点 后序 消除重叠子问题：备忘录    给一棵二叉树，找到节点之和最大的那颗BST\n 分析：左右子树是不是BST？加上自己是不是BST? 记录节点之和 定义：给定子树，返回int[] {是不是BST，最小值，最大值，和} 该做：得到左子树、右子树的结果，判断并计算 后序遍历 如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历。    剑33：给一个整数数组，判断是不是某二叉搜索树的后序遍历结果\n 定义：给定子数组，是不是 该做：确定左子树、右子树的子数组    "},{"id":4,"href":"/docs/cs/linux-kernel/%E4%BB%8E%E5%BC%80%E6%9C%BA%E5%88%B0main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C/","title":"从开机 main 函数执行","section":"Linux 内核设计的艺术","content":"Linux 从开机到加电执行 main 函数之前的过程 #   mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) flowchart LR bootsect[执行 bootsect]-- setup[执行 setup]-- head[执行 head.s]-- main[main 函数] 1.1 启动 BIOS，准备中断向量表和中断服务程序 #   加电时，内存 RAM 是空的 BIOS 负责把操作系统内核程序加载到内存中  具体过程：\n 靠硬件完成，将 CPU 的硬件逻辑设计为加电瞬间 CS:IP 指向 0xFFFF0, 即 BIOS 程序入口地址。 BIOS 在内存中建立中断向量表和中断服务程序。利用中断，才能加载内核程序。  1.2 加载内核程序 #   产生 int 0x19 中断，找到并加载启动扇区，从而 bootsecct 程序被拷贝到内存。 BIOS 负责找到并加载第一扇区，与具体的Linux内核无关，即两头约定 + 定位识别。   bootsecct 程序复制自身到另一个地方，并调整CS:IP、DS(数据段寄存器)、ES(附加段寄存器)、SS(栈基址寄存器)+SP(栈顶指针). 意味着从现在起，操作系统已经不需要完全依赖BIOS,可以按照自己的意志进行内存规划和程序执行。   执行 int 0x13 中断，加载 setup 程序。  需要传参给中断服务程序，包括指定的扇区和加载的内存信息等； 通过几个通用寄存器来实现传参，非函数调用    加载system系统内核程序 开始执行 setup 程序，读取机器系统数据，放在原bootsect程序所在的部分内存区域。  1.3 转变为32位模式，为调用 main 函数做准备 #   将 system 系统内核程序复制到 0x00000 的位置  这个位置本来放的是 BIOS 建立的中断向量表和BIOS数据区，相当于废掉了BIOS提供的实模式下的中断服务程序； 同时收回寿命结束的内存空间； 让内核代码占据内存物理地址最开始、最天然、最有利的位置。 这一过程是在关中断的状态下进行。   初始化两个表：  GDT(全局描述符表) + GDTR IDT(中断描述符表) + IDTR   打开A20，实现32位寻址 对 中断控制芯片8259A 重新编程  "},{"id":5,"href":"/docs/law/system/%E4%BD%95%E4%B8%BA%E5%80%BA/","title":"何为债","section":"系统","content":"何为债 #  债，以及其他的法律概念，从事实到概念形成，规定明确要件和法律效果，核心是法律的构建。因而，学习制度的思考路径，至少应当事实与法律并重。\n观察债的典型事实，其并非有共同构成要件，而是有同样的法律效果，即一方得以向另一方要求给付。此为债的基础原则。\n而债，实乃最基础的公式，其具有基础的要件，但加入具体的事实因素，则构成复杂的具体法律关系。而习得公式只是第一步，不同于数学公式的引用变形，每一个法律规则的使用，都是对于具体个体事实的讨论，都有十分重要的意义。\n因而，析得债实乃第一步，还应明确为何种债，并且需要进入到实际的具体概念和规则的讨论。\n“一方得以向对另一方要求给付”性质 #  该性质为债的基本原则，强调双方。如有突破的，需要有法律的明确规定。\n相对性 #  “债权为对于特定人之权利，债权人只能向债务人请求给付，而不能向债务人以外之人请求给付”。\n非支配性，没有绝对性和排他性。数个债权不论其发生先后，均以同等地位并存。（1）平等性：甲将房屋先后出卖给乙、丙、丁时买卖契约均属有效，三人均可请求甲交付该屋。（2）相对性：设甲将屋所有权移转于丁，乙、丙的债权随发生在前，仍不能向丁主张任何权利，仅得依债务不履行规定向甲请求损害赔偿。（3）非排他：债务人破产时，债权不论其发生先后，均依比例参加分配。\n第三人侵害债权 #  该理论寓有一项法律政策上的价值判断，即适当维护第三人的活动自由。\n例如，A驾车不慎，撞伤将在B歌厅作个人秀的歌星C。（1）A侵害了C的人身权，对其负是损害赔偿责任；（2）a.A的行为导致C无法演出，构成B的损失。b.C对于B的演出义务，产生于B与C之间的合同约定，该约定不可以用来规制A，B不可主张A侵害了自己能够使C来演出的权利。c.B可以依A故意以悖于善良风俗之方法，加损害于自己，来主张损害赔偿。\n即，债权的规制范围仅限于债权双方，第三人即使造成债权实际损害的结果，由于其并不受债权的约束，因此不可以主张第三人侵害债权。\n特殊：债权物权化 #  债权的物权化，即产生对抗一般人的法律效果，来源于法律的具体规定。\n 租赁权的物权化：租赁在先，即使出租人将租赁物所有权转移给第三人，无论第三人是否知道或知道应当知道该租赁合同的存在，承租人的租赁权依旧可以对抗第三人存在（“买卖不破租赁”）。 预告登记：预告登记的内容为债权，债权成立而登记后，任何处分该标的物的行为违背该预告登记的债权的，物权的变动无效。 基于约定产生的涉他关系  债的实现 #  实现的范围（债权角度） 。 债的内容即请求为给付，其目的是得到给付，如果交货付款同时完成，那么债权的存在没有那么大的意义。问题是，随着交易生活的不断变迁，债并非能够即时充分兑现。因此，债与债的实现一分为二。债的存在是为了保障债的实现，而债能够实现是债存在的基础。\n以当事人自治为原则，法律不直接参与债与债的实现。 债的内容是课债务人以给付义务，并赋予债权人以请求给付的权利。法律并不主动参与到这个过程中去，因为债是相对人之间的事，债权人可以主动选择是否实现请求以得到给付的权利。法律对债权人决定行使债权的给予权威、力量和制度，使其利益得到实现。\n此外，必要时法律予以强制性并于特殊情形下允许债权人自力实现其债权。\n一般权能 #   请求力：债的基本要义就是债权人能够诉请债务人履行义务。 执行力：诉请债务人履行后，债务人不履行的，法院得依债务的内容对债务人强制履行。具体有金钱请求权、物之交付请求权、行为及不行为请求权、假扣押假处分执行等。 私力实现：于特殊情况下，可以正当防卫紧急避险自助行为。除此之外，由于未涉及“实力”，五海域法律秩序及社会平和，允许抵抵销。 处分：由于法律赋予债权强的可实现力，因而债权富有价值，债权人可以对其进行处分，包括转让、免除、质押。 保持力：债务人给付后，债权人得以保有该给付，不致构成不当得利。债权具有保持给付之法律上的原因，该给付包括自动与法律强制下的给付。  特殊情形 #   请求力不完全：婚约，婚姻强调意志自由，履行以后不可强制；罹于消灭时效的债权请求力减损，不可诉请执行。 强制力排除：夫妻间的同居义务；与人身相关的义务：eg绘像，可以损害赔偿但不可直接强制； 处分排除：破产人因破产之宣告，对于其财产，丧失管理及处分权；约定债权不可让与的。  自然债务 #  婚姻居间报酬：成功才具有保有力；赌债：仅具有保有力。\n债务与责任 #  负担的范围（债务的角度）\n一般负担 #  责任即强制实现此项义务的手段，亦即履行此项义务的担保。即债务人的一般负担是为给付以自己的全部（或是特定）财产担保债务的实现。\n债务与责任问题是从债务人的角度来看债的实现，即债权人有权请求债务人使债实现，债务人如何积极配合债的实现，如何进行给付，给付不成怎么办。\n从这个角度上看，债务就是为给付“原始义务”，责任就是给付不能而生的“第二性义务”。责任是辅助于债务的存在，如同债权的其他权能辅助于请求权存在。债务本身就是负担，这个负担不仅仅包括为给付，还包括责任的负担。\n 无限责任：以自己的全部财产供债权人得依法强制执行 有限责任：以特定财产为限度，对于其他财产不得再为强制执行。  债权保全与担保制度 #  此即为特殊的负担，担保的财产涉及第三人或特定物。\n= 债的保全：责任财产的减少有两种情况，一种是债务人怠于行使自己的债权，一种是债务人积极赠与等不当使自己的财产减少的行为。 - 代位权：债务人怠于行使自己的到期债务，导致债权人不能实现债权，债权人可以直接找第三人要求其履行债务。 - 撤销权：债务人为有害债权的行为，倒是债权无法实现，债权人可以诉请法院撤销其不当行为，以恢复债务人之财产。\n 保证与担保  保证：保证人得以债权人约定，于主债务人不履行债务时，得由其代负履行责任。 担保：即以特定物担保债务的履行，包括抵押权、质押、动产抵押权、保留所有权及信托占有。   顺序总结：一般债权、优先受偿的债权（法律的规定）、有担保的债权、税收债权  债权的交易 #  包括债权让与与权利质权。\n债的义务群 #  债的微观内容，实际应为。\n 现行“民法”系以主给付义务为规律对象，基于诚信原则，由近而远，见渐次发生从积分义务，以及其他附随义务，辅助实现给付利益及维护他方当事人的人身及财产上利益，因此组成的义务体系。 在处理债之问题时，必须考虑：相对人负有何种义务，得否请求履行，得否主张同时履行抗辩，违反义务时的法律效果，得否请求损害赔偿或解除契约等。 债之关系上义务群的发展，赖乎判例学说，名称犹未统一，界限亦难完全确定，尤其从给付义务与附随义务，二者的区别从与主给付义务的远近来判断，存在模糊，二者的区别在于得否主张履行抗辩与得否解除契约，存在极大分野。  给付义务 #   主给付义务  决定债的性质的基本义务，固有、必备。 就双务合同而言，主给付义务构成对待给付义务，于他方当事人未为对待给付前，得拒绝自己之给付。 因可归责于债务人之事由，致给付不能、给付迟延或不完全给付时，债权人得请求赔偿损害或解除契约。   从给付义务  基于法律明文规定；基于当事人约定；基于诚实信用原则及补充的契约解释。 从给付义务与主给付义务关系密切，是使主给付义务得以满足而生的义务，固其得以请求履行，单独提起诉讼。 是否能够发生同时抗辩，应视具体的从给付义务是否为契约目的之达成是否必要而定。 其能够请求损害赔偿，但是否能够解除契约，依具体的从给付义务与契约目的之达成是否必要而定。    原给付义务与次给付义务 #  次给付义务是在原给付义务履行过程中，因特定事由演变而生的义务。次给付义务系根基于原来债之关系，其内容虽有所改变或扩张，但同一性仍维持不变。\n 因原给付义务给付不能、给付迟延或不完全给付而生成的赔偿损害义务，该义务既有替代给付义务的，亦有与原给付义务并存的。 契约解除时所生恢复原状之义务。  附随义务 #   促进实现主给付义务，使债权人的给付利益获得最大可能的满足，eg妥善包装花瓶；维护他方当事人人身或财产上的利益（保护功能），侵权行为法的社会安全义务来源。 性质：非给付义务，不发生同时履行抗辩，不得解除契约。德国法以是否能够提起单独诉讼作为区分附随义务与从给付义务的标准。 附随义务的违反与不完全履行给付：  不完全给付的法律后果是债权人得依关于给付迟延或者给付不能之规定行使其权利，因不完全给付而生前项义务之损害者，债权人并得请求赔偿。 法律没有设定附随义务得一般规定，附随义务的违反与不完全给付介于侵权责任与契约责任之间。  依照不完全给付的规定，不完全给付如为加害给付，除发生原来债务不履行之损害歪，更发生超过履行利益之损害，出卖人交付病鸡致买受人之鸡群亦感染而死亡。固可依侵权行为之规定请求损害赔偿，但被害人应就加害人之过失行为负举证责任，保护尚嫌不周，因此明定除了依侵权外，也可依不完全给付之理论请求损害赔偿。 依侵权行为法，因故意或过失侵害不法侵害他人权利者，负损害赔偿责任，其保护客体不及于纯财产上损害。同样思路，将附随义务的违法设定为符合不完全给付的规定，补充“侵权行为法”。     先合同义务  当事人为缔结契约而接触、准备或磋商时，发生的说明、告知、保密、保护扽跟其他义务。 具体规定（待补）   后合同义务  契约关系消灭后，当事人尚负有某种作为或不作为义务，以维护给付效果，或协助相对人处理契约终了的善后义务。 债务人违反后契约义务时，于违反一般契约义务同，依债务不履行负其责任。    不真正义务 #   相对人通常不得请求履行，而其违反并不发生损害赔偿责任，仅使负担此项义务者遭受权利减损或丧失的不利益而已。 不真正义务依诚实信用原则而生，为了最大程度上防止经济上的不效益。  标的物毁损灭失或其他情形不能返还：因可归责于解除权人自己的事由，解除权消灭。 损害扩大：被害人在法律上虽未富有不损害自己权益的义务，但既因自己之疏懈造成损害之发生或扩大，与有责任，依公平原则，自应依其程度忍受减免赔偿金额的不利益。    债法的体系 #   债法的适用逻辑：于处理相关问题时，应先检查债各是否设有规定，无特别规定时才可适用债总的一般规定。eg以不能之给付为契约标的，其契约始为无效；债权或其他权利之出卖人，应担保其权利确系存在。对于债权等权利的出卖契约规定了特别规定，这是因为立法者认为权利欠缺外部可见的形体，买受人必须信赖出卖人，故应受较为周全的保护。   甲于3月3日出售房屋给乙，约定3月10日交付。 乙于3月4日出售其对甲之债权与丙。 其后发现该屋于3月1日灭失。  甲乙买卖房屋的契约：为不能给付之契约标的，契约始为无效。房屋已经灭失，故甲乙的买卖合同无效。 乙丙之间的买卖契约：权利出卖人负有担保权利存在的义务，故乙丙的买卖合同有效。     民法的适用逻辑：以请求权基础为出发点，综合整部民法相关规定而为适用。并同样是特别优于一般。 实例探究：   甲欲丢弃旧笔A，误取新笔B丢弃。 乙先占之。 甲于次日发现其事，即向乙请求返还B笔。 乙表示已将该笔与丙的C书互易，并已同时履行。  甲基于错误的认识处分其B笔，该处分行为无效，不产生物权变动效力。 不是无主物，乙无法实现先占事实取得物权。 丙为善意第三人，并且满足善意取得要件。     故：甲得以向乙为返还原物请求权，侵权的损害赔偿请求权。甲得向丙请求返还原物请求权。  "},{"id":6,"href":"/docs/cs/open-source/%E6%9D%82%E8%B0%88/","title":"杂谈","section":"开源","content":"杂谈 #  开源相关。\n  开源大家谈  开源大家谈 # 近十年To B的国内外公司采用开源Core+SaaS，开源好处：最高效的开发模式；获客，得到更多的用户，测试和反馈，最重要的客户需求，用户的用法，会超出想象；基础设施必须开源。 开源文档很重要，发展开源社区，把Credit给别人。 得到高手帮助，提高自己能力，不要想得太难。代码开源，有生命力，更长的生命周期；把东西做好，回报自然来，平常心享受过程，很好的经历，未来还有商业机会。   "},{"id":7,"href":"/docs/law/practice/%E8%B7%A8%E5%A2%83%E5%B9%B6%E8%B4%AD%E4%BA%A4%E6%98%93%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E5%AE%9E%E6%93%8D%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/","title":"跨境并购交易方案设计实操案例解析","section":"实务","content":"跨境并购交易方案设计实操案例解析 #   客户是一家设立于香港的生物制药香港上市公司“并购方”，拟收购一家位于大陆的基因制药企业“目标公司”。 目标公司于2010年设立，注册资本为人民币1亿元，已全部缴齐 财务状况方面，目标公司连年亏损，净资产为负，尚欠银行逾期贷款人民币5000万元。 股权结构方面：目标公司现有3名股东，其中股东甲是一名境内自然人，持股51%，股权乙是当地政府出自平台，持股25%，股东丙是一家境内投资基金，持股24%。 并购方拟以人民币2.2亿并购目标公司。  维度思考 #  股权并购、资产并购\n主体：境内子公司\n标的：有形、无形资产；人员；债权债务关系\n程序：清算、评估、转让（完全私人交易主要是双方的磋商）\n要点：资质、限制（主要是银行方面）、税费、时间\n绕掉壳的不合规性，做到一样的效果。\n特殊行业：制药企业，无法适用资产并购\n股权并购 #  类型：转让；增资（常用方式）；VIE架构（协议控制）\nVIE的主要考量外商投资指导目录：第三类禁止类：涉及到基因等不可以适用股权投，只能协议控制。\n五个协议：独家购买权法律允许的情况下可以1块钱直接行使购买权、独家业务合作协议：转移利润；股权质押协议：全转让有风险；股东表决权委托协议：控制股 东会；配偶承诺函：婚姻纠纷；阿里土豆等。\n转让与增资：取得控制地位，1.02亿或500万；\n资金流向：转让时使用资金成本较低；资金额的作用。\n增资没有任何一方形成所得：无税收\n最优方案的重点注意：\n wfoe中留在境内、spv、体外孵化 恰当时间进行收购  特殊股东利益处置：\n 特殊主体特殊权利，梳理、谈判、保留or解除 国有资产处置：国有股的稀释，需要注意相应的程序：国有资产处置程序；公开义务：公开进场；备案 人员安排：实际控制人的竞业禁止、核心科研人员的六人、董事会及高管人员调整：eg派遣财务总监  "},{"id":8,"href":"/docs/cs/basic/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","title":"进程与线程","section":"计算机基础知识","content":"进程和线程 #  进程 #  No.1、线程和进程的区别 #  可以从1、概念，2、所拥有的资源，3、开销 三个方面考虑。\n 从概念上来说，进程是资源分配的基本单位，线程是 CPU 调度的基本单位； 从资源的角度来讲，  一个进程可以有多个线程，线程间可以共享该进程的资源。比如说，进程有自己的独立地址空间，而这一个进程内的线程是共享这一份相同的地址空间的。这就意味着线程切换快，因为不需要切换页表。但同时，要是有一个线程挂掉了，整个进程也会挂掉。相比较之下，进程之间就不会有这种影响，也就是会比较健壮。 当然，除了共享的资源以外，线程也会有私有的一些资源，比如寄存器和栈。   从开销的角度来讲：  我们使用线程的时候，一方面是想要提高它的并发性，可以用多个线程去执行一个进程的不同部分，这样能充分发挥多CPU的功能。 另一方面是可以减少开销，比如  线程的创建时间比进程快，因为进程在创建的过程中，还需要分配内存、文件管理信息，而线程直接共享就可以了； 线程的终止会比进程快，同样的道理，它需要释放的资源会比较少； 线程切换快，因为同一个进程里面的线程都具有同一个页表，在切换的时候就不需要切换页表。 通信问题。线程因为会共享一些全局变量、静态变量等数据，因此线程间通信会方便一些，但也会带来同步和互斥的问题。进程间要通信就需要借助IPC。   共享的有：堆、全局变量、静态变量、指针，引用、文件 线程私有的有栈、寄存器等。    1. 概念:进程是操作系统资源分配的基本单位。 #  进程就是运行起来的可执行程序。我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个运行中的程序，就被称为「进程」。\n2. 进程的状态：运行态、就绪态、阻塞态 #   运行状态：该进程正在 CPU上跑； 就绪状态：已经就绪，可运行，但还没有占有CPU，比如时间片用完了； 阻塞状态：该进程暂停运行，等待某一事件发生（比如等待键盘输入），即使给它CPU控制权，它也无法运行；如果完成了，就变成就绪态。 还有：创建状态、结束状态、挂起状态（表示进程没有占有内存空间，在硬盘上）  3. 进程的控制结构PCB #  是一个结构体，用来描述进程。也是进程存在的唯一标识。多个进程的PCCB通过链表的方式连接在一起。 包括：\n 进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程当前状态、进程优先级 CPU 相关信息：CPU 中各个寄存器的值 资源：内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。  4. 进程的控制 #  01 创建进程 #  父进程创建子进程，子进程继承父进程所拥有的资源。\n 为子进程分配一个唯一的进程标识号，并申请一个空白的 PCB 为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源； 初始化 PCB，等待被调度运行；  02 终止进程 #  正常结束、异常结束以及外界干预（信号 kill 掉）\n终止进程的过程如下：\n 查找 PCB； 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程； 如果还有子进程，终止所有子进程； 将全部资源归还给父进程或操作系统； 将其从 PCB 所在队列中删除；  03 阻塞进程 #  阻塞等待。\n阻塞进程的过程如下：\n 找到PCB； 如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行； 将该 PCB 插入的阻塞队列中去；  04 唤醒进程 #  一旦被阻塞等待，它只能由另一个进程唤醒。 唤醒进程的过程如下：\n 找到 PCB； 将其从阻塞队列中移出，状态变为就绪状态； 把该 PCB 插入到就绪队列中，等待调度程序调度；  5. 进程的上下文切换 #  CPU 寄存器和程序计数器（即将执行的下一条指令位置）。\n什么时候会发生进程调度/上下文切换？\n 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行； 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行； 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度； 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行； 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序  进程调度算法 #   批处理系统（保证吞吐量和周转时间）  先来先服务：利长不利短。 短作业优先：长会饿死 最短剩余时间优先：新作业加入时，比较    交互式系统（快速响应）  时间片轮转：排成队列，分配时间片，时钟中断 优先级调度：为每个进程分配一个优先级 多级反馈队列（结合）：每个队列时间片大小都不同    进程同步 #   临界区：对临界资源进行访问的那段代码 互斥：多个进程同一时刻，只一个进程进入临界区 信号量：PV操作，互斥量，生产者-消费者  进程间通信 #    无名管道：只能有亲缘，半双工\n  有名：没有亲缘关系的限制，半双工\n  信号：比如 ctrl+C，通知进程说某个事件已经发生\n  信号量：是一个计数器，用来控制多个进程对共享数据对象的访问\n  消息队列：消息的链表。\n 独立于发送进程和接收进程，即使进程终止，里面的内容不会删除 里面的消息可以用特定的格式和特定的优先级，所以可以支持随机读取，比如按消息类型读取，不用先进先出 克服了信号承载信息量少，管道只能无格式字节流和缓冲区大小受限的缺点    共享内存：最快的方式\n  套接字：适用不同机器\n  其他 #  3、一个进程可以创建多少线程，和什么有关？ #  理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。\n因此，一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。如果需要创建超过2K以上的线程，减小你线程栈的大小就可以实现了，虽然在一般情况下，你不需要那么多的线程。过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。\n"},{"id":9,"href":"/docs/algorithm/search/bfs/","title":"BFS广度优先搜索","section":"搜索查找算法","content":"BFS广度优先搜索 #  一、二叉树的层序遍历 #  102.二叉树的层序遍历 #  题目地址：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n107.二叉树的层次遍历 II #  题目链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n 相对于102.二叉树的层序遍历，就是最后把result数组反转一下就可以了。  199.二叉树的右视图 #  题目链接：https://leetcode-cn.com/problems/binary-tree-right-side-view/\n给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n 层序遍历的时候，判断是否遍历到单层的最后面的元素  637.二叉树的层平均值 #  题目链接：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n 层序遍历的时候把一层求个总和在取一个均值。  429.N叉树的层序遍历 #  题目链接：https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/\n给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。\n 多个孩子  for (int i = 0; i \u0026lt; node-\u0026gt;children.size(); i++) { // 将节点孩子加入队列  if (node-\u0026gt;children[i]) que.push(node-\u0026gt;children[i]); } 515.在每个树行中找最大值 #  题目链接：https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/\n您需要在二叉树的每一行中找到最大的值。\n 层序遍历，取每一层的最大值  116.填充每个节点的下一个右侧节点指针 #  题目链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/\n给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。\n 单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点  117.填充每个节点的下一个右侧节点指针II #  题目地址：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/\n普通二叉树。一样\n104.二叉树的最大深度 #  题目地址：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数\n111.二叉树的最小深度 #  相对于 104.二叉树的最大深度 ，本题还也可以使用层序遍历的方式来解决，思路是一样的。\n 只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点  "},{"id":10,"href":"/docs/cs/linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/","title":"Linux 进程调度","section":"计算机","content":"Linux 进程调度 #  前言 #  在计算机科学中，调度就是一种将任务（Work）分配给资源的方法。任务可能是虚拟的计算任务，例如线程、进程或者数据流，这些任务会被调度到硬件资源上执行，例如：处理器 CPU 等设备。调度器或调度算法的设计与实现最终都会归结到一个问题上，即如何对有限的资源进行分配以实现资源利用率的最大化并满足特定的需求。\n调度器是操作系统中的重要组件，操作系统中有进程调度器（Process Scheduler）、网络调度器（Network Scheduler）和 I/O 调度器（I/O Scheduler）等组件，本文介绍的是进程调度器。\n进程调度器负责给系统中的所有进程分配有限的 CPU 时间资源。只有通过合理的调度算法，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。\n进程调度算法总是追求达到以下目标：\n 公平：保证每个进程得到合理的 CPU 时间，避免进程的饥饿现象。 高效：尽量充分使用 CPU，使 CPU 保持忙碌状态。 快速的响应时间：使交互用户的响应时间应尽可能短。 周转时间：使批处理用户等待输出的时间尽可能短。 吞吐量：单位时间内处理的进程数量尽可能多。  但是很显然，这几个目标是相互冲突的，不可能同时达到。因此只能在这几个方面进行取舍，从而确定自己的调度算法。\n进程调度器将进程分为三类：\n  交互式进程(Interactive process)：这些进程经常与用户进行交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如命令行 shell、文本编辑程序。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。\n  批处理进程(Batch process)：这些进程一般在后台运行，不必与用户交互，需要占用大量的系统资源。但是能够忍受响应延迟。典型的批处理程序如编译程序、数据库搜索引擎等。\n  实时进程(Real-time process)：这些进程对调度延迟的要求最高，往往执行非常重要的操作，要求立即响应并执行。典型的实时程序比如视频播放软件、或飞机飞行控制系统，很明显这类程序不能容忍长时间的调度延迟。\n  根据进程的不同分类 Linux 采用不同的调度策略。\n对于实时进程，采用 FIFO 或者 Round Robin 的调度策略。\n对于普通进程，则需要区分交互式和批处理式的不同。传统 Linux 调度器提高交互式应用的优先级，使得它们能更快地被调度。而 CFS 和 RSDL 等新的调度器的核心思想是“完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。\n以下列出了 Linux 不同版本调度器的历史：\n 初始调度器 · v0.01 ~ v2.4  由几十行代码实现，功能非常简陋； 同时最多处理 64 个任务；   O(n) 调度器 · v2.4 ~ v2.6  调度时需要遍历全部任务； 当待执行的任务较多时，同一个任务两次执行的间隔很长，会有比较严重的饥饿问题；   O(1) 调度器 · v2.6.0 ~ v2.6.22  通过引入运行队列和优先级数组实现 O(1) 的时间复杂度; 使用本地运行队列替代全局运行队列增强在对称多处理器的扩展性； 通过负载均衡保证多个运行队列中任务的平衡；   完全公平调度器 · v2.6.23 ~ 至今  引入红黑树和运行时间保证调度的公平性； 引入调度类实现不同任务类型的不同调度策略；    本文会详细介绍从最初的调度器到今天复杂的完全公平调度器（Completely Fair Scheduler，CFS）的演变过程。\nLinux 初始的调度算法 #  Linux 最初的进程调度器仅由 sched.h 和 sched.c 两个文件构成。你可能很难想象 Linux 早期版本使用只有几十行的 schedule 函数负责了操作系统进程的调度：\nvoid schedule(void) {  int i,next,c;  struct task_struct ** p;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) {  ...  }  while (1) {  c = -1;  next = 0;  i = NR_TASKS;  p = \u0026amp;task[NR_TASKS];  while (--i) {  if (!*--p) continue;  if ((*p)-\u0026gt;state == TASK_RUNNING \u0026amp;\u0026amp; (*p)-\u0026gt;counter \u0026gt; c)  c = (*p)-\u0026gt;counter, next = i;  }  if (c) break;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p)  if (*p)  (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority;  }  switch_to(next); } 无论是进程还是线程，在 Linux 中都被看做是 task_struct 结构体，所有的调度进程都存储在上限仅为 64 的数组中，调度器能够处理的进程上限也只有 64 个。\n上述函数会先唤醒获得信号的可中断进程，然后从队列倒序查找计数器 counter 最大的可执行进程，counter 是进程能够占用的时间切片数量，该函数会根据时间切片的值执行不同的逻辑：\n 如果最大的 counter 时间切片大于 0，调用汇编语言的实现的 switch_to 切换进程； 如果最大的 counter 时间切片等于 0，意味着所有进程的可执行时间都为 0，那么所有进程都会获得新的时间切片；  Linux 操作系统的计时器会每隔 10ms 触发一次 do_timer 将当前正在运行进程的 counter 减一，当前进程的计数器归零时就会重新触发调度。\nO(n) 调度算法 #  数据结构：进程描述符 #  每个进程都有一个 task_struct 结构。该结构定义在 \u0026lt;include/linux/sched.h\u0026gt; 文件中，其中部分与进程调度相关的字段说明如下：\n  need_resched：调度标志，决定是否调用 schedule() 函数。\n  counter：进程处于可运行状态时所剩于的时钟节拍数。每次时钟中断到来时，update_process_times()对该值减 1。\n 创建新进程时，do_fork()以下列方式设置 current(父)和 p(子)进程的 counter 字段：current-\u0026gt;counter \u0026gt;\u0026gt;=1; p-\u0026gt;counter = current-\u0026gt;counter. 也就是说，父进程剩余的节拍数被分为两部分，一部分给父进程，一部分给子进程。这样做时为了防止通过 fork 子进程的方法无限制地使用 CPU 的时间。    rt_priority：实时进程的实时优先级。取值范围 1-99。\n  nice: 进程的静态优先级，它的值决定了 counter 的初值。nice 的取值范围是-20(优先级高)~19(优先级低)，缺省为 0。该值可通过 nice 系统调用改变。\n  policy： 本进程的调度策：\n SCHED_RR 和 SCHED_FIFO 用于实时进程。SCHED_RR 和 SCHED_FIFO 的调度策略在 rt_priority 不同的时候，都是谁的优先级高谁先执行，唯一的不同是相同优先级的处理： SCHED_RR 是时间片轮转的实时进程。当多个进程具有同一优先级时，采用时间片轮转轮流调度运行。适用于实时性要求较高但每次运行耗时较长的进程。 SCHED_FIFO 是先入先出的实时进程，先占有 CPU 的进程会持续执行，直到退出或者阻塞的时候才会让出 CPU。也只有这时候，其他同优先级的实时进程才有机会执行。适应于实时性要求比较强、而每次运行的耗时又比较短的进程。 SCHED_OTHER 用于普通的分时进程。  除了上面描述的三种调度策略，policy 成员也可以设定 SCHED_YIELD 的标记，它和调度策略无关，主要处理 sched_yield 系统调用的。\n  state: 表示进程当前运行状态：\n  TASK_RUNNING ：该状态表示这个进程可被调度执行而成为当前进程，是进程表达了希望被调度运行的意愿，内核会将该进程的 task_struct 结构加入可运行队列。\n  TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE ：这两个状态都表示进程处于睡眠状态。前者表示浅度睡眠，可被信号唤醒；后者表示深度睡眠。sleep_on 和 wake_up 用于深度睡眠；而 interruptible_sleep_on 和 interruptible_wake_up 则用于浅度睡眠。\n  TASK_ZOMBIE 表示已退出而暂时没有被父进程收回资源的\u0026quot;僵尸\u0026quot;进程。\n  TASK_STOPPED 主要用于调试目的。进程接收到一个 SIGSTOP 信号后就将运行状态改成 TASK_STOPPED 而进入挂起状态，然后在接收到一个 SIGCONT 信号时又恢复继续运行。\n    调度的时机 #  Linux 的调度程序是一个叫 schedule()的函数，由它来执行具体的调度算法。调用 schedule()的时机主要包括：\n直接调用 #    进程入睡时主动调用 schedule()：当现运行进程请求资源被阻塞时，会调用 sleep_on()或 interruptible_sleep_on()进入睡眠状态，这时会执行以下步骤：\n  把当前进程 current 插入到合适的等待队列中。\n  把当前进程 current 的状态修改为 TASK_INTERUPTIBLE 或 TASK_UNINTERUPTIBLE。\n  调用 schedule() 函数。\n  检查那个资源是否可用。如果不，转到第 2 步。\n  一旦那个资源成为可用的，把 current 从等待队列中删除。\n    进程终止时主动调用 schedule()：当现运行进程终止时，会调用 exit() 终止运行，这时会主动调用 schedule() 函数。\n  设备驱动程序执行长而重复的任务时，主动调用 schedule()：驱动程序在每次循环中，都会去检查调度标志 need_resched 的值，如果必要，就调用 schedule()主动放弃 CPU。\n  创建新进程：在 do_fork()中也会调用 schedule() 函数。\n  延迟调用 #  延迟调用是指当系统需要调度时，通过置现运行进程 need_resched 标志为 1。然后在从中断、异常、系统调用等从内核返回用户态时，对该标志进行检测，如果该标志为 1，则调用 schedule()。主要包括以下情况：\n  在中断处理过程中，发现 current 用完了时间片，置 need_resched 标志为 1。\n  一个进程被唤醒，且它的优先级比现运行进程更高，置 need_resched 标志为 1。\n  当父进程 fork 子进程时，其时间片会均分到父子进程。\n 如果只剩下一个 tick，这个 tick 会分配给子进程，而父进程的时间片则被清零，这时候等同于情况 1。 否则，父子进程的时间片都不为 0，这时等同于情况 2。    一个进程通过系统调用改变调度政策(sched_setscheduler)或表示礼让(sched_yield)时，会设置 need_resched 标志为 1。\n  如何计算优先级：godness() #  调度算法的核心是在可运行队列链表中的所有进程中确定优先级最高的进程。goodness() 就是用来计算进程优先级。它接受两个输入参数：prev(前一个运行进程)和 p(要评估的进程)，返回一个整数值 c，表示进程 p 的“值得运行的程度(goodness)”。\ngoodness()函数将实时进程和普通进程区分计算。流程如下：\n 如果该进程的 policy 被置 SCHED_YIELD 标志为，直接返回 -1。表示进程愿意“礼让”。 如果该进程是 SCHED_FIFO 或 SCHED_RR，直接返回：1000+ p-\u0026gt;rt_priority。可以看出，实时进程的优先级很高，且与 counter 和 nice 无关，至少为 1000，保证了实时进程会完全优先于普通进程的调度。 如果该进程是 SCHED_OTHER： 如果 p-\u0026gt;counter 为 0，直接返回 0。即该进程已用完时间片。 否则，返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice。 此外，在 2 的情况下，如果候选进程 p 是内核进程（无用户空间），或者 p 的用户空间与当前进程 prev 的用户空间相同，则返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice + 1。因为如果 p 正好在 prev 之后运行，它们将使用同一页表。  调度流程：schedule() #  可以将 schedule()函数大致分为以下三个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作  具体过程如下：\n初始化部分 #   current 的值保存在 prev 局部变量中, 将 prev-\u0026gt;need_resched 字段设为 0 判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。 prev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));  检查 prev 的状态，  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒:  prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。    确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。 检查候选进程 next：  如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。   检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。  进程切换之后的操作 #  执行__schedule_tail()，置 prev-\u0026gt;police 的 SCHED_YIELD 为 0。 函数返回。  如何重新分配时间片 #  在上一小节提到，当 c 为 0 时，说明可运行队列中没有实时进程，只有普通进程，且队列中所有普通进程的时间片都已用完，这时需要重新系统中所有进程的时间片（而不仅仅是可运行队列中的进程），计算方法为：\nfor_each_task(p)  p-\u0026gt;counter = (p-\u0026gt;counter \u0026gt;\u0026gt; 1) + NICE_TO_TICKS(p-\u0026gt;nice); 宏 NICE_TO_TICKS 的定义如下。以 HZ 为 200 为例，每秒中断 200 次，那么一个时钟滴答 tick 为 5ms，20 - nice 的取值为[1 ,40]，缺省为 20，将 20 右移 1 位即除以 2 为 10，10 个滴答即 50ms。当时钟频率 HZ 越高，每个滴答所代表的时间越短，NICE_TO_TICKS 分配的滴答数越多，但最大只是 20 – nice 的值左移 2 位即乘以 4，最大值为 160，仍小于实时进程的 1000。\n#if HZ \u0026lt; 200 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 2) #elif HZ \u0026lt; 400 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 1) #elif HZ \u0026lt; 800 #define TICK_SCALE(x) (x) #elif HZ \u0026lt; 1600 #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 1) #else #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 2) #endif #define NICE_TO_TICKS(nice) (TICK_SCALE(20-(nice))+1) 可以发现，经过重新计算后，那些不在可运行队列中的普通进程，会获得较高的时间配额，在将来的调度中会占一定的优势。但即使无数次更新方之后，counter 的值也不会超过两倍的 NICE_TO_TICKS，也不会超过实时进程的优先级。\nSMP 系统下的调度程序 #  Linux 为了支持对称多处理器(SMP)体系结构，必须对 Linux 的调度程序稍作修改。实际上，每个处理器运行它自己的 schedule()函数，但是，处理器间必须交换信息以提高系统性能。\n数据结构 #  schedule_data 结构体 #  如下所示，schedule_data 结构体用来很快的获得当前进程的描述符，每个 CPU 上都有一个该结构体。该结构体包含：\n 该 CPU 上现运行进程的描述符 task_struct。 现运行进程上台的时刻，即 schedule()是什么时候选 curr 作为运行进程。  struct schedule_data{  struct task_struct *curr;  unsigned long last_schedule; } struct schedule_data aligned_data[NR_CPUS]; task_struct 进程描述符 #  除了在上文提到的一些与进程调度相关的字段外，task_struct 还包含了几个与 SMP 相关的字段，包括：\n processor：表示该进程上一次运行在哪个 CPU 上。 avg_slice：表示该进程的平均时间片，即每次运行时间的期望值。  cacheflush_time 变量 #  cacheflush_time 变量表示对硬件高速缓存内容全部重写所需要花费的时间。这个值只是一个估值，大约不到 100 微秒。计算公式为：以 kHZ 为单位的 CPU 频率*以 KB 大小为单位的缓存容量/5000 在后面将看到，当现运行进程的 avg_slice – (time – last_schedule) \u0026lt; cacheflush_time，就不会执行进行的抢占。\nSMP 系统下调度流程：schedule() #  具体过程如下：\n  current 的值保存在 prev 局部变量中。prev-\u0026gt;processor 的值存放在 this_cpu 局部变量中。aligned_data[this_cpu]的值存放在 sched_data 局部变量中。将 prev-\u0026gt;need_resched 字段设为 0。\nprev = current; this_cpu = prev-\u0026gt;processor; sched_data = aligned_data[this_cpu];   判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。\nprev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));   检查 prev 的状态:\n   如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒: prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。  确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。在 goodness 函数中，检查进程的 processor 字段，并对最后在 this_cpu CPU 上执行的进程给与一定奖赏(PROC_CHANGE_PENALTY，通常为 15). 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。除此之外，做一些跟 CPU 相关的操作：   把 sched_data-\u0026gt;curr 置为 next。 next-\u0026gt;has_cpu 置为 1，next-\u0026gt;processor 置为 this_cpu。 在 t 局部变量中存放 current 时间标记寄存器的值，并执行： this_slice = t – sched_data-\u0026gt;last_schedule; sched_data-\u0026gt;last_schedule = t; prev-\u0026gt;avg_slice = (prev-\u0026gt;avg_slice + this_slice) / 2   检查候选进程 next：   如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。  检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。 进程切换之后的操作 当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 schedule()时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。如果 prev(即为 prev_new)还依然是可运行的，并且不是这个 CPU 的空任务，那么，对 prev 调用 reschedule_idle()函数。 把 prev 的 has_cpu 字段清 0。 函数返回。  SMP 系统下的 reschedule_idle() #  当进程 p 变为可运行时，执行 reschedule_idle()函数决定进程是否应该抢占某一 CPU 上的当前进程。具体过程如下：\n 如果 p 是实时进程，总会试图抢占，转到 3。 如果有一个 CPU 上的当前进程满足下列两个条件，则立即返回(不试图抢占)：  cacheflush_time 大于当前进程的平均时间片。防止高速缓存变得太“脏”。 为了存取某一临界内核数据结构，p 和当前进程都需要全局内核锁。   接下来执行 CPU 选择算法：  如果 p-\u0026gt;processor (即 p 最后运行的 CPU)是空闲的，选它。 遍历所有 CPU，对其上正在运行的任务 tsk，计算以下差值：goodness(tsk, p) - goodness(tsk, tsk), 如果这个差值为正，就选择差值最大的 CPU。   如果选择了某个 CPU，给选中的 CPU 的正在运行进程的 need_resched 字段置 1，并向这个 CPU 发处理器间中断：RESCHEDULE_VECTOR interprocessor interrupt。  O(1) 调度算法 #  O(n) 调度算法缺陷 #  Linux2.4 之前的版本，用较为简单的调度算法实现了进程调度。但是该算法存在以下问题：\n  算法复杂度问题。遍历运行队列的算法复杂度为 O(n)，意味着队列越长，选中一个进程所需要的时间就越长。此外，每次调度周期结束后，为每一个进程计算其时间片的过程太耗费时间。\n  多处理器问题。多个处理器上的进程放在一个就绪队列中，使得这个就绪队列成为临界资源，为了实现内核同步机制，需要对其上自旋锁，降低了系统效率。\n  CPU 空转问题。在 runqueue 队列中的全部进程时间片被耗尽之前，系统总会处于这样一个状态：最后的一组尚存时间片的进程分分别调度到各个 CPU 上去。我们以 4 个 CPU 为例，T0 ～ T3 分别运行在 CPU0~CPU3 上。随着系统的运行，CPU2 上的 T2 首先耗尽了其时间片，但是这时候，其实 CPU2 上也是无法进行调度的，因为遍历 runqueue 链表，找不到适合的进程调度运行，因此它只能是处于 idle 状态。也许随后 T0 和 T3 也耗尽其时间片，从而导致 CPU0 和 CPU3 也进入了 idle 状态。现在只剩下最后一个进程 T1 仍然在 CPU1 上运行，而其他系统中的处理器处于 idle 状态，白白的浪费资源。唯一能改变这个状态的是 T1 耗尽其时间片，从而启动一个重新计算时间片的过程，这时候，正常的调度就可以恢复了。随着系统中 CPU 数目的加大，资源浪费会越来越严重。\n  SMP 亲和力问题。在一个新的周期开后，runqueue 中的进程时间片都是满满的，在各个 CPU 上调度进程的时候，它可选择的比较多，再加上调度器倾向于调度上次运行在本 CPU 的进程，因此调度器有很大的机会把上次运行的进程调度到同一个处理器上。但是随着 runqueue 中的进程一个个的耗尽其时间片，cpu 可选择的余地在不断的压缩，从而导致进程执行在一个和它亲和性不大的处理器（例如上次该进程运行在 CPU0，但是这个将其调度到 CPU1 执行，但是实际上该进程和 CPU0 的亲和性更大些）。\n  实时进程调度性能问题。实时进程和普通进程挂在一个链表中，当调度实时进程的时候，我们需要遍历整个 runqueue 列表，扫描并计算所有进程的优先级，再从中选择出最终要调度的实时进程，在这过程中，一些时间片已经耗完的进程在不可能参与调度的情况下，依然会参与调度选择的过程。此外，整个 linux 内核不是抢占式内核，对于一些比较耗时的系统调用或者中断处理，必须返回用户空间才启动调度，大大降低了实时进程的调度性能。\n  交互式普通进程的调度延迟问题。O（n）并不区分交互式进程和批处理进程，它只是奖励经常睡眠的那些进程。但是有些批处理进程也属于 IO-bound 进程，例如数据库服务进程，它本身是一个后台进程，对调度延迟不敏感，但是由于它需要和磁盘打交道，因此也会经常阻塞在 disk IO 上。对这样的后台进程进行动态优先级的升高其实是没有意义的，会增大其他交互式进程的调度延迟。\n  虽然 O（n）调度器存在不少的问题，但是社区的人还是基本认可这套算法的，因 此在设计新的调度器的时候并不是完全推翻 O（n）调度器的设计，而是针对 O（n）调度器的问题进行改进。\n从以上分析中可以看出，单运行队列是影响调度性能的主要问题之一，因此改进运行队列就成为改进调度算法的入口点。\n基于此，O(1)调度器为每个 CPU 设置一个运行队列，并且为每个运行队列再设置两个队列：活动队列和时间片过期队列。每个队列中的元素以优先级再进行分类，相同优先级的进程为一个队列，最多可以有 140 个优先级。为了快速选中要运行的进程，设置以优先级为序的队列位图，位图的每一位对应一个队列，只要队列中有一个可运行进程，该位置 1，否则置 0。这样，无需遍历所有队列，而只要遍历位图，找到有可运行进程的队列，该队列的第一个进程就是被选中的进程。该算法的复杂度为 O(1). 如图所示：\n通过将单链表变成多个链表，可以解决上述大部分问题：\n 算法复杂度问题：O(1)调度器算法通过优先级位图，以及活动队列与过期队列指针交换，实现了 O(1)的复杂度，而不是遍历运行队列，并重新计算所有进程的时间片。 多处理器问题：由于每个 CPU 都有一个运行队列，因此 O(1)调度器就不需要全局运行队列的自旋锁，而只需要把这个自旋锁放入到每个 CPU 的运行队列数据结构中，通过把一个大锁细分成小锁，可以大大降低调度延迟，提升系统响应时间。。 CPU 空转问题：O(1)调度器每个 CPU 都有一个运行队列，当一个进程的时间片耗尽，在被移动到过期数组之前，会重新计算其时间片，而不是等到一个调度周期结束再重新计算进程时间片，因此解决了 CPU 空转问题。 SMP 亲和力问题：O(1)调度器设置了较为合理的负载均衡算法，只有在需要平衡任务队列大小时才在 CPU 之间移动进程。 实时进程与交互式调度性能问题：为了提高交互时进程和实时进程的响应时间，当前进程的时间片为 0 时，判断当前进程的类型，如果时交互式进程或实时进程，则重置其时间片并重新插入活动队列，否则插入过期队列，这样交互式进程和实时进程总能优先获得 CPU。然而当这些进程已经占用 CPU 时间超过一个固定值后，也会被移到过期队列中，避免其他进程产生饥饿现象。  数据结构 #  runqueue 数据结构 #  runqueue 可执行队列是调度程序中最基本的数据结构。定义于 kernel/sched.c 中。如上所述，每个 CPU 包含一个可执行队列；每个就绪进程都唯一地归属于某一个可执行队列。此外，可执行队列中还包含着每个 CPU 的调度信息。其包含的字段如下图所示：\n优先级数组 #  如上所述，每个运行队列有活动队列和过期队列两个优先级数组，每个数组是一个 prio_array 类型的结构体。优先级数组使得该调度算法复杂度为 O(1)。\n 计数器 nr_active 是一个计数器，保存可运行进程数目。 bitmap 是优先级位图数组。其中 BITMAP_SIZE 是位图数组的大小，类型为 unsigned long 长整型，长 32 位，每一位包含一个优先级，140 个优先级需要 5 个长整型数表示。bitmap 一开始所有的位都被置 0。当某个进程状态变为 TASK_RUNNING 时，对应的位被置 1。这样，查找系统中最高的优先级就变成了查找位图中被设置的第一个位。 queue 是优先级链表数组，一个链表对应一种优先级。每个链表包含了该 CPU 上相应优先级的全部可运行进程。其中 MAX_PRIO 定义了系统拥有的优先级个数，默认为 140。  进程描述符 #  与 linux 2.4 的进程描述符有些差异，其与调度相关的字段如下：\n进程的优先级 #  普通进程 #  静态优先级 #  普通进程的静态优先级保存在 static_prio 成员中，取值范围是 100（优先级最高）～ 139（优先级最低），分别对应 nice 值的-20 ～ 19。静态优先级本质上决定了进程的基本时间片，对应公式如下：\n由该公式得到一些普通进程优先级的典型值如下：\n动态优先级 #  在实际调度的时候使用的是动态优先级。普通进程的动态优先级保存在进程描述符的 prio 成员中。取值范围是 100（优先级最高）～ 139（优先级最低），和静态优先级一致。动态优先级根据以下公式得出：\n其中，bonus 取值范围 0~10，值小于 5 表示惩罚，大于 5 表示奖赏。bonus 的取值与进程的平均睡眠时间相关，如下表。需要说明的是，平均睡眠时间是进程在睡眠状态所消耗的平均纳秒数，但不是对过去时间的求平均值操作。例如，在 TASK_INTERRUPTIBLE 状态与在 TASK_UNINTERRUPTIBLE 状态所计算出的平均睡眠时间是不同的。而且，平均睡眠时间永远不会大于 1s.\n平均睡眠时间也被调度程序用来确定一个给定进程是交互式进程还是批处理进程。如果满足下列公式，则被看作是交互式进程：\n其中，静态优先级/4-28 被称为交互时的 δ。可以推出，高优先级的进程比低优先级的进程更容易成为交互式进程。例如，最高静态优先级(100)的进程，当他的 bonus 值超过 2，即睡眠时间超过 200ms 时，就被看作是交互式进程。\n实时进程 #  实时进程的实时优先级，存在进程描述符的 rt_priority 成员中，取值范围是 1（优先级最低）～ 99（优先级最高）。需要注意的是，当系统调用 nice()和 setpriority()用于基于时间片轮转的实时进程时，不改变实时进程的优先级，而会改变其基本时间片的长度。也就是说，基于时间片轮转的实时进程的基本时间片的长度与实时进程的优先级无关，而依赖于进程的静态优先级，它们的关系同普通进程下的公式一样。\n普通进程采用复杂的公式计算动态优先级，而实时进程不计算动态优先级，保证了给定优先级别的实时进程总能抢占优先级比它低的进程。\n调度程序所使用的函数 #  调度程序使用几个函数来完成调度工作，其中最重要的函数说明如下：\nscheduler_tick() #  每次时钟节拍到来时，scheduler_tick()被调用，执行以下步骤：\n 把转换为纳秒的 TSC 的当前值存到本地运行队列的 timestamp_last_tick 字段。这个时间戳是从 sched_clock()函数得到。 检查当前进程是不是本地 CPU 的 swapper 进程，如果是，则检查本地运行队列除了 swagger 进程外，是不是还有另外的可运行进程，如果是，就设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。之所以会出现这种情况，是因为如果内核支持超线程技术，那么只要一个逻辑 CPU 运行队列中的所有进程都比另一个逻辑 CPU 上已经在执行的进程优先级低得多，而两个逻辑 CPU 是对应同一个物理 CPU 的，因此，前一个逻辑 CPU 就可能空闲，即使它的运行队列中也有可运行的进程。执行完上述检查后，直接跳到第 7 步，因为不需要更新 swagger 进程的时间片。 检查 current-\u0026gt;array 是否指向本地运行队列的活动链表，如果不是，说明进程已经过期但还没有被替换，则设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。然后直接跳到第 7 步。 获得 this_rq()-\u0026gt;lock 自旋锁 根据进程不同类型执行不同操作：    如果当前进程是 FIFO 的实时进程，则什么也不做，跳到 6。\n  当前进程是基于时间片轮转的实时进程：递减当前进程时间片，如果时间片已经用完，则：\n 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice= 0。该字段是在 fork()系统调用服务例程中的 copy_process()中设置，并在进程的第一个时间片用完时清 0。 调用 set_tsk_need_resched()设置进程的 TIF_NEED_RESCHED 字段。 iv. 把当前进程移到当前的运行队列尾部。    当前进程是普通进程：递减当前进程时间片，如果时间片已经用完：\n 将当前进程从活动队列(this_rq()-\u0026gt;active)中移除。 调用 set_tsk_need_resched() 设置进程的 TIF_NEED_RESCHED 字段。 更新当前进程的动态优先级。current-\u0026gt;prio = effective_prio(current). 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice 清 0。 如果 this_rq()-\u0026gt;expired_timestamp 字段为 0（表示过期队列为空），把当前进程的时钟节拍 jiffies 赋值给 this_rq()-\u0026gt;expired_timestamp。 把当前进程插入活动队列或过期队列：  if (!TASK_INTERACTIVE(current) || EXPIRED_STARVING(this_rq()))  enqueue_task(current, this_rq()-\u0026gt;expired); else  enqueue_task(current, this_rq()-\u0026gt;active); 其中, TASK_INTERACTIVE 宏用于识别一个进程是不是交互式进程。EXPIRED_STARVING 宏负责检查过期队列中的进程是否处于饥饿状态：如果已经有相对较长时间没有发生数组切换了，那么再把当前的进程放置到活动数组，则会加重过期队列中进程的饥饿状态。\n否则，如果时间片没有用完，检查当前进程的剩余时间片是否太长：\nif (TASK_INTERACTIVE(p) \u0026amp;\u0026amp; !((task_timeslice(p) – p-\u0026gt;time_slice) %TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;time_slice \u0026gt;= TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;array == rq-\u0026gt;active)) {  list_del(\u0026amp;current-\u0026gt;run_list);  list_add_tail(\u0026amp;current -\u0026gt; run_list, this_rq()-\u0026gt;active-\u0026gt;queue+current-\u0026gt;prio);  set_tsk_need_resched(p); } 其中，宏 TIMESLICE_GRANULARITY 产生两个数的乘积给当前进程的 bonus，其中一个数为系统中 CPU 的数量，另一个为成比例的常量。基本上，具有高静态优先级的交互式进程，其时间片被分成大小为 TIMESLICE_GRANULARITY 的几个片段，以使这些进程不会独占 CPU。\n  释放 this_rq()-\u0026gt;lock 自旋锁。 调用 rebalance_tick()函数，保证不同 CPU 的运行队列包含数量基本相同的可运行进程。  从第 5 步中可以看出，对于 O(1)调度器，时间片的重新赋值是分散处理的，在各个进程耗尽其时间片之后立刻进行的。修正了 O(n)调度器一次性的遍历系统所有进程，重新为时间片赋值的过程。\n唤醒：try_to_wake_up() #  该函数通过把进程状态设置为 TASK_RUNNING，并调用 activate_task()函数将此进程放入对应的可运行队列中来唤醒睡眠或停止的进程。\n该函数接受的参数有：\n 被唤醒进程的描述符指针 p. 可以被唤醒的进程状态掩码(state)。 一个标志(syn)，用来禁止被唤醒的进程抢占本地 CPU 上正在运行的进程。  该函数执行以下操作：\n 禁本地中断，并获得最后执行该进程的 CPU 的运行队列的锁。 检查进程状态 p-\u0026gt;state == state。如果不是，直接跳到 9 终止函数。 如果 p-\u0026gt;arrray != NULL ,说明该进程已经属于某个运行队列，跳到 8. 确定目标 CPU：  如果有空闲的 CPU，就选空闲的 CPU。 如果先前执行进程的 CPU 的工作量远小于本地 CPU 的工作量，选前者。 如果进程最近被执行过，就选这个老的运行队列。 如果把进程迁移到本地 CPU 可以缓解 CPU 之间的不平衡，则选本地 CPU。   如果进程处于 TASK_UNINTERRUPTIBLE 状态，则递减目标运行队列的 nr_uninterruptible 字段，并把 p-\u0026gt;activated 字段置为-1。 调用 activate_task()函数，执行：  调用 sched_clock()获取以纳秒为单位的当前时间戳。如果目标 CPU 不是本地 CPU，就要补偿本地时钟中断的偏差：now=(shced_clock()–this_rq()-\u0026gt;timesamp_last_tick)+rq-\u0026gt;timestamp_last_tick 调用 recalc_task_prio()。 设置 p-\u0026gt;activated 字段的值。 使用 now 设置 p-\u0026gt;timestamp 字段。 把进程描述符插入活动队列，且 rq-\u0026gt;nr_running++。   如果目标 CPU 不是本地 CPU，或者没有设置 sync 标志，则，如果该进程优先级更高 p-\u0026gt;prio \u0026gt; rq-\u0026gt;curr-\u0026gt;prio，就调用 resched_task()抢占 rq-\u0026gt;curr。  单处理器系统，设置 rq-\u0026gt;curr 进程的 TIF_NEED_RESCHED 标志。 多处理器系统，如果 TIF_NEED_RESCHED 旧值为 0，且目标 CPU 没有轮询进程 TIF_NEED_RESCHED 标志的值，则发送处理器间中断 IPI，强制目标 CPU 重新调度。   把当前进程 p-\u0026gt;state 字段设为 TASK_RUNNING。 开 rq 运行队列的锁，打开本地中断。 如果成功唤醒返回 1，否则返回 0.  计算动态优先级：recalc_task_prio() #  recalc_task_prio() 函数更新进程的平均睡眠时间和动态优先级。\n该函数接受的参数有：\n 进程描述符指针 p。 当前时间戳 now。  该函数执行以下操作：\n 把 min(now – p-\u0026gt;timestamp, 109)的结果赋值给局部变量 sleep_time，表示进程消耗在睡眠状态的纳秒数。如果超过 1 秒，就设为 1 秒. 如果 sleep_time 不大于 0，直接跳到 8. 检查进程是不是内核线程、进程是否从 TASK_UNINTERRUPTIBLE 状态（即 p-\u0026gt;activated 为-1）被唤醒、进程连续睡眠的时间是否超过给定的睡眠时间期限。如果这三个条件都满足，把 p-\u0026gt;sleep_avg 字段设置位相当于 900 个时钟节拍的值（用最大平均睡眠时间减去一个标准进程的基本时间片长度获得的一个经验值）。然后跳到 8. 计算进程原来的平均睡眠时间的 bonus 值。如果 10-bonus\u0026gt;0,则把 sleep_time 乘以 10-bonus。所以原来的 p-\u0026gt;sleep_avg 越小，bonus 值越小，10-bonus 越大，sleep_time 越大，最终的 p-\u0026gt;sleep_avg 增加的就越快。 如果进程处于 TASK_UNINTERRUPTIBLE 状态而且不是内核线程：  检查平均睡眠时间 p-\u0026gt;sleep_avg 是否大于等于进程的睡眠时间极限。如果是，把 sleep_time 置为 0，直接跳到 6. 如果 sleep_time + p-\u0026gt;sleep_avg 大于等于睡眠时间极限，把 p-\u0026gt;sleep_avg 设为睡眠时间极限并把 sleep_time 置为 0 通过对进程平均睡眠时间的轻微限制，函数不会对睡眠时间很长的批处理进程给与过多的奖赏。   把 sleep_time 加到进程的平均睡眠时间 p-\u0026gt;sleep_avg 上。 检查 p-\u0026gt;sleep_avg 是否超过 1000 个时钟节拍，如果是，就置为 1000 个时钟节拍。 更新进程的动态优先级。p-\u0026gt;prio = effective_prio(p).  可以看到，在评估用户交互指数上，O(n)调度器仅仅考虑了睡眠进程的剩余时间片，而 O(1)调度器的“平均睡眠时间”算法考虑了更多的因素：在 cpu 上的执行时间、在 runqueue 中的等待时间、睡眠时间、睡眠时候的进程状态（是否可被信号打断），什么上下文唤醒（中断上下文唤醒还是在进程上下文中唤醒），因此 O(1)调度器更好的判断了进程是否属于交互式进程。\n调度流程： #  schedule() 与 O(n) 调度器类似，可以将 schedule() 函数大致分为以下四个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作 具体过程如下： 初始化部分 禁用内核抢占。current 的值保存在 prev 局部变量中，本地 CPU 的运行队列保存在 rq 局部变量中。 preempt_disable(); prev = current; rq = this_rq();  保证 prev 不占用大内核锁。通过进程切换会自动释放和重新获取大内核锁。 if (prev-\u0026gt;lock_dept \u0026gt;= 0)  up(\u0026amp;kernel_sem);  计算 prev 所用的 CPU 时间片长度： now = sched_clock(); run_time = now – prev-\u0026gt;timesamp; if (run_time \u0026gt; 1000000000)  run_time = 1000000000 run_time /= (CURRENT_BONUS(PREV) ? : 1) run_time 用来限制进程对 CPU 的使用，最多 1 秒。不过，当进程有较长睡眠时间时，CURRENT_BONUS()返回值越大，run_time 就会被降低。这是对较长平均睡眠时间的奖赏。 关本地中断，获得运行队列的自旋锁：spin_lock_irq(\u0026amp;rq-\u0026gt;lock) 检查 prev 是不是一个正在被终止的进程： if (prev-\u0026gt;flags \u0026amp; PF_DEAD)  prev-\u0026gt;state = EXIT_DEAD;  检查 prev 的状态，如果不是 TASK_RUNNING 可运行状态，而且没有在内核态被抢占：  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就让其变为可运行状态：prev-\u0026gt;state = TASK_RUNNING 以唤醒这个进程。 否则，调用 deactivate_task()函数从运行队列中删除 prev 进程,。同时，如果该进程状态是 TASK_UNINTERUPTIBLE，则 rq-\u0026gt;nr_uniterruptible++.  rq-\u0026gt;nr_running--; dequeue_task(p, p-\u0026gt;array); p-\u0026gt;array = NULL;  检查运行队列中剩于的可运行进程数。如果有可运行进程，但是当前内核支持超线程技术，且可运行进程比在相同物理 CPU 的某个逻辑 CPU 上运行的兄弟进程优先级低，p-\u0026gt;sleep_avg直接去执行 swapper 进程。 如果没有可运行进程，函数调用 idle_balance()，从其他 CPU 迁移一些可运行进程到本地队列中。如果本地队列还是没有可运行进程，就重新调度空闲 CPU 的可运行进程。如果还是没有，则直接去执行 swapper 进程。 到这里运行队列中一定有可运行进程。检查运行队列中是否至少有一个进程是活动的(rq-\u0026gt;active-\u0026gt;nr_active\u0026gt;0)。如果没有，交换活动队列和过期队列的指针。  确定优先级最高的进程 next #   在优先级数组中查找第一个非 0 的位图对应的链表的第一个进程描述符，并赋值给 next。\n  检查 next-\u0026gt;activate 字段，该字段编码值表示进程在被唤醒时的状态，如下表：\n如果 next 是一个普通进程，并且 activate 为 1 或 2，就把自从进程插入运行队列开始所经过的纳秒数加到进程的平均睡眠时间。但是 1 和 2 的情况还是有区别，在 2 的情况下，增加全部运行队列等待时间，在 1 的情况下，只增加等待时间的部分。这是因为交互式进程更可能被异步事件(如键盘)而不是同步事件唤醒。\nif (next-\u0026gt;prio \u0026gt;= 100 \u0026amp;\u0026amp; next-\u0026gt; activate \u0026gt; 0){  unsigned long long delta = now – next-\u0026gt;timestamp;  if ( next-\u0026gt; activate == 1)  delta = (delta * 38) / 128;  array = next-\u0026gt;array;  dequeue_task(next, array);  recalc_task_prio(next, next-\u0026gt;timestamp + delt- ;  enqueue_task(next, array); } next-\u0026gt; activate = 0;   完成进程切换 #  如果最终的候选进程就是当前进程，释放自旋锁，不做进程切换，直接结束。 否则执行进程切换： next-\u0026gt;timestamp = now; rq-\u0026gt;nr_switches ++; rq-\u0026gt;current = next; prev = context_switch(rq, prev, next) 其中 context_switch()函数建立 next 的地址空间。  如果 next 是内核进程，则借用 prev 的 active_mm。 if ( ! next_mm ){ next-\u0026gt;active_mm = prev-\u0026gt;active_mm; atomic_inc(\u0026amp;prev-\u0026gt;active_mm-\u0026gt;mm_count); enter_lazy_tlb( prev-\u0026gt;active_mm, next) }  如果 next 是普通进程，则执行 switch_mm 切换用户空间，把虚拟内存从上一个进程映射切换到新进程中。 if ( next_mm ){ switch_mm( prev-\u0026gt;active_mm, next-\u0026gt;mm, next); }    如果 prev 是内核进程或正在退出的进程： if ( ! prev_mm ){  rq-\u0026gt;prev_mm = prev-\u0026gt;active_mm;  prev-\u0026gt;active_mm = NULL; }  调用 switch_to()进行真正的进程切换，从上一个进程的处理器状态切换到新进程的处理器状态，包括保存、恢复栈信息和寄存器信息。 switch_to( prev, next, prev);   进程切换之后的操作 #   当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 p-\u0026gt;sleep_avg时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。进程切换后的第一部分指令是：\nbarrier(); finish_task_switch( prev); 其中 finish_task_switch(prev) 函数如下：\nmm = this_rq()-\u0026gt;prev_mm; this_rq()-\u0026gt;prev_mm = NULL; prev_task_flags = prev-\u0026gt;flags; spin_unlock_irq(\u0026amp; this_rq()-\u0026gt;lock); if (mm)  mmdrop(mm) if (prev_task_flags \u0026amp; PF_DEAD)  put_task_struct( prev); 其中 mmdrop()减少内存描述符的使用计数器。如果减到了 0，释放与页表相关的所有描述符和虚拟存储区。put_task_struct()释放进程描述符使用计数器，并撤销所有其余对该进程的引用。\n  p-\u0026gt;sleep_avg函数最后一部分代码如下。包括在需要的时候重新获得大内核锁，重新启用内核抢占，并检查是否一些其他的进程已经设置了当前进程的 TIF_NEED_RESCHED。如果是，则整个 p-\u0026gt;sleep_avg函数重新执行，否则函数结束。\nprev = current; if (prev-\u0026gt;lock_depth \u0026gt;= 0)  __reacquire_kernel_lock(); preempt_enable_no_resched(); if (test_bit(TIF_NEED_RESCHED, \u0026amp;current_thread_info() -\u0026gt; flags))  goto need_resched; return;   多处理器系统中运行队列的平衡 #  从 Linux2.6.7 版本开始，Linux 提出一种基于“调度域”概念的复杂的运行队列平衡算法，从而能够容易适应各种已有的多处理器体系结构。并提供了以下函数：\n  rebalance_tick()函数会在每一次时钟节拍到来时由 scheduler_tick()调用，负责周期性、在需要的时候调用 load_balance()函数。\n  load_balance()函数检查调度域是否处于严重的不平衡状态，如果是，将会尝试调用 move_task()函数把一些进程从一个运行队列迁移到另一个运行队列。\n  move_task()函数负责把进程从源运行队列迁移到本地运行队列。\n  其中比较重要的 load_balance()函数可简单描述为如下操作：\n1、 调用 find_busiest_queue()，找到最繁忙的可运行队列，即该队列中的进程数目最多。如果没有哪个可运行队列中进程的数目比当前队列中的数目多 25%或更多，就返回 NULL，并且 load_balance()函数也返回。否则返回最繁忙的可运行队列。\n2、 从最繁忙的运行队列中选择一个优先级数组以便抽取进程，最好是过期数组，因为那里面的进程已经相当较长一段时间没有运行了，很可能不在 CPU 的高速缓存中。如果过期数组为空，那就只能选活动数组。\n3、 找到含有进程并且优先级最高的链表。\n4、 分析找到的所有这些优先级相同的进程，选择一个不是正在执行，也不会因为 CPU 相关性而不可移动，并且不在高速缓存中的进程。如果有进程满足以上条件，调用 move_task()将其从最繁忙的队列迁移到当前队列。\n5、 只要可运行队列之间仍然不平衡，就重复上面两个步骤，最终达到平衡。此时，解除对当前运行队列的锁定，从 load_balance()返回。\n抢占 #  用户抢占 #  用户抢占是指在内核即将返回用户空间的时候，如果 need_resched 标志被设置，会导致 p-\u0026gt;sleep_avg被调用，此时就发生了用户抢占。与延迟调用小节描述的一样，用户抢占在从系统调用或中断处理程序返回用户空间时发生。\n内核抢占 #  在不支持内核抢占的内核中，内核代码可以一直执行，直到完成返回用户空间或者明显的阻塞为止。也就是说，调度程序没办法在一个内核任务正在执行的时候发起调度。在 2.6 版本的内核中，引入了内核抢占能力，只要重新调度是安全的，即，只要没有持有锁，那么正在执行的代码就是可重新导入的，内核就可以在任何时间抢占正在执行的任务。\n为了支持内核抢占，为每个进程的 thread_info 引入了 preempt_count 计数器。该计数器初始值为 0，每当使用锁的时候加 1，释放锁的时候减 1.当该值为 0 时，表示内核可以抢占。\n因此，从中断返回内核空间的时候，内核会检查 need_resched 和 preempt_count 的值。如果 need_resched 被设置，且 preempt_count 为 0，说明有一个更为重要的任务需要执行并且可以安全的抢占，此时，调度程序就会被调用。此外，如果当前进程持有的所有锁都被释放了，此时会去检查 need_resched 是否被设置，如果是就调用调度程序。\n如果内核中的进程被阻塞了，或它显示地调用 p-\u0026gt;sleep_avg，内核抢占就显式地发生，这种形式的内核抢占一直都是支持的，因为无需额外的逻辑来保证内核可以安全的被抢占。\n楼梯调度算法与 RSDL 调度算法 #  O(1)调度器区分交互式进程和批处理进程的算法与以前虽大有改进，但仍然在很多情况下会失效。有一些著名的程序(如 fiftyp.c, thud.c, chew.c, ring-test.c)总能让该调度器性能下降，导致交互式进程反应缓慢。\n为了解决这些问题，大量难以维护和阅读的复杂代码被加入 Linux2.6.0 的调度器模块，虽然很多性能问题因此得到了解决，可是另外一个严重问题始终困扰着许多内核开发者。那就是代码的复杂度问题。这些不足催生了 Con Kolivas 的楼梯调度算法 SD，为调度器设计提供了一个新的思路。之后的 RSDL 和 CFS 都基于 SD 的许多基本思想。\n楼梯调度算法 #  O(1)调度器算法的主要复杂性来自动态优先级的计算，调度器根据平均睡眠时间和一些很难理解的经验公式来修正进程的优先级以及区分交互式进程。这样的代码很难阅读和维护。\n楼梯调度算法(staircase scheduler)抛弃了动态优先级的概念，而采用了一种完全公平的思路。其思路虽然简单，但是实验证明它对应交互式进程的响应比 O(1)调度器更好，而且极大地简化了代码。\n和 O(1)调度器一样，楼梯算法也同样为每一个优先级维护一个进程队列，并将这些队列组织在 active 数组中。当选取下一个被调度进程时，SD 算法也同样从 active 数组中直接读取。 与 O(1)算法不同在于，当进程用完了自己的时间片后，并不是被移到 expire 数组中。而是被加入 active 数组的低一优先级列表中，即将其降低一个级别。不过请注意这里只是将该任务插入低一级优先级任务列表中，任务本身的优先级并没有改变。当时间片再次用完，任务被再次放入更低一级优先级任务队列中。就像一部楼梯，任务每次用完了自己的时间片之后就下一级楼梯。\n任务下到最低一级楼梯时，如果时间片再次用完，它会回到初始优先级的下一级任务队列中。比如某进程的优先级为 1，当它到达最后一级台阶 140 后，再次用完时间片时将回到优先级为 2 的任务队列中，即第二级台阶。不过此时分配给该任务的 time_slice 将变成原来的 2 倍。比如原来该任务的时间片 time_slice 为 10ms，则现在变成了 20ms。基本的原则是，当任务下到楼梯底部时，再次用完时间片就回到上次下楼梯的起点的下一级台阶。并给予该任务相同于其最初分配的时间片。总结如下：设任务本身优先级为 P，当它从第 N 级台阶开始下楼梯并到达底部后，将回到第 N+1 级台阶。并且赋予该任务 N+1 倍的时间片。\n以上描述的是普通进程的调度算法，实时进程还是采用原来的调度策略，即 FIFO 或者 Round Robin。\n楼梯算法能避免进程饥饿现象，高优先级的进程会最终和低优先级的进程竞争，使得低优先级进程最终获得执行机会。\n对于交互式应用，当进入睡眠状态时，与它同等优先级的其他进程将一步一步地走下楼梯，进入低优先级进程队列。当该交互式进程再次唤醒后，它还留在高处的楼梯台阶上，从而能更快地被调度器选中，加速了响应时间。\n从实现角度看，SD 基本上还是沿用了 O(1)的整体框架，只是删除了 O(1)调度器中动态修改优先级的复杂代码；还淘汰了 expire 数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。\nRSDL 调度算法 #  RSDL（The Rotating Staircase Deadline Schedule）也是由 Con Kolivas 开发的，它是对 SD 算法的改进。核心的思想还是“完全公平”。没有复杂的动态优先级调整策略。\nRSDL 重新引入了 expire 数组。它为每一个优先级都分配了一个 “组时间配额”， 我们将组时间配额标记为 Tg；同一优先级的每个进程都拥有同样的\u0026quot;优先级时间配额\u0026quot;，本文中用 Tp 表示，以便于后续描述。\n当进程用完了自身的 Tp 时，就下降到下一优先级进程组中。这个过程和 SD 相同，在 RSDL 中这个过程叫做 minor rotation。请注意 Tp 不等于进程的时间片，而是小于进程的时间片。下图表示了 minor rotation。进程从 priority1 的队列中一步一步下到 priority140 之后回到 priority2 的队列中，这个过程如下图左边所示，然后从 priority 2 开始再次一步一步下楼，到底后再次反弹到 priority3 队列中。\n在 SD 算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得 CPU。因此低优先级进程的等待时间无法确定。RSDL 中，当高优先级进程组用完了它们的 Tg(即组时间配额)时，无论该组中是否还有进程 Tp 尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是 RSDL 中 Deadline 代表的含义。 进程用完了自己的时间片 time_slice 时（下图中 T2），将放入 expire 数组中它初始的优先级队列中(priority 1)。\n当 active 数组为空，或者所有的进程都降低到最低优先级时就会触发 major rotation：。Major rotation 交换 active 数组和 expire 数组，所有进程都恢复到初始状态，再一次从新开始 minor rotation 的过程。\n和 SD 同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为 minor rotation 而降到了低优先级进程队列中。当它重新进入 RUNNING 状态时，就获得了相对较高的优先级，从而能被迅速响应。\nCFS 完全公平调度算法 #  CFS 是最终被内核采纳的调度器。它从 RSDL/SD 中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS 的算法和实现都相当简单，众多的测试表明其性能也非常优越。\n按照作者 Ingo Molnar 的说法：\u0026ldquo;CFS 百分之八十的工作可以用一句话概括：CFS 在真实的硬件上模拟了完全理想的多任务处理器\u0026rdquo;。在“完全理想的多任务处理器“下，每个进程都能同时获得 CPU 的执行时间。当系统中有两个进程时，CPU 的计算时间被分成两份，每个进程获得 50%。然而在实际的硬件上，当一个进程占用 CPU 时，其它进程就必须等待。这就产生了不公平。\n假设 runqueue 中有 n 个进程，当前进程运行了 10ms。在“完全理想的多任务处理器”中，10ms 应该平分给 n 个进程(不考虑各个进程的 nice 值)，因此当前进程应得的时间是(10/n)ms，但是它却运行了 10ms。所以 CFS 将惩罚当前进程，使其它进程能够在下次调度时尽可能取代当前进程。最终实现所有进程的公平调度。下面将介绍 CFS 实现的一些重要部分，以便深入地理解 CFS 的工作原理[5]。\nCFS 如何选取下一个要调度的进程 #  CFS 抛弃了 active/expire 数组，而使用红黑树选取下一个被调度进程。所有状态为 RUNABLE 的进程都被插入红黑树。在每个调度点，CFS 调度器都会选择红黑树的最左边的叶子节点作为下一个将获得 cpu 的进程。\ntick 中断 #  在 CFS 中，tick 中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记 need_resched 标志，中断返回时就会调用 scheduler()完成进程切换。否则当前进程继续占用 CPU。从这里可以看到 CFS 抛弃了传统的时间片概念。Tick 中断只需更新红黑树，以前的所有调度器都在 tick 中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。\n红黑树键值计算 #  理解 CFS 的关键就是了解红黑树键值的计算方法。该键值由三个因子计算而得：一是进程已经占用的 CPU 时间；二是当前进程的 nice 值；三是当前的 cpu 负载。\n进程已经占用的 CPU 时间对键值的影响最大，其实很大程度上我们在理解 CFS 时可以简单地认为键值就等于进程已占用的 CPU 时间。因此该值越大，键值越大，从而使得当前进程向红黑树的右侧移动。另外 CFS 规定，nice 值为 1 的进程比 nice 值为 0 的进程多获得 10%的 CPU 时间。在计算键值时也考虑到这个因素，因此 nice 值越大，键值也越大。\n在本文中，我们将为每个进程维护的变量称为进程级变量，为每个 CPU 维护的称作 CPU 级变量，为每个 runqueue 维护的称为 runqueue 级变量。\nCFS 为每个进程都维护两个重要变量：fair_clock 和 wait_runtime。进程插入红黑树的键值即为 fair_clock – wait_runtime。\n fair_clock 从其字面含义上讲就是一个进程应获得的 CPU 时间，即等于进程已占用的 CPU 时间除以当前 runqueue 中的进程总数； wait_runtime 是进程的等待时间。它们的差值代表了一个进程的公平程度。该值越大，代表当前进程相对于其它进程越不公平。  对于交互式任务，wait_runtime 长时间得不到更新，因此它能拥有更高的红黑树键值，更靠近红黑树的左边。从而得到快速响应。 红黑树是平衡树，调度器每次总最左边读出一个叶子节点，该读取操作的时间复杂度是 O(LgN)。\n调度器管理器 #  为了支持实时进程，CFS 提供了调度器模块管理器。各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块。2.6.23 中，CFS 实现了两个调度算法，CFS 算法模块和实时调度模块。对应实时进程，将使用实时调度模块。对应普通进程则使用 CFS 算法。Ingo Molnar 还邀请 Con Kolivas 可以将 RSDL/SD 写成一个调度算法模块。\nCFS 源代码分析 #  每次时钟中断会调用 scheduler_tick()函数。它首先更新 runqueue 级变量 clock；然后调用 CFS 的 tick 处理函数 task_tick_fair()。task_tick_fair 主要工作是调用 entity_tick()。函数 entiry_tick 源代码如下：\nstatic void entity_tick(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  struct sched_entity _next;  dequeue_entity(cfs_rq, curr, 0);  enqueue_entity(cfs_rq, curr, 0);  next = **pick_next_entity(cfs_rq);  if (next == curr)  return;  __check_preempt_curr_fair(cfs_rq, next, curr,  sched_granularity(cfs_rq)); } 首先调用 dequeue_entity()函数将当前进程从红黑树中删除，再调用 enqueue_entity()重新插入。这两个动作就调整了当前进程在红黑树中的位置。_pick_next_entity()返回红黑树中最左边的节点，如果不再是当前进程，就调用_check_preempt_curr_fair。该函数设置调度标志，当中断返回时就会调用 p-\u0026gt;sleep_avg进行调度。 函数 enqueue_entity()的源码如下:\nenqueue_entity(struct cfs_rq _cfs_rq, struct sched_entity _se, int wakeup) {  update_curr(cfs_rq);  if (wakeup)  enqueue_sleeper(cfs_rq, se);  update_stats_enqueue(cfs_rq, se);  __enqueue_entity(cfs_rq, se); } 它的第一个工作是更新调度信息。然后将进程插入红黑树中。其中 update_curr()函数是核心。完成调度信息的更新:\nstatic void update_curr(struct cfs_rq _cfs_rq) { struct sched_entity _curr = cfs_rq_curr(cfs_rq); unsigned long delta_exec; if (unlikely(!curr)) return; delta_exec = (unsigned long)(rq_of(cfs_rq)-\u0026gt;clock - curr-\u0026gt;exec_start); curr-\u0026gt;delta_exec += delta_exec; if (unlikely(curr-\u0026gt;delta_exec \u0026gt; sysctl_sched_stat_granularity)) { __update_curr(cfs_rq, curr); curr-\u0026gt;delta_exec = 0; } curr-\u0026gt;exec_start = rq_of(cfs_rq)-\u0026gt;clock; } 该函数首先统计当前进程所获得的 CPU 时间，rq_of(cfs_rq)-\u0026gt;clock 值在 tick 中断中被更新，curr-\u0026gt;exec_start 就是当前进程开始获得 CPU 时的时间戳。两值相减就是当前进程所获得的 CPU 时间。将该变量存入 curr-\u0026gt;delta_exec 中。然后调用__update_curr():\n__update_curr(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  unsigned long delta, delta_exec, delta_fair, delta_mine;  struct load_weight _lw = \u0026amp;cfs_rq-load;  unsigned long load = lw-\u0026gt;weight;  delta_exec = curr-\u0026gt;delta_exec;  schedstat_set(curr-\u0026gt;exec_max, max((u64)delta_exec, curr-\u0026gt;exec_max));  curr-\u0026gt;sum_exec_runtime += delta_exec;  cfs_rq-\u0026gt;exec_clock += delta_exec;  if (unlikely(!load)) return;  delta_fair = calc_delta_fair(delta_exec, lw);  delta_mine = calc_delta_mine(delta_exec, curr-\u0026gt;load.weight, lw);  if (cfs_rq-\u0026gt;sleeper_bonus \u0026gt; sysctl_sched_min_granularity) {  delta = min((u64)delta_mine, cfs_rq-\u0026gt;sleeper_bonus);  delta = min(delta, (unsigned long)((long)sysctl_sched_runtime_limit - curr-\u0026gt;wait_runtime));  cfs_rq-\u0026gt;sleeper_bonus -= delta;  delta_mine -= delta;  }  cfs_rq-\u0026gt;fair_clock += delta_fair;  add_wait_runtime(cfs_rq, curr, delta_mine - delta_exec); } __update_curr()的主要工作就是更新前面提到的 fair_clock 和 wait_runtime。这两个值的差值就是后面进程插入红黑树的键值。变量 Delta_exec 保存了前面获得的当前进程所占用的 CPU 时间。函数 calc_delta_fair()根据 cpu 负载（保存在 lw 变量中），对 delta_exec 进行修正，然后将结果保存到 delta_fair 变量中，随后将 fair_clock 增加 delta_fair。函数 calc_delta_mine()根据 nice 值（保存在 curr-\u0026gt;load.weight 中）和 cpu 负载修正 delta_exec，将结果保存在 delta_mine 中。根据源代码中的注释，delta_mine 就表示当前进程应该获得的 CPU 时间。\n随后将 delta_fair 加给 fair_clock 而将 delta_mine-delta_exec 加给 wait_runtime。函数 add_wait_runtime 中两次将 wait_runtime 减去 delta_mine-delta_exec。由于 calc_delt_xx()函数对 delta_exec 仅做了较小的修改，为了讨论方便，我们可以忽略它们对 delta_exec 的修改。最终的结果可以近似看成 fair_clock 增加了一倍的 delta_exec，而 wait_runtime 减小了两倍的 delta_exec。因此键值 fair_clock-wait_runtime 最终增加了一倍的 delta_exec 值。键值增加，使得当前进程再次插入红黑树中就向右移动了。\nCFS 小结 #  以上的讨论看出 CFS 对以前的调度器进行了很大改动。用红黑树代替优先级数组；用完全公平的策略代替动态优先级策略；引入了模块管理器；它修改了原来 Linux2.6.0 调度器模块 70%的代码。结构更简单灵活，算法适应性更高。相比于 RSDL，虽然都基于完全公平的原理，但是它们的实现完全不同。相比之下，CFS 更加清晰简单，有更好的扩展性。\nCFS 还有一个重要特点，即调度粒度小。CFS 之前的调度器中，除了进程调用了某些阻塞函数而主动参与调度之外，每个进程都只有在用完了时间片或者属于自己的时间配额之后才被抢占。而 CFS 则在每次 tick 都进行检查，如果当前进程不再处于红黑树的左边，就被抢占。在高负载的服务器上，通过调整调度粒度能够获得更好的调度性能。\n在最新版本的 CFS 实现中，内核使用虚拟运行时间 vruntime 替代了等待时间，但是基本的调度原理和排序方式没有太多变化。\n参考资料 #  [1] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核[M]. 中国电力出版社, 2001.\n[2] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核(第三版)[M]. 中国电力出版社, 2007.\n[3] 陈莉君, 康华. Linux 操作系统原理与应用[M]. 清华大学出版社, 2006.\n[4] RobertLove, 洛夫, 陈莉君, et al. Linux 内核设计与实现[M]. 机械工业出版社, 2006.\n[5] Linux 调度器发展简述 https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/\n[6] O(n)、O(1)和 CFS 调度器 http://www.wowotech.net/process_management/scheduler-history.html\n[7] 调度系统设计精要 https://draveness.me/system-design-scheduler/\n[8] 进程调度之 6：进程的调度与切换 https://my.oschina.net/u/3857782/blog/1857556\n"},{"id":11,"href":"/docs/cs/the-clean-coder/","title":"The Clean Coder","section":"计算机","content":"《The Clean Coder》 阅读记录 #  术道结合，这本书不教术，更多的传道，且不仅仅适用于职业，还适用于处理其他事物。尽管是只可意会的道，依然可以通过娓娓道来的叙述与提炼，使读者联系自身经历，揣摩体悟，纳为己用。\n0、关于职业素养 #  如何体现职业素养？\n从自身出发，回答一个问题：在过去的工作中，遇到过哪些印象深刻的困难，最后是怎么解决的？ 问题不在于问题的难度，而在于反思的程度：怎么分析问题、查阅什么资料、采取解决问题的方式步骤、采取什么措施避免和改进。\n从外部出发，是否对外展示了专业精神获得外部人员的信任？是否需要对你进行微观管理才能令人放心？\n总结起来，职业素养 = 能力（技术） + 素质（价值观、原则、态度）+ 持续的积累和养成。\n关于价值观，可阅读前言部分 “挑战者”号航天飞机工程师的故事。  1、专业主义 #  “哦！笑吧，科延，老伙计。这是上帝，或者也可以说时命运或自然，跟我们开的一个玩笑。不过，不管这家伙是谁或是什么，他真幽默！哈哈！” —— 霍华德，《碧血金沙》    清楚你到底要的是什么？真的是成为专业人士吗？不仅仅是荣誉与骄傲，更多的是责任与义务。\n  担当责任，不仅如何保全自己，还有客户及他人。\n  不行损害之事：让 QA 找不出任何问题 + TDD 100% 覆盖率的要求 + 随时重构 + 自动化 QA  0、就像医生一样，虽然 Bug 无法避免，但是需要为出现的 Bug 负责。 1、练习道歉，道歉时必要的。 2、不能铭记过去的人，注定要重蹈覆辙。有责任让失误率无限接近零。     专业人士的职业生涯：\n 了解你的领域，如设计模式。过去来之不易的理念，大部分依然像过去一样富有价值。 坚持学习，与时俱进：想想你会去找已经不看医学期刊的医生看病、会聘请不了解最新税法和判例的税务律师吗？ 需要投入时间和精力去追求和练习（想想音乐家的表演和练习）。因为热爱，额外的20小时能让你免于枯竭匮乏。 合作与辅导是必要的。 了解业务领域：不可以不求甚解，能辨别与质疑。 与雇主 / 客户保持一致：站在雇主的角度思考，而开发人员之间互相认同是容易的，应当避免狭隘之见。 谦逊。  编程是及其自负的行为，专业人士知道此，因此不会故作谦逊：他们熟知自己的工作，并引以为荣；他们对自己的能力充满自信，并因此用于承担有把握的风险。专业人士不是胆小鬼。 然而，专业人士也知道自己会摔跟头，自己的风险评估也有出错的时候，自己也有力不从心的时候。这时候，如果他们照照镜子，会看到那个自负的傻瓜正对着自己笑。 因此，在发现自己成为笑柄时，专业人士会第一个发笑。他从不会嘲讽别人，自作自受时他会接受别人的嘲讽。反之，他则会一笑了之。他不会因别人犯错就对之横加贬损，因为他知道，自己就是下一个犯错的人。 专业人士都清楚自己的自负，也知道上天会注意到这种自负，并加以惩戒。如若果真遭遇挫折，最好的办法就是按照霍华德说的————一笑了之吧！       2、说不 #  “能就是能，不能就是不能。不要说‘试试看’。” ———— 尤达  奴隶没有权利说“不”。劳工或许也对说“不”有所顾虑。但是专业人士应该懂得说“不”。只有敢于说“不”，才能真正做成一些事情。  2.1 对抗角色 #  13、团队与项目 #   有凝聚力的团队：团队组建、克服差异（一起搞定一切）、多个项目中整体移动 给足时间，成为引擎，军团  14、辅导、学徒期与职业素养 #   导师很重要，可以更好、更加顺利地跨过一些坎。 可以有多种形式的辅导。 软件学徒期是必要的，类比医学生（人命关天） 职业素养：能力（技术）和素质（价值观、原则、态度），以及持续的积累和养成。 非理性决策，非感情用事，只要能被人观察到，便具有传染性：成为表率，向人展示即可。  15、工具 #   使用工具，不再是思考下一步要键入什么字符或代码，而是思考接下来要对代码进行什么样的变换。  "},{"id":12,"href":"/docs/example/table-of-contents/without-toc/","title":"Without ToC","section":"Table of Contents","content":"At me ipso nepotibus nunc celebratior genus #  Tanto oblite #  Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius #  Quibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\n Remansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit  Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae #  Credulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\n Baculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra  Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"},{"id":13,"href":"/docs/algorithm/tree/1/","title":"二叉树 - 子树分解题","section":"二叉树","content":"二叉树 - 子树分解题 #  基础 #   https://leetcode-cn.com/problems/diameter-of-binary-tree/ https://leetcode-cn.com/problems/invert-binary-tree/submissions/ https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/  构造题 #   https://leetcode-cn.com/problems/maximum-binary-tree/  "},{"id":14,"href":"/docs/algorithm/tree/3/","title":"二叉树 - 构造题","section":"二叉树","content":"二叉树 - 构造题 #   https://leetcode-cn.com/problems/maximum-binary-tree/ https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/  "},{"id":15,"href":"/docs/algorithm/tree/2/","title":"二叉树 - 遍历题","section":"二叉树","content":"二叉树 - 遍历题 #   https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/  "},{"id":16,"href":"/docs/law/system/%E5%95%86%E5%85%A5%E5%85%AC%E5%8F%B8%E6%B3%95/","title":"商入公司法","section":"系统","content":"“商入公司法” #  商法调整的是商事关系，商事几乎包括各种以营利为的商品交换以及与此相关的其他活动。\n一般而言，商事关系具有以下特征：一是主体的平等性；二是只发生在以营利为目的而进行的商事活动过程，这是商事关系区分于其他法律关系尤其是普通民事关系的最重要的特点。营利至少包括获取利益、常业性。\n商法按内容来分包括商事组织法与商事行为法。\n 商组织作为从事商活动的主体，关系到方方面面，法律自然要设定规范，规制其准入与存续。商组织法包括商事主体的设立、组织、管理、变更、解散、破产、清算而发生的内外关系。对外关系主要由债等民法调整，因而主要是对内关系。 商行为存在着商活动的特性，有别于一般的民事行为，因而也被特殊规定。商行为法包括票据法、证券法、保险法和海商法等商法部门。  公司法是最主要的商组织法。\n公司本质 #  公司的法律性质即为最底层的法律原则。\n公司概念 #  在大陆法系国家，公司仅指具有法人资格的营利性社团，从实质来看，它至少具有三个要素构成，即独立的人格、个人结合的社团、以营利为目的；在形式上它还要满足依法设立，即依据商事法律规定的条件和程序而设立公司。\n人格性 #  指公司具有独立的人格，这种独立的人格使其能够区别于其成员而独立存在。\n人格是权利义务的归属点，拥有人格意味着公司具有权利能力和行为能力，能够享有权利，承担义务。能够独立从事经营活动，实施法律行为，并能够依法承担民事责任。\n公司人格的外征表现：名称（区分）、独立财产（承担责任，公司的财产丧失可能导致人格也消灭）、自己的组织机构（意志形成、行为执行）。\n公司需要依法登记才能取得独立人格地位。因此在一定意义上可以说完全是法律的产物，是法律上的一种拟制。（1）采用二元主体的民事架构，最主要的目的在于方便公司从事各种经营活动；（2）拟制并不意味着有实体，因而公司人格具有可否认性。\n社团性 #  即以社员的结合作为其成立基础，我国《公司法》采用的是企业法人，民法典表达为“营利主义”。现代公司法显示承认一人公司的存在已成为时代的潮流，我国现行公司法也已经突破了公司的社团性，规定了一人有限责任公司。\n营利性 #  以营利为目的指组织公司成员各自以其出资经营某项事业并将公司所获得的利益分配给它的社员作为最终目的。\n公司企业存在的目的在于追求利润最大化，表现为（1）股利的分配；（2）剩余财产的分配。\n现代公司法要求公司在考虑利润最大化目标时，也要兼顾“利益相关者（stakeholder/other constituencies）”的利益，即承担一定的社会责任。\n公司特征 #  制度的价值、作用，主要内容，法律立场。\n即公司这种企业区别于其他商事组织，而使其成功的原因特征：集中管理、所有人的有限责任、的股权自由转让和公司的永久存在。\n集中管理 #  所有权和经营权的分离，将公司交给更具备专业技术经验的经营者。但集中管理在封闭公司是不明显的。\n 投资者有限责任的产生：既然股东不能直接参与企业管理，又怎么能够像合伙人承担无限责任呢 所有者权益的自由转让：如果股东对公司经营不满意，他可以通过股权转让退出公司。 公司的独立主体地位：只要投资人愿意，公司可以无限期地存在。  有限责任 #  按认缴的出资额或认购的股份份额承担责任。核心是在公司和其股东划出一条明显的界限。“简单来讲，对于投资者而言其可以多项投资，更敢更省事；对于实际经营管理者而言，只有公司经营良好才不至于使股权被收购自己被替换。”\n 降低监控代理人的成本，投资人可以多样化投资来分散风险，也可以多样化和消极监督 降低监控其他股东的成本，合伙制情形下合伙人还要监督其他合伙人的财产状况 股份自由转让会刺激管理层进行更为有效的管理 有限责任存在股份交易的公开市场，价格能够极大的企业价值的附加信息，减少投资人花费大量资源去考察附加信息 投资者可以多样化投资，这也大大降低了企业筹资成本 促进投资者投资风险事业的投资而不至于遭受毁灭性损失  股权自由转让 #  公众公司存在为其股份转让的公开市场。\n 股东可以自由退出而公司资本不致减少 促使公司管理水平的提高 公开市场能够最大限度地反映财产的价值  公司的永久存在 #  实际含义是公司不会像合伙企业那样因为成员的退出而导致解散，合伙的存在依附于合伙协议。公司”永续存在“，但其控制权却可能发生了无数次的易手。\n公司法律性质探讨 #  基于法理和体系的视角中，进一步挖掘的公司的本质特征。\n法人说 #  公司是法人，具有独立的主体地位。公司完全是法律的产物，公司的设立和运作均需要依照法律的规定进行。公司法具有明显的强制性特征。\n法人理论受到了相当的批评，其认为法人说片面强调形式主义，公司是一种虚拟的实体，而非真实意义上的人，公司之所以是”法人“，只不过是因为法律进行了这样的，而公司之所以讲公司拟人化，主要是为了方便人们从事商事经营活动。\n批评者进一步分析，人们常将有限责任、法人身份以及永久存在视为公司的显著特征，这其实是一种误导性陈述。\n 有限责任只是意味着投资者所承担的企业风险不会超过其初始成本，这是投资的特征而非公司的特征。 法人身份和永久存在仅仅意味着公司在解散之前持续存在，并且有一个名称以便于交易和应付诉讼，否则公司在进行某一项交易时，公司都需要次次明确公司所有投资者的名单及份额。  公司法人虚拟性的一个反正是在特定而有限的情况下，如果这种虚拟实体实施了欺诈行为或明显违反法律政策或是实施了其他有害行为，法律可以适用“揭开公司面纱”原则否认其人格。\n契约关系说 #  公司完全是由当事人一系列协议构成，当事人有权对诸如公司治理等问题进行自主安排。\n契约关系理论认为企业是雇员、管理者、股东等资源结合起来自行安排各种交易，他们共同收到一种复杂的契约关系链条的约束。\n企业并不是某种人格化的东西，而是在组成企业的各种要素之间确定了一系列合约安排，即一系列合同束。除了当事人约定的合同之外，有一些合同体现着法院和立法者的意志，这类合同的作用在于，它有如人们在遇到类似问题而真正订立合同时必然会采用这样的条款一样。\n其中体现了经济学家与法学家极为不同的差异，即对于隐形合同的认可与否，法学家认为合同在于传统的要约承诺，公众公司从来没有阅读过公司章程，最多只能说他们接受这份章程，而不可能认定是预定的。\n契约论实际上是应然而非实然，即这样的合同内容符合追利人的期待，是节省成本的一种安排，自由订立也会选择该规范。\n契约关系论反对公司法人理论，认为“公司的法人性恰恰掩盖了交易的本质”，因为每一根人只拥有自己投入的一部分，任何人无权对公司享有全部所有权。公司中的中心人物是管理者。\n相反地，其认为公司只不过是一种契约关系，政府不能对私人商业活动干预，政府不应该通过制定法形式讲强制性规范加于公司或当事人。而政府的特许令状不过是对于公司这种契约的承认而已，并诉讼方便，交易便利。\n契约论最重要的优点在于转变公司法的规范态度，给公司更多的活性，能够更加充分的发挥公司的优势，自由管理主体优势。\n"},{"id":17,"href":"/docs/law/system/%E5%9B%BD%E9%99%85%E6%8A%95%E8%B5%84%E4%BB%B2%E8%A3%81%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E6%94%B9%E9%9D%A9/","title":"国际投资仲裁的发展与改革","section":"系统","content":"国际投资仲裁的发展与改革——为什么仲裁结果总是不统一，除了增加透明度与设立上诉机制我们还能做什么 #  国际投资仲裁概况 #  20世纪60年代后期，国际社会开始尝试将国际仲裁作为解决主权国家与外国私人投资者之间投资争议的方式，缔结了《华盛顿公约》，建立了解决投资争议国际中心ICSID，ICSID允许加入国拒绝将某项具体争议提交ICSID仲裁，也有权将某些种类的争议排除在可仲裁的范围之外。因而更为可接受，但20世纪90年代子厚，这种节制的机制开始逐渐失去戒指，美式BIT和一些区域性贸易协定的投资章节规定投资者可以直接提请国际仲裁，导致国家主权的行政权、司法权、立法权受到挑战。\n实体问题 #   适格投资、适格投资者的范围过于广泛：华盛顿公约允许将缔约国国民控制的非缔约国公司视为公约意义上的合格投资者 模糊的实体法规范：没有统一的解释，使主权国家对专辑的行为符合shi\u0026rsquo;fou条约要求缺乏预见性，也为仲裁庭随意解释这些条款增加的条约义务了chuang\u0026rsquo;zao条件。eg公平公正没有准确的标准可循。 措施的概念过于宽泛，只要投资者认为东道国采取的措施违反了在投资条约下的义务就可以提起国际仲裁，而措施已经不仅包括行政管理措施，还包括东道国的司法行为和立法行为。egloewen诉美国案认定法院在案件审理过程中存在严重的审判不公和行为不当的情形。  程序问题 #   东道国无需具体同意，而是”概括的同意“，在事前的同意时，东道国同意将争议提交国际仲裁裁决时，根本无法与之ujin\u0026rsquo;h会否与投资者发生纠纷以及因何原因发生纠纷。 现代投资条约中的程序性涉及缺乏对仲裁员自由裁量权和仲裁程序的适当监督和对不一致裁决的适当协调和纠正，出现投资者倾向的仲裁员。 执行不被认可。 现代投资条约为投资者提供了诸多挑选救济场所的机会，可以通过多个BIT重复申请。  国际投资仲裁的发展与改革现况 #  仲裁特征：一裁终局和自由选择仲裁员。\n概况：美欧对国际投资仲裁机制进行改革的不同模式 #  针对国际投资仲裁机制的缺陷，美国与欧盟在传统双边协定模式的基础上，分别以北美自由贸易协定模式与常设仲裁模式加以改革。**两种模式在仲裁员由谁指定、上诉机制的设置以及仲裁庭的常设性和多边性等存在制度分歧。**美欧的制度不仅反映了两者对国际投资仲裁机制改革应采取投资者主导型还是东道国主导型路径的不同认知，还反映了两者对国际投资仲裁制度主导权的争夺。（1） 关于国家投资仲裁的改革，主要集中在是否建立一个常设的投资仲裁法庭和规定上诉机制的问题上。联合国贸易和发展委员会议提出了详细的国际投资协定的改革建议，包括设立一个常设的攻击投资仲裁法庭以及上诉机制。（7）\n投资争议解决机制是近四十年来国际投资协定中的常见条款，投资者诉国家解决争端解决机制（ISDS，investor-State Dispute Settlement）赋予投资者国际仲裁方式起诉东道国的权利。 （2）\nUNCTAD world investment report 可以看到现在的国际投资仲裁数量\n有人认为，国际投资仲裁制度或许正遭遇一场“正当性危机”（legitimacy crisis，即国际投资仲裁由于在解决国际投资争端方面不胜任而引发的信任危机。主要在于1投资条约中没有清楚、确定地规定投资者权利标注暖，致使当事人、仲裁庭在适用投资条约时缺乏预见性，尤其时不同仲裁庭就类似案件的决定常常不一致2国际投资条约在程序上对投资者利益的保护甚于对东道国利益的保护，有损东道国主权（3） 事实表明，传统给国际商事仲裁引以为自豪的一些优势，如非公开地处理争端、仲裁庭的成立相对简便易行、仲裁裁决一裁终局且具有强制执行力、仲裁员拥有充分的自由裁量权等，反而被证明具有种种缺陷，因为这涉及判断一个主权行为是否在国际法上属于合法行为。（程序实体） 2013年6月，联合国贸易与发展大会（UNCTAD）曾发布一份报告，对目前国际投资仲裁制度受到广泛诟病的几个方面进行了总结，并未如何改革提出了”路线图“，根据该报告，目前国际投资仲裁机制的弊端主要包括：程序的正当性和透明度不够（我们一般讲的正当性不够指的是更加倾向于投资者的利益，背景是最开始签订的时候发展中国家就让渡了相应的权利以求投资，一开始就是不平等的；指的是对公众知情权东道国公权力行使的侵犯：是相对于一般的商事仲裁而言的）；仲裁裁决缺乏一致性以及错误的裁决无法纠正（同类案不同判，同类规定不同解释。国际投资仲裁中，任何仲裁庭的裁决都不会对其他仲裁庭有任何约束力，仲裁庭都有权就自己案件中争议的问题重新进行审判）；仲裁员由当事人指定，使仲裁员的独立性和中立性都受到质疑；使仲裁程序的时间和经济成本过高。（5）裁决的矫正机制缺失：是哟个法律不正确并不是ICSID公约的裁决撤销理由。不一致可以从伊克卡乐公司案与基里克案关于投资者是否需要用尽当地救济才能够提起国际投资仲裁二者做出了截然不同的解释，并且仲裁员中的桑兹教授均为仲裁员。（8） 评价制度和评价改革就能够从与目前国际投资仲裁的弊端具有什么样的相关关系来进行逐条分析。\nICSID的成立是改善发展中国家投资环境所作出的一项重要的多边努力。现在，ICSID不在苦于案源不足，而是逐步意识到在效率、声誉等方面面临着挑战，呼吁投资者积极利用ICSID调节机制或自行解决争端。有学者认为ICSID裁决缺乏一致性；更有学者批判国际投资仲裁的程序缺陷，如仲裁员存在偏见、程序不公开、耗时费钱等。（4）\n众所周知，ICSID的产生很大程度上是二战后南北矛盾的产物，其发展也是南北矛盾演进的一个缩影。换言之，发达国家虽然认为发展中家落后的法制状况难以为外国投资者提供有效保护，但也意识到传统外交保护可能被认为是干涉内政，因而谋求创设某种国际争端解决机制。与此同时，为吸收外资并避免发达国家以保护海外投资为名干涉内政，暗中国家fa\u0026rsquo;z对于创设国际争端解决机制也具有显示的利益，因而同意适当让渡对涉外投资争端的管辖权。（4） 1肇始于于20世纪下半夜的国际投资法律制度源于解决资本输出国的外国投资者在资本输入国受到不公正待遇而制定额双边投资协定，早期主要目的在于避免后殖民化时期外国投资者受到东道国不断改革的法律和这个测制度所产生的负面影响。二战后面对的是东道国对于其财产的征收通常没有给予补偿，而这种行为明显侵犯其财产权和其他权力。2随着经济民族主义的衰退，发展中国家开始采取各种方法吸引外资，在很大程度上不公正对待外国投资的现象少了，这一时期的投资争端数量减少了而且集中东道国对外国投资的歧视或违反公平公正待遇等问题上3随着21实现可持续发展的目标提出以及国家对外国投资带来负面印象，投资者根据相关投资以xi的尸体保护标准提起赔偿诉求的案件不断增加，而仲裁庭做出䣌不利于东道国的巨额赔偿裁决给的东道国经济发展带来沉重的负担，包括发达国家也开对国际投资仲裁有了怀疑态度。（8）\n国际投资法正在经历一个巨大的变化，相较于过去只重视投资者利益的做法，人们越来越意识到投资仲裁中的公法属性，(9)\n卡尔沃主义：在西方探险家发现每周新大陆后，拉美国家开始遭受西方列强以外交保护为名干涉内政的痛苦经历，国家主权受到严重侵犯，在此背景下，19世纪阿根廷国际法学家卡洛斯·卡尔沃提出了著名的”卡尔沃主义“，其根本总之在于拒绝干涉内政，维护国家主权。卡尔沃主义的基本原则有两项：一是主权国家基于主权平等原则不受任何形式的干涉；而是外国人物权享受东道国没有对国民规定的权利或特权，外国人只能寻求当地救济，不干涉及外国人与本国人之间的绝对平等是卡尔沃主义的本质所在。（4）\n美国与欧盟模式 #   传统双边投资协定模式（传统BIT模式）：脱胎于商事仲裁，授予投资者对东道国政府违反国际投资协定的行为提起仲裁的权利，允许其自由选择国际投资争端解决中心ICSID或联合国国际贸易法委员会UNCITRAL提供的仲裁规则或双方约定的其他仲裁规则开展仲裁，双方投资协定对仲裁员制定、仲裁程序透明度和参与性、上诉机制、轻佻仲裁请求（frivolous claim）、竞合或平行程序等不做限定或补充。这种模式在20世纪90年代之前发达国家和发展中国家签订的投资双边协定中比较常见。 2.环境变化： 20世纪90年代之后，国际投资环境发生变化，新兴国家崛起，南南合作、北北合作增加，资本流动不再限于南北国家之间的依附性流动。争议对象多为发达国家的公共健康及环境政策，而不再是传统上东道国政府对投资财产的直接征收措施。投资争议类型的改变，催生国际投资仲裁机制功能的改变，资本输出国所提供的条约文本不仅需要具备海外投资利益保护的“攻击性”功能，还需具备防范境外投资者滥诉以及制约本国政府形式提供环境、公共卫生等公共产品只能的“防御性”功能，并由此改善国际投资法环境。 （2）对当前ISDS机制最常见的批评是认为它威胁到主权国家通过立法实现合法公共政策目的的能力。仲裁裁决没有充分保护政府的管制权，仲裁庭解释权过大，损害了政府的权利。 美国：率先对攻击投资仲裁机制做出调整，94年《北美自由贸易协定》第11章国际投资仲裁条款对传统BIT模式做出修订，形成北美自由贸易协定模式（NAFTA模式）NAFTA模式仍允许争端方选择ICSID和UNCITRAL等投资仲裁规则，但在协定中对后者做出补充或限制。例如：该协定增加了仲裁程序的透明度，允许非争议第三方及“法庭之友”提交意见书。浙西都是对传统BIT模式的调整。又如，在争端方未能制定仲裁员或首席仲裁员的情形下，该协定将ICSID仲裁规则下世界银行行长对仲裁员的制定权转移至《北美自由贸易协定》秘书处，从而强化了争端放对仲裁员的控制，对传统BIT模式形成限制。 NAFTA对于仲裁机制的改革并不彻底，虽然提高了国际投资仲裁程序的透明度与参与性，但未从根本上解决仲裁庭的问责性不足和裁决不一致问题。美国在《美国与中美州五国和多米尼加自由贸易协定》及《美国与新加坡自由贸易协定》中提出设置上诉机制的构想，以强化仲裁机制的问责性。2016年签署的《跨太平洋伙伴关系协定TPP》中有关仲裁程序的透明度、第三方参与、上诉机制的条款亦延续了美式投资协定对NAFTA模式进行改革的传统。（11）目前，除美国以外，NAFTA模式还为加拿大、日本、韩国等国对外签订的国际投资协定所采纳。中国在2014年签署的《中加投资促进及保护协定》和2015年签署的《忠告自由贸易协定》中也采纳了此模式。 欧盟：欧盟第国际投资仲裁机制的改革要晚于美国，但改革力度更大。其背景在于1999年金融危机后，比利时、希腊、塞浦路斯等欧盟成员国因调整财政政策而纷纷陷入投资争端12，使得欧洲议会不得不正视国际投资仲裁机制对欧盟公共政策的挑战，要求欧盟委员会制定具体政策，避免成员国公共政策成为投资者起诉对象。（出于国家自愿，所以体现了国家的主观目的特征）在与美国进行的2013年《跨大西洋贸易与投资伙伴协定TTIP》谈判中，欧洲市民高呼废除国际投资仲裁机制，而欧洲议会及欧盟委员虽然最终决定保留国际投资仲裁机制，但对其予以答复改革，例如严格限定仲裁员资质和任期、固定仲裁原名册、设立上诉机制等（14）。草案不仅允许仲裁庭接受法庭之友意见（amicus curiae），也允许与案件结果有直接现实利益的第三方接入到程序中（right to intervene）,有助于加强程序公正；草案要求接受第三方资助的当事方披露资助方的信息，以及要求缴纳担保费，看可以限制投资者轻率起诉；草案提出建立上诉法庭，其主要理由是解决投资仲裁裁决的一致性问题；上诉法庭由6位法官组成，欧盟、美国和第三国各占2席，任期6年，可连任一次。  2015年5月欧盟贸易委员提交的一份报告提出设立常设仲裁庭的构想15，设立常设仲裁庭、以东道国为主导的常设仲裁庭模式最终出现在2016年欧盟与加拿大和越南分别达成的《欧加全面经济与贸易协定》和《欧越自由贸易协定》中。常设仲裁庭与NAFTA模式一致的地方在于，投资者依然可以适用ICSID与UNCITRAL等仲裁程序规则，国际投资协定对仲裁程序的透明度、第三方参与等问题作出较补充。但常设仲裁模式目前仍处于摸索阶段，仅在上述自由贸易协定中出现，尚不具有普遍性。\n2015年末，欧盟公布了与美国进行《环大西洋贸易和投资伙伴协定》谈判的投资章节的建议草案，之后欧加贸易协定、欧越贸易协定，都包括改革后的国际投资争端积极而机制，即设立常设的投资仲裁法庭制度，包括普通法庭共和上诉法庭。 欧盟包括三点：1消除国际商事仲裁制度运用于解决投资者-国家投资争端的弊端；与投资仲裁对东道国国内造成的影响不匹配；增强裁决一致性的建议层出不穷，而建立上诉机制一致被认为是最好的方法，如建立类似世界贸易组织上诉机构的上级法律组织来指导、监督临时成立的仲裁庭的工作。但要实现这一点，困难十足，在欠缺所谓“初步裁决”只丢的昂下qing\u0026rsquo;k，需要对当前主流制度性规定做出修改需要有关成员国就此问题达成政治和李，eg华盛顿公约裁决不得被任何上诉神擦汗，要修改需要得到全体成员国协商一致。设置解释委员会：仲裁员拥有的自由裁量权和解释条约的权因此设立解释力过大，甚至可能做出为违反缔约国意图，因而设立一个由各投资者组成的解释委员会，使成员国对涉及其自身的条款有更大的解释权。但是这样的杰斯还行只能适用于生效之后的诉请，而不具有任何溯及力，因而可能造成“亡羊补牢”的效果。增加透明度：目前只有在仲裁双方共同同意时才能将仲裁文件公开，因此很多投资者诉东道国的案件根本没有或者只有极少数文件被公布出来，欧盟不仅投资建立了对公众开放注册登录及查阅的数据库，主要从公开仲裁程序的重要文件，许可法庭之友的书面陈述及听证会分开等方面提高程序的透明度，2增强对东道国维护公共利益措施的考量，尽可能在保护投资者私人利益和为u东道国公共利益之间取得平衡3尽力防止投资者对投资仲裁程序的滥用。（9）\n增加透明度 #  （3）在国际商事仲裁制度中，仲裁机构往往不公开仲裁程序和仲裁文书，但仲裁制度应该有更强的透明度，具体说来，国际投资仲裁制度应当允许公开仲裁裁决及案件相关材料，应当第三人允许作为法庭之友或仲裁第三人加入仲裁程序：1BIT许多规则相对模糊，国际投资仲裁听在适用该规定时就徐做出解释，如仲裁庭有机会参考先前类似判决、听取第三方的意见，则仲裁庭将能够更全面地思考问题，以减少仲裁裁决前后不一致的情况。2国家投资争端往往涉及国家主权和公共利益，增强仲裁程序的透明度也将使公众能够关注、监督仲裁进程，这也将促使仲裁员更加谨慎地做出审判，一球投资者和东道国公共利益的平衡。 （6）”秘密进行的会议，未知的仲裁员，做出的不公开的裁决“这一小撮人对投资者与外国政府之间的争端做出的仲裁裁决，使一个国家的法律被废止，司法体系受到之一，环境法规遭到挑战。这也是《纽约时报》对于国际投资仲裁秘密性所引发的主要问题。除此之外，投资者与东道国的争端解决结果还会对公共资金和纳税人的税负产生重大影响，因为东道国一旦败诉即将面临高额赔偿。 从价值取向来看，投资者与东道国之间的关系仍然是司法人与公法人之间的不平等的关系，而政府活动需要遵守透明度和公共接入的基本要求。\n透明度改革的实现路径 #  国际投资条约 #  NAFTA直接以自由贸易委员会做出的解释性声明形式予以明确，条约局限于缔约方与另一缔约国投资者之间的争端。\n仲裁机构的仲裁规则 #  ICSID采取在其仲裁规则中讲透明度内容的条款进行规定或修改的方式 UNCITRAL《透明度规则》的适用涉及两种情况，对于《透明度规则》第1条范围内的条约，即2014年4月1日及以后订立的条约，以及之前订但仲裁双方同意适用的，或条约缔约方或涉及多边的tiao\u0026rsquo;yue投资人母国和被申请过同意适用（透明度规则）的条约。 关于《透明度规则》适用于现行投资条约，贸易法委员会则采用公约的方式实现，依据此方案，一国一旦加入此公约，《透明度规则》的适用范围将很广。\n条约与仲裁机构的规则相冲突 #  通常以条约为准。UNCITRA直接规定透明度规则与条约冲突以条约为准，ICSID仲裁规则第20条第2款规定”仲裁庭在仲裁程序中，应适用双方当事人有关程序问题的任何协议，但公约或行政和财务条例另有规定的除外。“\n透明度的具体内容（6） #   启动程序的公告 确保公众知晓东道国的争端已经启动，主体为被答辩方或仲裁庭.除此之外，联合国已于2014年4月1日在维也纳设立了透明度登记处。 仲裁程序中的文件公开 使公众获取相关仲裁信息和进展情况，也是涉及到主体范围时间，在具体文件的供不上，UNCITRAL有了一定创新，分为应当公布，经任何人请求应当公布以及仲裁庭行使自由裁量权公布三类，并应当主义保密信息的要求。 听证会的公开 用于保障公众对公共利益问题的参与权，分歧在于当事方是否审理的公开拥有否决权。 法庭之友 最终裁决结果 最终裁决结果以仲裁庭为宜。 透明度的例外 即对于保密信息的保护，从文本内容看，目前已进行的一些条约或仲裁规则对于透明度的的内容规定标准并不统一。ICSID的规定较为简略，相比之下USbit做了较为全面的规定，不仅详细列举了需要保护的信息，并对具体的保护程序做了安排，UNCITRAL工作组在起草相关条文内容的时候存在较大分歧主要集中在保密信息的认定是否可以依据被申请过的法律，后认为支持这一观点。  评价 #  积极意义在于对于之前的倾向投资者的直通车程序能够保证公众对公共事务的知情权和参与权，使公共利益问题得以通过可续恶的而方式决定，有利于仲裁员在投资者与东道国之间权利与利益的平衡。但面临着法律和技术层面的若干难题：（1）如何确保法庭之友的介入控制咋合理程度而不对争议双方造成不必要的损害；（2）透明度程序如何保证中参与gon以及文件公开的程序在合理时间内进行，不至于减损仲裁的效率优势；（3）如何确保文件公开的程序以合理的成本尽心，不至于增加争议双反过的负担等等。\n设立上诉机制 #  （2）2004年ICSID曾发布报告讨论建立上诉机制，尽管很多人认为有必要建立上诉机制，但是ICSID成员国认为还是为时过早，如果未来需要建立上诉机制，最好的办法还是通过ICSID，以提高不同之间条约结果的一致性。双边投资所建立的上诉机制更有可能投资法的碎片化，上诉机制对于提升裁判结果一致性的作用很可能会被夸大。尽管上诉机制可以增强裁决的一致性，但是增加案件的审理案件的审理时间，使得案件更加昂贵，这将加重中小投资者和发展中国家的负担。 （4）到2005年年中，可能有20个iaguo在BIT中考虑针对投资仲裁设立上诉机制，众多国家对国际投资仲裁机制的忧虑已经对ICSID产生了影响，促使ICSID开始考虑在ICSID体制内设立上诉机制问题。 （7）1.必要性（现况）已经从学者谈论阶段转为条文改革实践阶段；现况是不少仲裁案件的发生系基于相同或相似的条约条款、类似的商业背景和政府管理措施，但不同仲裁庭就相同或相似的条约义务做出的经常不同甚至完全相反。其问题还是在于仲裁庭过分地倾向投资者，引起东道国对于裁决的公正性的质疑。目前ICSID设立了裁决废除委员会，但没有设立被撤销后的措施；NAFTA为指fan争端解决机构对协定的解释出现偏差或错误授权协定下的权利机构公平贸易委员会对协定做引导性解释，对于这种解释争端解决机构必须服从，问题是1这种一致性意见很难获得2ICSID质疑其是否具有这种变相修改贸易协定的权力；3没有对仲裁庭不遵守解释性生命的行为如何补救。\n法庭之友 #  (6)Friend of the Court,源于拉丁文Amicus Curiae Brief,即对案件实质问题有重大利害关系的非诉讼当事方主动申请或应法庭要求向法庭提交书面意见的人。目前法庭之友的参与参在两种模式：一类是ICSID模式，详细列举仲裁庭在接受法庭之友文件时应靠考虑要素；另一类则是美国的简单规定模式，赋予仲裁庭比较大的裁量权，值得注意的是，UNCITRAL在法庭之友的规定上比较特殊，考虑到了非争端缔约方的参与可能会引发外交保护等政治风险，因此，将它与其他第三人区分开来，分别予以规制。（？）\n在法庭之友的规定上，美式BIT范本没有做太多限制，赋予仲裁庭较大的自由裁量权，其实是希望民间力量的接入保护其作为东道国的公共利益，美国非政府组织参加公共事务，表达诉求的机制已经较为成熟，而且美国国内的法庭之友制度也相对完善，一旦美国政府成为被告，法庭之友会踊跃参与，为美国谋求公共利益，这样的条文会促进保护美国作为东道国的利益而又不会将其投资者至于被动的位置。非争端当事方的参与者多为非政府组织，这些组织多来源于发达国家，难免与各投资者有千丝万缕的联系，从而可能共同向发展中国家发难（引用）\n欧加自贸协定和欧新自贸协定规定do仲裁庭“可以”在特定情形下接受第三方的法庭之友的意见，而《协定》投资章节草案第3节第23条则在接受法庭之友意见的同时，允许任何能够证明其与案件结果有直接现实利益的自然人或法人作为第三方接入程序dao当中，得到所有争议双方接收的程序性文件，在规定时间内提交书面陈述并在听证会中进行口头陈述。哟与第三方的参与只能是全部或部分地支持某一争端放的主张，而不能提出自己的主张，故第三方不具有独立的请求权。\n合并仲裁制度 #  合并仲裁是商事仲裁中常用的程序，其在国际投资仲裁中也应有用武之地。1合并仲裁制度已有立法依据，在NAFTA中，以及美国加拿大、墨西哥缔结的自由贸易协定中几乎都对合并仲裁做了规定。2合并仲裁制度已经有了实践经验，尤其是阿根廷经济危机发生后，投资者提起了众多针对阿根廷的投资仲裁请求，ICSID在受理仲裁请求时，将多起仲裁案件合并审理，取得了很好的成效，能够提高办案效率。\n第三方资助（略讲） #  第三方资助（third party funding）一般是指由与案件争议没有利益关系的第三方对一方当事人参加诉讼或仲裁提供资助的安排，实际上就是负担仲裁费用以及其他相关费用。第三方资助现象是国际仲裁领域近年来的重要新发展，虽然绝大多数第三方资助都在幕后进行，目前不可能有关于投资仲裁案件当事人受到第三方资助的统计数据，但是在一些发达国家如澳大利亚、德国等，第三方资助已形成产业。（引用待补5）\n日益增多 #   多个案件向我们展示了第三方资助在国际投资仲裁中占到了相应比例（第一个责令申请人缴纳仲裁费用担保的命令、第一个要求当事人披露第三方资助在isds中运用及其实践的具体清康） 国际上存在完全以第三方资助为业的相关公司（Burford投资回报率达到70%） 隐蔽性（不披露甚至签订保密条款）、产业化专业化、投资对象一般仅限于投资者  积极影响：接近司法access to justice #   提供资助：帮助陷入财务困境的投资者也能进行费用高昂的isds，拓宽权利救济途径 盈利行为：促使其会做相应请求的禁止掉擦汗，增加胜诉可能性 但具有立场，出发点仅在投资者的片面利益上。  消极影响：商业行为 #   增加无理的不充分的诉讼请求 存在利益关联影响公正性 其追求高额的赔偿而不像投资者单纯为了解决争议，而非更倾向于金钱  规制困境 #  有人甚至认为：国际投资仲裁中第三方资助事实上游离在无人监管的”法律真空地带“\n 对第三方资助的规制缺乏法律基础：视为国际合同，第三方可以选择更有利的法律并仲裁地免受规制 仲裁庭权力不够、动力不足 规制在实践中难以保证实施  对于弊端的作用 #   正当性和透明性：东道国基于本国的公共利益而采取的”合法行为“要被外国投资者诉诸仲裁，并通过私密的三个人决定支付巨额赔偿，针对东道国和东道国民众来说，显得非常不公平（奇怪，派员参加为何还是不公平）；缺乏正当性和透明性为第三方资助提供了空间：仲裁费用的负担往往是取决于仲裁员的自由裁量权的，而仲裁员更主张倾向投资者，并且无论如何东道国都是需要支付法律费用的。第三方资助加剧正当性和透明度缺失：从第三方资助本身而言，其就是针对投资者的，东道国本身即使胜诉也仅是无需赔偿，仍旧需要支付仲裁费用，因而其不可能在此种情况下还愿意向第三方在支付；其具有营利目的；其本身是私密的。 缺乏判决一致性：存在同案不同判的可能，第三方更敢于资助可能滥诉的行为；第三方资助会加剧不一致。 裁决的矫正机制缺失：能够使第三方更快地收回成本和营利，第三方因此也会积极地捍卫现在的制度。 第三方资助机构已经和国际仲裁员群体建立了千丝万缕的联系，第三方资助在这一点上对及gu投资仲裁制度的伤害最大，其会直接对被资助人委托什么律师、制定什么仲裁员进行干预。 高昂的时间成本和经济成本：刺激了第三方资助实践的产生和发展，对于经济上陷入困境的投资者来说，国际投资仲裁不仅花费高，耗费的时间成本也大，由此对于第三方资助的需求扩张；另外，由于第三方能够从中获利，其必然尽可能仲裁请求的金额，而仲裁请求的金额越大，自然仲裁费用越高。（5）  仲裁员 #  仲裁员由正义双方逐案挑选，且仅是投资者这一方有权提起诉讼。\n"},{"id":18,"href":"/docs/example/table-of-contents/","title":"Table of Contents","section":"Example Site","content":"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":19,"href":"/docs/algorithm/lru/","title":"Lru","section":"算法","content":"LRU #   要用哈希表 + 双向链表 哈希表：快速查找节点 双向链表  队头：最近访问的，或新加入的 队尾：最久未被访问    题目要求两个方法：\n get（）  如果不存在，返回-1 如果存在：  通过key找哈希表，得到节点 moveToHead 将该节点移到队头 返回节点的值     put（）  cache.count(key)不存在的话  new新链表节点 加到哈希表 addToHead 添加到头部 size++判断是否超出容量，如果超出：  removeTail 删除尾部 删除哈希表cache.erase size\u0026ndash; delete链表节点     否则就是已经存在：  cache[key] 拿到节点 更新node-\u0026gt;value为新的值 moveToHead 将该节点移到队头      主要方法：\n 查找由哈希表负责 插入：要插哈希表，要插链表头,size++ 删除：要删哈希表，要删链表尾，size\u0026ndash; 变更：链表先删再插  注意:\n 用双向链表，且带伪头节点和伪尾节点 每次要注意是不是要同时操作链表和哈希表  "},{"id":20,"href":"/docs/algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/","title":"位运算技巧","section":"算法","content":"位运算技巧 #  1、转换操作 #   转小写  (\u0026#39;a\u0026#39; | \u0026#39; \u0026#39;) = \u0026#39;a\u0026#39; (\u0026#39;A\u0026#39; | \u0026#39; \u0026#39;) = \u0026#39;a\u0026#39; 转大写  (\u0026#39;b\u0026#39; \u0026amp; \u0026#39;_\u0026#39;) = \u0026#39;B\u0026#39; (\u0026#39;B\u0026#39; \u0026amp; \u0026#39;_\u0026#39;) = \u0026#39;B\u0026#39; 互换  (\u0026#39;d\u0026#39; ^ \u0026#39; \u0026#39;) = \u0026#39;D\u0026#39; (\u0026#39;D\u0026#39; ^ \u0026#39; \u0026#39;) = \u0026#39;d\u0026#39; 2、正负号一样？ #  int x = -1, y = 2; bool f = ((x ^ y) \u0026lt; 0); // true int x = 3, y = 2; bool f = ((x ^ y) \u0026lt; 0); // false 3、n\u0026amp;(n-1) 的应用 #  用于消除n的二进制表示中的最后一个1。\n 位1的个数  while(n!=0){ n=n\u0026amp;(n-1); res++;} 判断一个数是不是 2 的指数  return(n\u0026amp;(n-1))==0; "},{"id":21,"href":"/docs/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","section":"算法","content":"动态规划 #   确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组  509. 斐波那契数 #  题目地址：https://leetcode-cn.com/problems/fibonacci-number/\n解法1：递归\n解法2：动态规划，一维数组\n解法3：动态规划，状态压缩缩\n70. 爬楼梯 #  题目地址：https://leetcode-cn.com/problems/climbing-stairs/\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n746. 使用最小花费爬楼梯 #  题目链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/\n数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。\n每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。\n请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。\n62.不同路径 #  题目链接：https://leetcode-cn.com/problems/unique-paths/\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\n63. 不同路径 II #  题目链接：https://leetcode-cn.com/problems/unique-paths-ii/\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n 条件：遇到障碍dp[i][j]保持0就可以了。  343. 整数拆分 #  题目链接：https://leetcode-cn.com/problems/integer-break/\n给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。\n dp[i]: 分拆数字i，可以得到的最大乘积为dp[i]。 dp[i] = max(j * (i-j), j * dp[i-j])  494. 目标和 #  题目链接：https://leetcode-cn.com/problems/target-sum/\n给定一个非负整数数组，a1, a2, \u0026hellip;, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n474.一和零 #  题目链接：https://leetcode-cn.com/problems/ones-and-zeroes/\n给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\n96.不同的二叉搜索树 #  题目链接：https://leetcode-cn.com/problems/unique-binary-search-trees/\n给定一个整数 n，求以 1 \u0026hellip; n 为节点组成的二叉搜索树有多少种？\n  解法一：递归\n 递归函数参数：是一个区间[1,n] 以 i 为根节点的数量 = [lo, i -1]的数量 * [i+1, hi]的数量 结束条件：为空！没有元素    解法二：动态规划\n dp[i]: 给定i,能组成的不同二叉搜索树的个数 涉及到累加：需要 j 循环 dp[i] = 以 j 为头节点，左子树的数量（即dp[j-1]) * 以 j 为头节点，右子树的数量（即dp[i - j])， 即：dp[i] += dp[j-1] * dp[i - j] dp[0] = 1的含义：没有元素的时候，也是一种    重叠子问题、最优子结构（子问题互相独立）、状态转移方程\n 明确「状态」 定义 dp 数组/函数的含义 明确「选择」 明确 base case。    最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。\n动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，不断以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。\n找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的朋友应该能体会。\n  遍历的过程中，所需的状态必须是已经计算出来的。看 base case\n  遍历的终点必须是存储结果的那个位置\n  子序列问题 #   一维dp数组  最长递增子序列  dp[i]: 以nums[i]为结尾的最长递增子序列的长度 算出所有dp[i]后，再选最大的就好了。即两次选择 有时间看nlgn的解法 二维递增子序列：信封嵌套问题 - labuladong的算法小抄 (gitbook.io)   最大子序和：具有最大和的连续子数组  dp数组：dp[i] = 以nums[i]为结尾的最大子数组和/最长递增子序列 将dp[i+1]与dp[i]建立联系     二维 dp 数组  涉及两个字符串/数组  最长公共子序列  dp函数：dp(s1, i, s2, j)计算s1[i..]和s2[j..]的最长公共子序列长度 base case: i == s1.length() || j == s2.length() 空串 0 如果相等/不等几种情况 备忘录 变1：给定字符串s1和s2，使它们相同所需最小步数 - m - lcs + n - lcs 变2：给定字符串s1和s2，使它们相同所需删除字符ascii值最小和  修改base case 修改状态转移部分     编辑距离  dp函数：返回子的最小编辑距离 base case: i走完或者j走完，直接返回另一个剩下的长度 如果相等，左上角。否则，三选1，三个角   最小路径和  dp[i][j] 取决于 dp[i-1][j] dp[i][j-1]     只涉及一个字符串/数组  最长回文子序列的长度  分析要求的结果，想：怎么从已知的结果推出来 dp数组定义：在子串s[i..j]中，最长回文子序列的长度为dp[i][j] 得出状态转移 分析base case 画出dp表，确认遍历方向写for循环        背包问题 #  0-1背包问题 #   dp[i][j] : 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少 dp[i] = 不放物品i（dp[i - 1][j]） + 放物品i （dp[i - 1][j - weight[i]]）。即：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 初始化：dp[0][j] = 0； j \u0026lt; weight[0]时，dp[0][j] = 0，else value[0]  一维滚动数组解法：\nvector\u0026lt;int\u0026gt; dp(bagWeight + 1, 0);// 初始化 for(int i = 0; i \u0026lt; weight.size(); i++) { // 遍历物品  for(int j = bagWeight; j \u0026gt;= weight[i]; j--) { // 遍历背包容量  dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);  } } 1049. 最后一块石头的重量 II #  题目链接：https://leetcode-cn.com/problems/last-stone-weight-ii/\n题目难度：中等\n有一堆石头，每块石头的重量都是正整数。\n每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u0026lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。\n 返回值处理：在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的  子集背包问题 #   dp[i][j] : 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，为true则刚好装满 dp[i] = 不放物品i（dp[i - 1][j] else 放物品i （dp[i - 1][j - weight[i]]）。即：dp[i][j] = if dp[i - 1][j] else dp[i - 1][j - weight[i]] + value[i]) 初始化：dp[\u0026hellip;][0] = false，dp[0][..] = true. ？  完全背包问题 #   dp数组定义：使用前i种物品，当前背包容量为j，有dp[i][j]种方法可以装满  要求的 dp[N][amount] base case: dp[0][..] = 0. dp[\u0026hellip;][0] = 1   状态转移逻辑（索引i-1表示第i个物品）  不装：dp[i][j] = dp[i-1][j] 装：dp[i][j] = dp[i][j-coins[i-1]]    518. 零钱兑换 II #  链接：https://leetcode-cn.com/problems/coin-change-2/\n难度：中等\n给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。\n  dp[j]：凑成总金额j的组合数为dp[j]\n  dp[j] += dp[j - coins[i]];\n  初始化：dp[0] = 1\n  贪心算法 #  暴力：指数级\n动态规划：多项式\n贪心：线性\n 最多有多少个无重叠区间  有空看下动归的解法 状态压缩技巧   本质就是投影 - 用于base case 直接去掉i维，然后分析对应原来的哪一个。分析外层/内层for循环。本质也是投影  "},{"id":22,"href":"/docs/algorithm/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","section":"算法","content":"双指针 #  1、数组 #  27. 移除元素 #  给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n  删除数组里的元素，只能覆盖！\n  fast: 遇到对应元素就略过；遇到最终留下来的，赋值给slow.\n  slow: 这个坑是填最终要留下来的数的\n  26. 删除有序数组中的重复项 #  给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。\n fast与slow. 记得更新 val.  283. 移动零 #  给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n fast：遇到0就略过；不是0就往前填 swap slow  977. 有序数组的平方给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 #    平方的最大值就在数组的两端，不是最左边就是最右边。\n  双指针法，i指向起始位置，j指向终止位置。\n  15. 三数之和 #  给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。\n 排序 三个指针指向三个位置：从左到右（for循环）、left、right（while循环） 循环内：  条件判断（return） i 去重,注意[-1, -1, 2] left和right的去重,注意[0,0,0]    18. 四数之和 #   不要判断 nums[k] \u0026gt; target 就返回了，如[-5, -4, -3, -1] -11  2、字符串 #  344. 反转字符串 #  编写一个函数，其作用是将输入的字符串反转过来。\n left 和 right，移动，交换  844. 比较含退格的字符串 #  给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。注意：如果对空文本输入退格字符，文本继续为空。\n  退格影响的是#前面的那个字符！所以要从后往前遍历！\n  两个字符串的指针指到的位置，一定是合法的字符\n  skipS和skipT的设置，这样指针才知道要删掉几个字符，该在哪里停下来。\n  判断：要注意下标越界\n  一定要先判断\u0026gt;=0，才去比较s[i]和t[j]\n  指针指的位置一定是合法的，不是#，所以如果i和j有一个\u0026lt;0，一个不是，那一定不相等。\n    剑指 Offer 05. 替换空格 #  请实现一个函数，把字符串 s 中的每个空格替换成\u0026quot;%20\u0026quot;。\n  先扩容数组resize：原size + 2*空格数量\n  从后往前：很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。\n  151. 翻转字符串里的单词给定一个字符串，逐个翻转字符串中的每个单词。 #   移除多余的空格：即移除指定重复项。  删除最前面的 = 把 fast指针移动到第一个非空格字符（因为后面会把 fast 的赋给 slow 的坑） 双指针 删除最后面的空格：slow 最后指向的有可能是：最后一个空格，或者合法字符。   将整个字符串反转 + 将每个单词反转：用同一个reverse(left, right)函数  3、链表 #  206. 反转链表 #  反转一个单链表。\n 解法一：递归 解法二：三指针  24. 两两交换链表中的节点 #  给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n 设dummy节点，模拟交换  新建虚拟头节点 模拟交换过程 while循环条件：确保虚拟头节点（即前缀节点)+两个节点都不是空的 执行交换过程，不断设置和移动cur 返回值：dummy节点是不变的，返回其next就好    19. 删除链表的倒数第 N 个结点 #  给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n 注意是先走n步，因为最终需要让slow走到要删除节点的前一个节点  02.07. 链表相交 #  给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。\n 如果相交了，则后面的节点必然都是相同的，所以：  先求出A的长度，再求出B的长度 让长的先走，走到剩下和短的一样  小技巧：通过交换，让A变为长的   不断往后移，直到找到相等的。    142. 环形链表 II #   判断链表是否有环？  快慢指针一定会相遇，相遇的点就是在环内。因为相当于fast指针在追赶slow，且每次追赶1步。   找到入口点？  设x,y,z，fast走的路 = 2 * slow走的路，推导得出x和z的关系，来一遍同步指针不同点出发。    "},{"id":23,"href":"/docs/algorithm/%E6%8E%92%E5%BA%8F/","title":"排序","section":"算法","content":"排序算法 #  快速排序 #  1、快速排序的基本过程？ #   用分治的思想。 选一个基准元素。把比这个元素小的放左边，大的放右边。这时候基准元素所处的即为最终的位置。 递归对左右两边都采取一样的方法，直到没有元素或只有一个元素。  void quickSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, intleft, intright) {  if (left \u0026gt;= right) {  return;  }  int index = partition(nums, left, right);  quickSort(nums, left, index - 1);  quickSort(nums, index + 1, right); } void quickSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  quickSort(nums, 0, nums.size() - 1); } 2、分割的过程是什么样的？ #   假设 pivot 作为基准元素。 从数组的右端向左扫描找到第一个小于它的元素。 再从数组的左端向右扫描直到找到第一个大于它的元素。 交换这两个元素。  不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，把基准元素和相遇的这个位置交换。\nint partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, intleft, intright) {  int pivotIndex = left;  int pivot = nums[left];  while (left \u0026lt; right) {  while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026gt;= pivot) {  right--;  }  while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026lt;= pivot) {  left++;  }  if (left \u0026gt;= right) {  break;  }  swap(nums, left, right);  }  swap(nums, pivotIndex, left);  return left; } 3、快排的复杂度是多少？ #   平均复杂度：O(NlgN) 最坏复杂度：O(N方)  即每次分割时，O(N)，要分割N次   好处：不需要辅助空间，原地排序。  4、有改进的方法吗？ #   切换到插入排序 三数取中 三向切分  5、怎么找出数组第 K 个元素 #  partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 k 个元素。\nint selectK(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) {   int left = 0, right = nums.size() - 1;  while (left \u0026lt;= right) {  int index = partition(nums, left, right);  if (k == index) {  return nums[k];  } elseif (k \u0026lt; index) {  right = index - 1;  }  elseif (k \u0026gt; index) {  left = index + 1;  }  }  return nums[k]; } 冒泡排序 #  1. 基本算法 #  从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。\nvoid bubbleSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int n = nums.size();  bool isSorted = false;  for (int i = 0; i \u0026lt; n \u0026amp;\u0026amp; !isSorted; i++) {  isSorted = true;  for (int j = 0; j \u0026lt; n - i -1; j++) {  if (nums[j] \u0026gt; nums[j + 1]) {  isSorted = false;  swap(nums, j, j + 1);  }  }  } } 2. 算法改进 #  在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。\n3. 性能分析 #  平均和最坏都是 O(n^2)\n稳定排序。\nO(n2) #    冒泡排序\n  选择排序 - 不稳！\n 两层for循环每次选最小    插入排序\n  O(n*log2n) #    快排\n  堆排 - 不稳！\n  归并排序\n 第一步：创建一个额外大集合用于存储归并结果，长度则为那两个小集合的和， 第二步：我们从左自右比较两个指针指向的值，将较小的那个存入大集合中，存入之后指针移动，并继续比较，直到某一小集合的元素全部都存到大集合中  第三步：当某一小集合元素全部放入大集合中，则需将另一小集合中剩余的所有元素存到大集合中。      希尔排序 - 不稳！\n 希尔增量分组，组内排序    计数排序：O(n+m) - O(n+m)\n桶排序：O(n) - O(m)\n基数排序：O(k*n)\n"},{"id":24,"href":"/docs/cs/open-source/%E6%9D%82%E8%B0%88/%E5%BC%80%E6%BA%90%E5%A4%A7%E5%AE%B6%E8%B0%88/","title":"开源大家谈","section":"杂谈","content":"开源大家谈 #   近十年To B的国内外公司采用开源Core+SaaS，开源好处：最高效的开发模式；获客，得到更多的用户，测试和反馈，最重要的客户需求，用户的用法，会超出想象；基础设施必须开源。   开源文档很重要，发展开源社区，把Credit给别人。 得到高手帮助，提高自己能力，不要想得太难。代码开源，有生命力，更长的生命周期；把东西做好，回报自然来，平常心享受过程，很好的经历，未来还有商业机会。  "},{"id":25,"href":"/docs/example/collapsed/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":"4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":26,"href":"/docs/example/collapsed/3rd-level/","title":"3rd Level","section":"Collapsed","content":"3rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":27,"href":"/docs/example/hidden/","title":"Hidden","section":"Example Site","content":"This page is hidden in menu #  Quondam non pater est dignior ille Eurotas #  Latent te facies #  Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona #  O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris #  Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":28,"href":"/docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":"Buttons #  Buttons are styled links that can lead to local page or external link.\nExample #  {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "},{"id":29,"href":"/docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":"Columns #  Columns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne...  \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt;  # Mid Content Lorem markdownum insigne...  \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt;  # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example #  Left Content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   "},{"id":30,"href":"/docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":"Details #  Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample #  {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title Markdown content #  Lorem markdownum insigne\u0026hellip;   "},{"id":31,"href":"/docs/shortcodes/expand/","title":"Expand","section":"Shortcodes","content":"Expand #  Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample #  Default #  {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Expand ↕  Markdown content #  Lorem markdownum insigne\u0026hellip;    With Custom Label #  {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Custom Label ...  Markdown content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.    "},{"id":32,"href":"/docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":"Hints #  Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example #  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  "},{"id":33,"href":"/docs/shortcodes/katex/","title":"Katex","section":"Shortcodes","content":"KaTeX #  KaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample #  {{\u0026lt; katex [display] [class=\u0026#34;text-center\u0026#34;] \u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt; /katex \u0026gt;}}     Display Mode Example #  Here is some inline example:  \\(\\pi(x)\\)  , rendered in the same line. And below is display example, having display: block  \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\]  Text continues here.\n"},{"id":34,"href":"/docs/shortcodes/mermaid/","title":"Mermaid","section":"Shortcodes","content":"Mermaid Chart #  MermaidJS is library for generating svg charts and diagrams from text.\nOverride Mermaid Initialization Config\nTo override the initialization config for Mermaid, create a mermaid.json file in your assets folder!\n Example #  {{\u0026lt; mermaid [class=\u0026#34;text-center\u0026#34;]\u0026gt;}} stateDiagram-v2  State1: The state with a note  note right of State1  Important information! You can write  notes.  end note  State1 --\u0026gt; State2  note left of State2 : This is the note to the left. {{\u0026lt; /mermaid \u0026gt;}}     "},{"id":35,"href":"/docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":"Section #  Section renders pages in section as definition list, using title and description.\nExample #  {{\u0026lt; section \u0026gt;}}   First Page  First page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.   Second Page  Second Page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.   "},{"id":36,"href":"/docs/shortcodes/section/first-page/","title":"First Page","section":"Section","content":"First page #  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":37,"href":"/docs/shortcodes/section/second-page/","title":"Second Page","section":"Section","content":"Second Page #  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":38,"href":"/docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":"Tabs #  Tabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example #  MacOS MacOS #  This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux Linux #  This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows Windows #  This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n "},{"id":39,"href":"/docs/other/%E4%B8%AD%E5%9B%BD%E6%94%BF%E5%BA%9C%E4%B8%8E%E7%BB%8F%E6%B5%8E%E5%8F%91%E5%B1%95%E5%85%B0%E5%B0%8F%E6%AC%A2/","title":"《中国政府与经济发展》","section":"非法类","content":"兰小欢《中国政府与经济发展》读书笔记 #  上篇：微观机制 #  一、地方政府的权利与事务 #   社科理论，刻意追求标新立异无意义；社会现象非常复杂，单一理论只能启示某个侧面，从不同理论中看到共同之处，方能融会贯通。实事求是了解现状、依托现实提炼理论，避免用理论歪曲事实。 实事求是。    不能脱离政府谈经济。\n  决定了要干哪些事，才能决定要用什么资源。因此事权是理解政府间资源分配的基础。\n  事权划分的三种理论：\n 公共服务的规模经济与边界 信息复杂性 激励相容    1、公共服务的规模经济与边界 #  2、信息复杂性 #   上级拥有形式权威，下级因为有信息优势，因此拥有实际权威。如官与吏。 存在信息的获取问题，因此体制内的文山会海； 存在信息的扭曲和隐瞒，因此上级的监督和审计就有必要。但监督机制本身也受信息的制约。 信息复杂多变，模糊不清的地方太多，繁杂事权没有清楚的法律界定，所以体制内的实际权力和责任都高度个人化，体制内的规章制度也无法完全取代个人信任，因此上级在提拔下级时，除考虑工作能力之外，关键岗位上都要尽量安排信得过的人。 一件事该不该做？要做到什么程度？怎么样才算做好？做好了算谁的功劳？做砸了谁负责？所谓权利，就是在说不清楚的情况下由谁来拍板决策的问题。权利的自然集中就可能造成专权和腐败。  国家土地监察制度的驻地效应：\n城市化过程土地价值飙升，违法现象（越权批地、非法占用割地）层出不穷，且违法主体多是地方政府或相关机构，其下属的土地管理部门无力防范和惩处。06年建国家土地监察制度，设国家自然资源总督察，向地方派驻督察局，但只有9个，在驻地城市的震慑和查处效果比其他地方强。\n3、激励相容 #    如果一方想做的事，另一方既有意愿也有能力做好，就叫激励相容。\n  事分两类：\n 比较具体，规则和流程相对明确，成果比较容易衡量和评价 ———— 垂直管理 抽象和宽泛，只有大致目标，如经济增长和稳定就业，需要下级发挥主动性和创造性调动资源去达成 ———— 地方管理    与地方经济密不可分的，即使专业性较强的部门，也不能垂直管理。如工商局、环保局。\n  "},{"id":40,"href":"/docs/other/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E8%92%8B%E5%BB%B7%E9%BB%BB/","title":"《中国近代史》","section":"非法类","content":"蒋廷黻《中国近代史》读书笔记 #  一、剿夷与抚夷 #  4、民族丧失二十年的光阴 #   鸦片战争失败的根本理由：军器和军队是中古的军队、政府是中古的政府、人民、士大夫阶级是中古的人民。因此虽拼命抵抗，终归失败，是自然的、逃不脱 的。 鸦片战争的军事失败还不是民族致命伤，失败以后还不明了失败的理由，力图改革，才是民族的致命伤。 为何？  中国人的守旧性太重。 我国文化是士大夫阶级的生命线。一实行新政，文化摇动，就是饭碗的摇动。 士大夫阶级最缺乏独立的、大无畏的精神。    "},{"id":41,"href":"/docs/other/%E8%A7%A3%E8%AF%BB%E4%B8%AD%E5%9B%BD%E7%BB%8F%E6%B5%8E%E6%9E%97%E6%AF%85%E5%A4%AB/","title":"《解读中国经济》","section":"非法类","content":"林毅夫《解读中国经济》读书笔记 #  粗浅读之，即便对于传统的经济学理论没有甚至初级的了解，从零开始，也通过林老师的介绍，收获颇多。简单归纳，以求在知识图谱中扎上这么一段清晰而博大的中国经济知识。\n我将从《解读中国经济》得到的知识分为三类。一是有关中国经济的过去、现在和未来；二是新结构经济学是什么；三是新结构经济学理论将是什么。\n中国经济的过去、现在和未来 #  中国经济的过去、现在和未来是极具代表性的发展中国家的过去、现在和可能的未来。\n过去，中国经济带着和其他发展中经济体的共同共性，寻求可以逐渐发展和现代化的方法。几乎全部的发展中国家一开始选择的是追赶和超过发达国家，一切资源都集中在资本集中型和技术集中型，由政府统一调配。此项政策施行之后，经济发展缓慢，虽然现代化进程有所前进，但是GDP却没有很大的增长。\n经济危机频发后，发达国家主张新自由主义，即鼓吹政府退出干涉，由市场自由调节。于是，又几乎所有的发展中国家直接摒弃之前的政府调配政策，这样的后果是经济危机加剧而发展更加缓慢。 反倒是中国，采用政府调配与市场竞争并行，既有有为政府又有有为市场，反倒是这个开始被大家公认为“两不像”的政策取得了最后的胜利。\n新结构经济学是什么 #  循着这条历史路径，林老师向我们揭开了新结构经济学的序幕。\n新结构经济学，即研究结构的经济学，采用亚当斯密的“原因、本质”的研究方法，探究构成结构的原因与本质，由此构建适合各个国家自己的经济理论。\n新结构经济学的出发点是要素禀赋，由要素禀赋到比较优势，由比较优势决定了产业，以上均围绕最低要素生产成本，并辅之以合适的硬的基础设施和软的制度安排。\n要素禀赋，要素只主要以生产要素为主的一个国家的要素，禀赋指决策者在做决策时考虑的全部东西。决定一个国家发展的因素有很多，但起决定性因素的是要素禀赋，要素禀赋可以简单理解成当一个国家发展经济时，其能够依靠的好与不好的物质因素。\n比较优势，典型的即发展中国家对比发达国家，其特点就是劳动力资源充足，而资本及技术资源劣后，因此，发展中国家的核心优势即是劳动密集型产业。同时，通过从发达国家进口技术与资本，发展中国家能够利用极少的风险和成本，获得产业升级等。而发达国家要进行技术与资本的革新，需要承担极高的成本风险。\n产业，建立于要素禀赋之下。在发展中国家可以分为两类，一类是劳动密集型产业，劳动力成本廉价，会引得市场争相投入，商人有足够的动力，只需要考虑与经济发展方向适合的引导；一类是技术、资本密集型产业，发展国家在该种产业中劣后，动力不足，一旦离开政府的补贴扶持，很容易倾覆，而这一类产业通常是与民生相关的基础产业。\n深入要素禀赋，即是要建立符合各国家自己产业结构的经济发展政策，将各国不同的结构要素考虑在内，而不同于发达国家略去此类因素的二维经济学，是适应各国家的三维经济学。\n新结构经济学将是什么 #  在此基础上，深入对重要结构要素的具体探究，并以中国现在的经济政策作为例子，进一步构建宏观新结构经济理论。\n“这是一个需要理论而且一定能够产生理论的时代，这是一个需要思想而且一定能够产生思想的时代。我们不能辜负了这个时代。”\n经济理论的发展中心往往是世界经济中心，因为经济理论的发展需要素材，而今，发达国家缺的是素材，因为它们的经济已经趋向稳定，大多只是脚注性的研究，而中国经济学家有最新的素材。这是时代赋予我们的使命。\n"},{"id":42,"href":"/docs/other/%E9%87%8D%E8%AF%BB%E9%A9%AC%E5%85%8B%E6%80%9D%E9%9F%A9%E6%AF%93%E6%B5%B7/","title":"《重读马克思》","section":"非法类","content":"韩毓海《一篇读罢头飞雪，重读马克思》读书笔记 #  人间喜剧 #  “召唤亡灵的行动” #  《路易波拿巴的雾月十八日》讲述的两个问题：\n 法国政治体制的变迁：议会民主 -\u0026gt; 宪政制度（大工业资产阶级） -\u0026gt; 国家官僚制度（法国小农） -\u0026gt; 流氓无产者政治（金融资本家） 政治制度变迁背后的阶级关系和阶级斗争。   国家官僚制：小农不能为自己做主，就幻想着“青天大老爷”骑在自己头上为自己做主。小农的生活方式是自给自足，没有发展出自己的经济交换方式，因此也没有组织这种经济交换方式的政治制度形式，即“不是一个阶级”。 欧洲七次反法战争的实质：拿破仑（翻身农民军队）欲摧毁金融家集团对于欧洲的统治。 法兰西第二帝国：金融帝国、基于法国小农的小块土地抵押发行国债刺激经济。而后经济危机，发动战争。战败，内债 + 战争赔款。 巴黎公社诞生，无产阶级专政的历史条件：各阶级轮番登台，最后的阶级：劳动者阶级在连统治阶级自己也不愿统治下去时方才登上历史舞台。 市民社会里的个人为何不能联合起来？互相之间不了解，因为大家讲不同的语言。 如何联合联系起来？借来的语言：前人和死人的语言、名字、口号、服装和旗帜， 两个目的：  表达自己现实的诉求（人支配和创造自己的语言）。内容战胜辞藻、实质战胜形式、活人战胜死人 掩盖自己现实的诉求（用语言支配人）。    “流氓无产者”与国债 #   流氓无产者：金融骗子，扮演者社会信用代理人的角色。 资产阶级（金融资本家）如何利用金融手段进行统治：收债、放债，用法国的钱再来收买法国。 具体地：用钞票、彩票、股票收买社会的各个阶级，收买军队（打手），这些收买人心的钞票又全部转化为国债，使得法国所有国民成为负债者。 不断进行改革（自身每次都能在投机的改革中获利），甚至用政变稳定金融秩序。 1848年：第二次工业革命、同时金融阶级代替工业阶级成为社会的统治者。  小块农地的金融化 #   工厂原型：监狱，监狱原型：济贫所。 资本主义的刑罚：用劳动和饥饿惩罚穷人。 资本主义的劳动交换：用劳动交换货币，货币由资本家掌握，即资本统治劳动。 空想的社会主义：排斥大生产、资本和金融，交换劳动法则：劳动者直接交换他们的劳动和劳动产品，不需要雇主，需要合作社。 共产主义 = 联合起来的劳动 + 联合起来的生产：肯定大生产、协作、科技、金融把生产资料组织为资本的功能，土地和资本不应被极少数资本家垄断，而应被联合起来的劳动所用。 农民离不开货币，经济的金融化离不开小农和小块土地，如果略过大规模的产业经济和实体经济的发展，只能把小块土地变成金融产品，必然破产 \u0026ndash; 路易-拿破仑·波拿巴的教训。 路易-拿破仑·波拿巴式发展道路模型的本质：金融家的冒险精神 + 小农幻想症。  “现代社会靠无产阶级过活” #   美国的“中产阶级”：   20世纪80年代，美国经济金融化、去工业化、去产业化，大量产业劳动者阶级转化为中产阶级，靠的是房产和股票的升值。 保守，唯一担心自己的财产不要减少，反对一切社会改革与政治运动。彼此不信任，无法形成政治力量，因此需要一个金融大资产阶级来代表他们。 金融危机，重新沦为无产阶级。   资本主义社会不是从罗马社会发展出来的，是从罗马“边缘的边缘”罗得岛上“跳起来的”。\n  资本主义的形式：\n   资本主义不与小生产相联系，而与工业化的大生产和产业革命（即组织起来的劳动）相联系 ———— 这是革命之处。 劳动者、企业主互相预付的信用制度构成上层建筑， 根本弊端：少数人垄断，对劳动进行剥削。   没有无产阶级的斗争，资产阶级就一定会被流氓无产者镇压，现代产业经济就会在金融海啸中灰飞烟灭，现代社会就会走向野蛮。\n  现代产业的形成建立在无产阶级的“信用”的基础上，他们自发地把劳动转化为资本和信用，但却把它们交给资本家去发财，他们还只是“被动的联合”。\n  不能想着跨越肮脏、拥挤、充满阶级斗争和骚动的产业经济阶段，向着衣冠楚楚的服务业和金融业迈进，甚至退回到小生产的田园牧歌。\n  共产主义：消灭现存状况的现实的运动。\n  “从来就没有救世主，也不靠神仙皇帝，要创造人类的幸福，全靠我们自己”。\n  {{ hint info}} 国际悲歌歌一曲，狂飙为我从天落 {{ /hint }}\n"},{"id":43,"href":"/docs/cs/basic/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"C++内存管理","section":"计算机基础知识","content":"C++内存管理 #  1、new/delete 和 malloc/free 有什么区别？ #   new 的步骤分两步：调用 malloc 申请空间、调用构造函数。释放空间的时候一样。 new 不需要头文件， malloc 要 stdlib.h new 是类型安全的，比如 int *p = new float[2]就会报错；malloc 不是，编译时可以通过。  2、malloc和free的原理 #  2.1 进程的地址空间 #   3 - 4G 内核空间 0 - 3G 用户空间  栈（↓)：局部变量、函数参数、返回地址 内存映射段（↓）：动态库/匿名映射 堆（↑）： BSS段：未初始化/初始为0的.. 数据段：初始化的全局变量和局部静态变量 代码段：可执行二进制代码    2.2 进程控制块里的mm_struct #   start_brk：堆的起始地址 brk：终止地址 可以增大brk的值，但需要系统调用  2.3 malloc 实现方案 #  系统调用开销 + 内存碎片 =\u0026gt; 采用内存池。\n 将内存分成大小不同的 chunk, 通过 bins 组织起来 128 个bin，分为 small bins（每个chunk相同）、large bins（不同）、unsorted bin（相当于缓冲区 如果要的内存 \u0026lt;512 字节 =\u0026gt; small, 否则 large, 否则 unsorted_list 如果全都不够，\u0026lt; 128k =\u0026gt; brk 否则mmap  3、如果 new / malloc 返回空指针，怎么办？ #   new：会抛出异常，可以用 try\u0026hellip;catch malloc：要判断是否空指针，是的话就return终止  4、遇到过内存泄露吗？内存泄露了怎么办？ #  几种可能：\n 未成对出现，申请了没有释放的操作。比如在构造中申请，析构中没释放。 没有将基类的析构函数定义为虚函数。 没有定义拷贝构造函数 或者 没有重载赋值运算符，导致两次释放的相同的内存。类中包含指针变量。  工具：linux 下 valgrind、mtrace等工具。\n6、C++有哪几种内存分配方式？ #   在栈上：函数，局部变量 堆上：动态内存分配 new/malloc 全局/静态存储区 常量存储区  7、堆和栈的区别？动态分配内存和静态分配内存的区别 #   分配方式不同：动态，由程序员控制 VS 静态，编译器自动管理 碎片：有 VS 无 生长方向：从低-\u0026gt;高 VS 反过来  #33 8、浅拷贝和深拷贝的区别？\n 浅：只赋值指针，和原来的指向同一块内存 深：创建一个新的一样的对象。  9、结构体内存对齐了解吗？ #  结构体中会按size最大的成员对齐。\n智能指针 #  0、智能指针概念 #   用途是用于动态分配内存，防止内存泄露和空悬指针问题。 原理是将基本类型指针封装为类对象指针，离开作用域-\u0026gt;调用析构，delete  、都有哪些智能指针？ #   shared_ptr  多个智能指针可以共享同一个对象。 每个share_ptr都有一个关联的引用计数，一旦一个share_ptr的引用计数变为0，就会自动释放自己所管理的对象。 share_ptrp = make_shared(42);   unique_ptr  独享所有权，保证同一时间只有一个智能指针指向该对象。当unique_ptr被销毁时，指向的独享被释放。 不能直接拷贝或赋值。 unique_ptrp (new string(\u0026ldquo;unique\u0026rdquo;));   weak_ptr  可以绑定到share_ptr，指向由shared_ptr管理的对象，允许共享但不拥有。 解决share_ptr相互引用时，死锁。 在确定是否应该释放对象的时候，shared_ptr不把weak_ptr统计在内。    "},{"id":44,"href":"/docs/cs/basic/c++%E5%9F%BA%E7%A1%80/","title":"C++基础","section":"计算机基础知识","content":"C++ 基础 #  一、基本语法 #  1、指针和引用有什么区别？ #   指针有自己的空间，引用只是别名 sizeof(指针) = 4；sizeof(引用) = 对象的大小 指针可以指向其他对象，引用不行。  2、const 的作用是什么？ #  作用：（在 const 后面）的值不可改变。\n 变量； 指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 成员函数，说明该成员函数内不能修改成员变量。  3、const 和 volatile 一起修饰变量？ #  表示变量是不可改变的，并且编译器不会优化这个变量。\n4、static 的作用是什么？ #   普通变量：修改存储区域（静态区）、生命周期（main运行前分配空间），初始值 普通函数：作用范围。仅在定义该函数的文件内才能使用。多人开发场景，为了防止与他人命名空间里的函数重名，可以将函数定义为 static。 成员变量：不需要实例化对象就能访问。多个对象只一份 成员函数：同。但不能访问非静态成员  5、Lambda 表达式 #  sort(vec.begin(), vec.end(), [](int a, int b) -\u0026gt; bool { return a \u0026lt; b })\n 捕获外部变量（值，引用） 参数 [](int x, int y){ return x + y }(5,4) 输出9  5、了解过 inline 内联函数吗？ #  作用：= 宏 ，直接写进去，直接执行。\n优点：\n 和普通函数相比，不用参数压栈等动作，提高运行速度。 和宏函数相比，内联函数会做类型检查，且在运行时可调试，而宏定义不可以。  缺点：\n 内存换时间。如果执行函数体内代码的时间，远远大于函数调用的开销，那就没有意义。 决定权在编译器：不内联包含循环、递归、switch 等复杂操作的函数  编译器对 inline 函数的处理步骤：\n 将 inline 函数体复制到 inline 函数调用点处； 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；  5-2、虚函数可以是内联函数吗？ #   可以。编译器知道调用的对象是哪个类。 不可以。虚函数的多态性在运行期，编译器不知道在运行期调用哪个代码，即：虚函数表现多态性的时候不能内联。  二、面向对象 #  0、面向对象概念？ #   封装 继承 多态  1、封装的概念？ #  把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。类继承默认 private， struct默认public。\n public protected：本类 + 子类的成员函数 private：本类的成员函数、友元类或友元函数  2、多态的概念 #  多态，即多种状态（形态）。\n 静态多态：重载，编译期确定。（函数重载、运算符重载 动态多态：虚函数 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换  3、虚函数的概念？ #  1、概念 #  用 virtual 修饰的成员函数。当使用基类的引用或指针调用一个虚函数时将在运行期进行动态绑定。\n2、实现 #  通过虚函数指针和虚函数表：\n 每个对象，都有一个虚函数指针，指向一张虚函数表，虚函数表是针对类的，表中放了虚函数的地址。 子类继承父类时，会继承虚函数表，重写虚函数时，会替换掉函数地址。  虚函数表：所有对象共享这个类的虚函数表。表在程序只读数据段，实际函数在代码段。\n3、不能是虚函数 #  这些不能是虚函数：\n 构造函数：因为虚函数指针要在构造函数中初始化 静态 普通  4、虚析构函数 #  基类的指针指向派生类对象，并用基类的指针删除派生类对象。 如果不是的话，基类指针指向派生类对象，会调基类的析构函数。\n5、纯虚函数与抽象类 #   纯虚函数是一种特殊的虚函数，在基类中不能实现，只声名，必须被继承并实现。 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。  3、虚继承的概念？ #  1、概念 #  虚继承用于解决菱形继承问题（类D同时继承B和C，B和C又继承自A：浪费空间、存在二义性）。\n2、实现 #  通过虚基类指针和虚基类表：\n 每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）；虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员， 虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。当虚继承的子类被当做父类继承时，虚基类指针也会被继承。  5、sizeof(空类)的大小？ #  值为1。分配一个字节，可以使这个类的不同实例拥有独一无二的地址。\n6、覆盖和重载的区别 #   覆盖：和父类完全相同 重载：不同参数列表/返回值  7、拷贝构造函数和赋值运算符重载 #  当类中包含指针变量时：\n 拷贝构造函数：用于构造新的对象，Student s1 = s; Student s2(s) 赋值运算符重载：拷贝 s1 = s;  8、Struct 和 Class 的区别？ #   默认继承权限不同，class继承默认是private继承，而struct默认是public继承 class还可用于定义模板参数，像typename，但是关键字struct不能用于定义模板参数 C++保留struct关键字  9、强制类型转换 #   static_cast  场景：转换数值型数据类型（如 float -\u0026gt; int） 非多态类型的转换，不执行运行时类型检查   dynamic_cast  场景：指针或引用 多态类型的转换、执行行运行时类型检查 向上转换、向下转换   const_cast  场景：删除 const、volatile 特性（如将 const int 类型转换为 int 类型 ）   reinterpret_cast  函数调用过程 #  0、有哪三个寄存器？ #   eip: 指向下一条即将执行的指令 ebp: 指向栈底 esp：指向栈顶  1、参数压栈的顺序 #  从左←右\n（1，2，3）先压3！2，1，ESP指向12、保存现场\n保存现场：\n 将 eip 压栈， 将 ebp 压栈:  然后确定函数的区域：将现在的栈顶作为新的栈底，并往上移一点点\n还有将其他main函数的一些现场压栈保护起来。\n栈结构：\nesp -\u0026gt; 前 edi\n64字节隔离区 - 局部变量 x - 局部变量 y\nebp-\u0026gt; 前ebp值 - 前eip值 - 参数1 - 参数23、恢复现场\n 弹出edi、esi等 调整 esp 为 ebp 弹出前 ebp、eip  "},{"id":45,"href":"/docs/cs/basic/http/","title":"HTTP/HTTPS","section":"计算机基础知识","content":"HTTP/HTTPS #  一、状态码 #  1、有哪些常见的状态码？ #   1xx - 正在处理  100 - 正常 101 - 切换请求协议   2- 成功  200 - 请求成功 201 - 已创建 202 - 已接受 204 - 无内容   3- 重定向  301 - 永久性重定向 302 - 临时重定向   4- 服务端无法处理请求（客户端错误  400 - Bad Request 语法错误 401 - Unauthorized 403 - Forbidden 拒绝 404 - not found 405 - method not allowd 406 - Not Acceptable 408 - Request Time-out   5- 服务端处理请求出错（服务端错误  500 - Internal Server Error 内部错误 501 - Not Implemented 502 - Bad Gateway 服务器无效响无效响应 503 - 服务器过载，稍后重试 504 - Gateway Timeout 请求超时，nginx 配置不对    2、301和302的区别是什么？ #   301是页面或资源永久性地移到了另一个位置。应用场景：网站移到了新的地址 / 或多个域名跳转到同一个域名，有利于URL权重的集中。 302是暂时性转移，常被用作网址劫持，搜索引擎会抓新的内容，但保存旧的网址。  二、HTTP 报文 #    http请求报文\n 请求行：包括请求方法（GET\\POST等）、请求地址URL、协议版本（比如HTTP1.1） 请求头(Request Header) ：connection(比如keep-alive)、content-length长度、origin、user-agent、content-type(POST就有三种)、encoding、language、cookie 请求正文    http响应报文\n 状态行 : 包括状态码、协议版本 响应头： 响应正文    0、POST 请求体都有哪些形式？ #   application/x-www-form-urlencoded： 默认的，key1=val\u0026amp;key2=val2这种，和GET常见的，数据量不大。 multipart/form-data：上传文件 application/json：数据结构比较复杂时  1、HTTPS1、HTTP 和 HTTPS 的区别？ #   加密：http 请求是明文传输，容易被窃听或截取，https在http的基础上加了SSL加密层 证书：https需要ca证书 端口：80 VS 443  2、HTTPS的加密流程 #  3、HTTP 1.0、HTTP 1.1及HTTP 2.0的主要区别是什么 #   1.0 默认是短连接。 1.1 默认长连接，TCP默认不关闭，复用TCP连接 2.0 多路复用  1.1 和 2 都是基于 TCP ，而 HTTP/3 基于 UDP 。\n4、Cookie与Session #    概念\n cookie: 服务端发送给客户端的一串标识，浏览器下次发送请求时会一起带上发送给服务端。可以用于用户登录、设置等场景。 session：表示服务端和客户端一次会话的过程。    区别\n  实际用法 可以同时配合使用，通过 SessionID 。\n  token Token 也是服务端生成的一串标识字符串，比如当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，然后返回给客户端，客户端下次请求时带上这个 Token ，就可以验证身份。\n  分布式session\n 用Nginx做代理，确保同一个IP固定访问某台机器 Session 复制 Session 共享，缓存/中间件    7、在浏览器中输入url到显示主页的过程 #  DNS、TCP、HTTP、TCP\n DNS解析：  查浏览器的DNS缓存 查系统的缓存 读本地的Host文件   TCP三次握手 发起HTTP请求 响应HTTP报文 浏览器解析、渲染页面 四次挥手  "},{"id":46,"href":"/docs/cs/basic/stl/","title":"STL","section":"计算机基础知识","content":"STL #  零、STL总体 #  1、STL包含什么？ #   容器 迭代器：不暴露容器内部结构，对容器遍历。 算法：排序等常用算法。  2、常用的STL/容器？ #   顺序容器  array - 固定大小 vector - 动态数组 list - 双向链表 forward_list - 单向链表 deque - 双端队列   关联型  map、multimap、unordered_map、unordered_multimap set、multiset、unordered_set、unordered_multiset   容器适配器  stack - 栈 queue - 队列 priority_queue - 优先队列    3、容器内部怎么删除一个元素？ #   顺序型：it = erase(it) 返回下一个有效的it 关联型：erase(it++) 返回 void  一、vector #  1、底层原理是什么？ #  是一个动态数组，装不下的时候-\u0026gt;自动申请一片更大地空间，VS 下 1.5 倍或 GCC 下 2 倍，然后复制，释放，原来的迭代器失效。\n2、为什么是1.5倍或2倍扩容？ #   为什么是成倍增长，而不一个固定大的值？  复杂度：均摊后可以达到O(1) vs O(n) 内存的角度：1.5倍的方式可以更好地对内存进行重复利用。因为如果2倍，下一次申请内存会大于之前分配的内存之和，无法再重用。   为什么不是以 3 倍或者 4 倍增长呢？ - 可能产生堆空间浪费  3、size()和capacity()的区别 #   size: 有多少个元素 finish - start capacity: 可以容纳多少个元素 end_of_storage - start  4、扩容的两种方式reserve()和resize()的区别？ #   reserve  预留空间，没有创建元素对象， 只改变 capacity()， 比如不能用[]下标去访问。 只有1个参数。   resize  改变容器大小，有创建对象 改变 capacity()，也改变了size()，可以用[]访问。 多个参数。    5、迭代器失效的情况遇到过吗？ #   如果插入元素后，改变大小，引起内存重新分配，那就会全部失效 指向的那个元素被删除了，会返回下一个有效的 it = vec.erase(it)  6、怎么释放vector的内存？ #  方法1：\n vec.clear() - 先清空内容 size() 为 0 vec.shrink_to_fit(): 让 capacity 和 size 匹配，也就达到目的了。  方法2：直接vector().swap(foo)\n二、list #  1、list 的底层原理知道吗？ #  底层是一个双向链表，很方便插入和删除。\n三、deque #  1、deque 的底层原理知道吗？ #  底层是一个双端队列，方便在头部和尾部插入和删除。2、什么时候用 vector ? 什么时候用 list ? 什么时候用 deque ?\n vector：随机存取的场景。 list：插入删除频繁 deque：需要在头部和尾部操作的时候  四、map #  1、map 底层是什么？ #  底层是红黑树。\n2、map 插入方式有哪几种？ #   insert()插入 pair 数据：map.insert( pair\u0026lt;int, string\u0026gt;(1, \u0026ldquo;xxx\u0026rdquo;)) insert()使用make_pair()函数：map.insert( make_pair(1, \u0026ldquo;xxx\u0026rdquo;) ) insert()插入value_type数据：map.insert( map\u0026lt;int, string\u0026gt;::value_type(1, \u0026ldquo;xxx\u0026rdquo; )) 用类似数组的方式直接插入：map[1] = \u0026ldquo;xx\u0026rdquo;  3、count 和 find 方法有什么区别？ #  都可以用来判断一个key是否存在。\n count()\u0026gt;0 统计出现的次数，要么 0，要么1 find() != end() 表示 key 存在。  4、map 与 multimap #  允不允许重复。\n5、map 与 set 区别是什么？ #  set相当于只有 key 没有 value，因为它的value就是key。6、map与unordered_map的区别是什么？怎么选？\n 查找速度：lgN与O(1)的区别，特别是大数量的情况下。 内存：若要尽量少用内存，用map。 hash_map需要考虑hash函数的消耗。  五、unordered_map #  1、底层原理是什么？ #  是一个哈希表。\n  用开链法解决hash冲突。\n  在设计bucket 数组长度的时候，内置了28个质数，创建时，选择大于等于元素个数的质数，所谓长度（或者说容量）。如果插入的个数超了，就找下一个质数，并重新计算hash值。\n  概念\n  用法\n 把所有元素变为0：直接clear()，下次[]访问的时候自动默认为0。 参考：C++ STL unordered_map容器用法详解 (biancheng.net)    六、迭代器 #  1、迭代器的底层原理 #   萃取技术 模板piantehua  2、迭代器失效的情形 #   插入时 - vector重新分配内存空间 删除时  "},{"id":47,"href":"/docs/law/system/%E4%BB%A5%E5%85%AC%E5%8F%B8%E6%8B%85%E4%BF%9D%E4%B8%BA%E4%BE%8B/","title":"以公司担保为例","section":"系统","content":"以公司担保为例 #  法律规范 #  2021公司法草案 #  【有限责任公司】 第七十一条 有限责任公司向其他企业投资或者为他人提供担保，按照公司章程的规定，由董事会或者股东会决议；公司章程对投资或者担保的总额及单项投资或者担保的数额有限额规定的，不得超过规定的限额。\n公司为公司股东或者实际控制人提供担保的，必须经股东会决议。\n前款规定的股东或者受前款规定的实际控制人支配的股东，不得参加前款规定事项的表决。该项表决由出席会议的其他股东所持表决权的过半数通过。\n【股份有限公司】 第一百二十三条 本法第七十一条关于有限责任公司向其他企业投资、为他人提供担保的规定，第七十二条至第七十五条关于有限责任公司股东会决议无效、可撤销、不成立的规定，适用于股份有限公司。\n【上市公司】 第一百三十九条 上市公司在一年内购买、出售重大资产或者向他人提供担保的金额超过公司资产总额百分之三十的，应当由股东会作出决议，并经出席会议的股东所持表决权的三分之二以上通过。\n第一百七十四条 公司及其子公司不得为他人取得本公司的股份提供赠与、贷款、担保以及其他财务资助。公司实施员工持股计划或者金融机构开展正常经营业务的除外。\n【决议】 第七十二条公司股东会、董事会的决议内容违反法律、行政法规的无效。\n第七十三条股东会、董事会会议的召集程序、表决方式违反法律、行政法规或者公司章程，或者决议内容违反公司章程的，股东、董事、监事自决议作出之日起六十日内，未被通知参加股东会、董事会会议的股东、董事自知道或者应当知道股东会、董事会决议作出之日起六十日内，可以请求人民法院撤销；但是，股东会、董事会会议的召集程序或者表决方式仅有轻微瑕疵，对决议未产生实质影响的除外。股东、董事、监事依照前款规定提起诉讼，公司能够证明该股东、董事、监事有不正当目的的，人民法院可以应公司的请求，要求其提供相应担保。\n第七十四条有下列情形之一的，股东会、董事会的决议不成立：（一）未召开股东会、董事会会议作出决议；（二）股东会、董事会会议未对决议事项进行表决；（三）出席会议的人数或者所持表决权数未达到本法或者公司章程规定的人数或者所持表决权数；（四）同意决议事项的人数或者所持表决权数未达到本法或者公司章程规定的人数或者所持表决权数。\n第七十五条股东会、董事会决议被人民法院宣告无效、撤销或者确认不成立的，公司应当向公司登记机关申请撤销根据该决议已办理的变更登记。股东会、董事会决议被人民法院宣告无效、撤销或者确认不成立的，公司根据该决议与善意相对人形成的民事法律关系不受影响。\n合同效力 #  民法典 #  第五百零四条 法人的法定代表人或者非法人组织的负责人超越权限订立的合同，除相对人知道或者应当知道其超越权限外，该代表行为有效，订立的合同对法人或者非法人组织发生效力。\n第五百零五条 当事人超越经营范围订立的合同的效力，应当依照本法第一编第六章第三节和本编的有关规定确定，不得仅以超越经营范围确认合同无效。\n18公司法 #  第十六条 公司向其他企业投资或者为他人提供担保，依照公司章程的规定，由董事会或者股东会、股东大会决议；公司章程对投资或者担保的总额及单项投资或者担保的数额有限额规定的，不得超过规定的限额。\n公司为公司股东或者实际控制人提供担保的，必须经股东会或者股东大会决议。\n前款规定的股东或者受前款规定的实际控制人支配的股东，不得参加前款规定事项的表决。该项表决由出席会议的其他股东所持表决权的过半数通过。\n2019九民纪要 #  （六）关于公司为他人提供担保 关于公司为他人提供担保的合同效力问题，审判实践中裁判尺度不统一，严重影响了司法公信力，有必要予以规范。对此，应当把握以下几点： 17.【违反《公司法》第16条构成越权代表】为防止法定代表人随意代表公司为他人提供担保给公司造成损失，损害中小股东利益，《公司法》第16条对法定代表人的代表权进行了限制。根据该条规定，担保行为不是法定代表人所能单独决定的事项，而必须以公司股东（大）会、董事会等公司机关的决议作为授权的基础和来源。法定代表人未经授权擅自为他人提供担保的，构成越权代表，人民法院应当根据《合同法》第50条关于法定代表人越权代表的规定，区分订立合同时债权人是否善意分别认定合同效力：债权人善意的，合同有效；反之，合同无效。 18.【善意的认定】前条所称的善意，是指债权人不知道或者不应当知道法定代表人超越权限订立担保合同。《公司法》第16条对关联担保和非关联担保的决议机关作出了区别规定，相应地，在善意的判断标准上也应当有所区别。一种情形是，为公司股东或者实际控制人提供关联担保，《公司法》第16条明确规定必须由股东（大）会决议，未经股东（大）会决议，构成越权代表。在此情况下，债权人主张担保合同有效，应当提供证据证明其在订立合同时对股东（大）会决议进行了审查，决议的表决程序符合《公司法》第16条的规定，即在排除被担保股东表决权的情况下，该项表决由出席会议的其他股东所持表决权的过半数通过，签字人员也符合公司章程的规定。另一种情形是，公司为公司股东或者实际控制人以外的人提供非关联担保，根据《公司法》第16条的规定，此时由公司章程规定是由董事会决议还是股东（大）会决议。无论章程是否对决议机关作出规定，也无论章程规定决议机关为董事会还是股东（大）会，根据《民法总则》第61条第3款关于“法人章程或者法人权力机构对法定代表人代表权的限制，不得对抗善意相对人”的规定，只要债权人能够证明其在订立担保合同时对董事会决议或者股东（大）会决议进行了审查，同意决议的人数及签字人员符合公司章程的规定，就应当认定其构成善意，但公司能够证明债权人明知公司章程对决议机关有明确规定的除外。债权人对公司机关决议内容的审查一般限于形式审查，只要求尽到必要的注意义务即可，标准不宜太过严苛。公司以机关决议系法定代表人伪造或者变造、决议程序违法、签章（名）不实、担保金额超过法定限额等事由抗辩债权人非善意的，人民法院一般不予支持。但是，公司有证据证明债权人明知决议系伪造或者变造的除外。 19.【无须机关决议的例外情况】存在下列情形的，即便债权人知道或者应当知道没有公司机关决议，也应当认定担保合同符合公司的真实意思表示，合同有效：（1）公司是以为他人提供担保为主营业务的担保公司，或者是开展保函业务的银行或者非银行金融机构；（2）公司为其直接或者间接控制的公司开展经营活动向债权人提供担保；（3）公司与主债务人之间存在相互担保等商业合作关系；（4）担保合同系由单独或者共同持有公司三分之二以上有表决权的股东签字同意。 20.【越权担保的民事责任】依据前述3条规定，担保合同有效，债权人请求公司承担担保责任的，人民法院依法予以支持；担保合同无效，债权人请求公司承担担保责任的，人民法院不予支持，但可以按照担保法及有关司法解释关于担保无效的规定处理。公司举证证明债权人明知法定代表人超越权限或者机关决议系伪造或者变造，债权人请求公司承担合同无效后的民事责任的，人民法院不予支持。 21.【权利救济】法定代表人的越权担保行为给公司造成损失，公司请求法定代表人承担赔偿责任的，人民法院依法予以支持。公司没有提起诉讼，股东依据《公司法》第151条的规定请求法定代表人承担赔偿责任的，人民法院依法予以支持。 22.【上市公司为他人提供担保】债权人根据上市公司公开披露的关于担保事项已经董事会或者股东大会决议通过的信息订立的担保合同，人民法院应当认定有效。 23.【债务加入准用担保规则】该约定的效力问题，参照本纪要关于公司为他人提供担保的有关规则处理。\n2020最高人民法院关于适用《中华人民共和国民法典》有关担保制度的解释 #  第七条 公司的法定代表人违反公司法关于公司对外担保决议程序的规定，超越权限代表公司与相对人订立担保合同，人民法院应当依照民法典第六十一条和第五百零四条等规定处理：\n（一）相对人善意的，担保合同对公司发生效力；相对人请求公司承担担保责任的，人民法院应予支持。\n（二）相对人非善意的，担保合同对公司不发生效力；相对人请求公司承担赔偿责任的，参照适用本解释第十七条的有关规定。\n法定代表人超越权限提供担保造成公司损失，公司请求法定代表人承担赔偿责任的，人民法院应予支持。\n第一款 所称善意，是指相对人在订立担保合同时不知道且不应当知道法定代表人超越权限。相对人有证据证明已对公司决议进行了合理审查，人民法院应当认定其构成善意，但是公司有证据证明相对人知道或者应当知道决议系伪造、变造的除外。\n第八条 有下列情形之一，公司以其未依照公司法关于公司对外担保的规定作出决议为由主张不承担担保责任的，人民法院不予支持：（一）金融机构开立保函或者担保公司提供担保；（二）公司为其全资子公司开展经营活动提供担保；（三）担保合同系由单独或者共同持有公司三分之二以上对担保事项有表决权的股东签字同意。上市公司对外提供担保，不适用前款第二项、第三项的规定。\n第九条 相对人根据上市公司公开披露的关于担保事项已经董事会或者股东大会决议通过的信息，与上市公司订立担保合同，相对人主张担保合同对上市公司发生效力，并由上市公司承担担保责任的，人民法院应予支持。相对人未根据上市公司公开披露的关于担保事项已经董事会或者股东大会决议通过的信息，与上市公司订立担保合同，上市公司主张担保合同对其不发生效力，且不承担担保责任或者赔偿责任的，人民法院应予支持。相对人与上市公司已公开披露的控股子公司订立的担保合同，或者相对人与股票在国务院批准的其他全国性证券交易场所交易的公司订立的担保合同，适用前两款规定。\n第十条 一人有限责任公司为其股东提供担保，公司以违反公司法关于公司对外担保决议程序的规定为由主张不承担担保责任的，人民法院不予支持。公司因承担担保责任导致无法清偿其他债务，提供担保时的股东不能证明公司财产独立于自己的财产，其他债权人请求该股东承担连带责任的，人民法院应予支持。\n第十一条 公司的分支机构未经公司股东（大）会或者董事会决议以自己的名义对外提供担保，相对人请求公司或者其分支机构承担担保责任的，人民法院不予支持，但是相对人不知道且不应当知道分支机构对外提供担保未经公司决议程序的除外。金融机构的分支机构在其营业执照记载的经营范围内开立保函，或者经有权从事担保业务的上级机构授权开立保函，金融机构或者其分支机构以违反公司法关于公司对外担保决议程序的规定为由主张不承担担保责任的，人民法院不予支持。金融机构的分支机构未经金融机构授权提供保函之外的担保，金融机构或者其分支机构主张不承担担保责任的，人民法院应予支持，但是相对人不知道且不应当知道分支机构对外提供担保未经金融机构授权的除外。担保公司的分支机构未经担保公司授权对外提供担保，担保公司或者其分支机构主张不承担担保责任的，人民法院应予支持，但是相对人不知道且不应当知道分支机构对外提供担保未经担保公司授权的除外。公司的分支机构对外提供担保，相对人非善意，请求公司承担赔偿责任的，参照本解释第十七条的有关规定处理。\n第十二条 法定代表人依照民法典第五百五十二条的规定以公司名义加入债务的，人民法院在认定该行为的效力时，可以参照本解释关于公司为他人提供担保的有关规则处理。\n法律解释 #  法律规定 #  第七十一条 有限责任公司向其他企业投资或者为他人提供担保，按照公司章程的规定，由董事会或者股东会决议；公司章程对投资或者担保的总额及单项投资或者担保的数额有限额规定的，不得超过规定的限额。 公司为公司股东或者实际控制人提供担保的，必须经股东会决议。 前款规定的股东或者受前款规定的实际控制人支配的股东，不得参加前款规定事项的表决。该项表决由出席会议的其他股东所持表决权的过半数通过。\n缺少后果→错决议、超限额 #  股东会、董事会会议的召集程序、表决方式违反法律、行政法规或者公司章程，或者决议内容违反公司章程的→可撤销 未召开；未表决；人数或表决权数不够；未达到通过→不成立\n此针对的是决议\n针对越权代理 #  公司根据该决议与善意相对人形成的民事法律关系不受影响\n非关联担保 #   “他人”：非股东和实际控制人 要求：由董事会或者股东会决议；不得超过规定的限额。  关联担保 #   股东或实际控制人： 附则（三）实际控制人，是指通过投资关系、协议或者其他安排，能够实际支配公司行为的人。 要求：经股东会决议；前款规定的股东或者受前款规定的实际控制人支配的股东，不得参加前款规定事项的表决；由出席会议的其他股东所持表决权的过半数通过。  “超越权限”的担保合同的效力 #  历来主张担保是特殊的公司行为，不直接适用“公司根据该决议与善意相对人形成的民事法律关系不受影响”。\n区分对内对外阶段 #  对是否对公司产生效力与合同是否具有效力进行判断\n判断71条的规范性质 #  强制性规范性质没有争议，但强制规范又可进一步分为管制性规范和效力性规范，在效力二分法的性质判定确实难以确定的。有一种观点是直接认定为效力性规范，即违反了该强制规定的直接定义为无效。\n联系合同法以越权代理进行判断 #  认为该条款为内部程序规范，否认公司章程的对世效力，割裂该条款与担保合同效力的牵连关系，而将担保合同效力的判断过度到标间代表的规则上。\n九民概要 #  （六）关于公司为他人提供担保 关于公司为他人提供担保的合同效力问题，审判实践中裁判尺度不统一，严重影响了司法公信力，有必要予以规范。对此，应当把握以下几点： 17.【违反《公司法》第16条构成越权代表】，人民法院应当根据《合同法》第50条关于法定代表人越权代表的规定，区分订立合同时债权人是否善意分别认定合同效力：债权人善意的，合同有效；反之，合同无效。 18.【善意的认定】前条所称的善意，是指债权人不知道或者不应当知道法定代表人超越权限订立担保合同。一种情形是，关联担保，应当提供证据证明其在订立合同时对股东（大）会决议进行了审查，决议的表决程序符合《公司法》第16条的规定，另一种情形是非关联担保，只要债权人能够证明其在订立担保合同时对董事会决议或者股东（大）会决议进行了审查，同意决议的人数及签字人员符合公司章程的规定，就应当认定其构成善意，但公司能够证明债权人明知公司章程对决议机关有明确规定的除外。债权人对公司机关决议内容的审查一般限于形式审查，只要求尽到必要的注意义务即可，标准不宜太过严苛。公司以机关决议系法定代表人伪造或者变造、决议程序违法、签章（名）不实、担保金额超过法定限额等事由抗辩债权人非善意的，人民法院一般不予支持。但是，公司有证据证明债权人明知决议系伪造或者变造的除外。 19.【无须机关决议的例外情况】存在下列情形的，即便债权人知道或者应当知道没有公司机关决议，也应当认定担保合同符合公司的真实意思表示，合同有效：（1）公司是以为他人提供担保为主营业务的担保公司，或者是开展保函业务的银行或者非银行金融机构；（2）公司为其直接或者间接控制的公司开展经营活动向债权人提供担保；（3）公司与主债务人之间存在相互担保等商业合作关系；（4）担保合同系由单独或者共同持有公司三分之二以上有表决权的股东签字同意。 20.【越权担保的民事责任】依据前述3条规定，担保合同有效，债权人请求公司承担担保责任的，人民法院依法予以支持；担保合同无效，债权人请求公司承担担保责任的，人民法院不予支持，但可以按照担保法及有关司法解释关于担保无效的规定处理。公司举证证明债权人明知法定代表人超越权限或者机关决议系伪造或者变造，债权人请求公司承担合同无效后的民事责任的，人民法院不予支持。 21.【权利救济】法定代表人的越权担保行为给公司造成损失，公司请求法定代表人承担赔偿责任的，人民法院依法予以支持。公司没有提起诉讼，股东依据《公司法》第151条的规定请求法定代表人承担赔偿责任的，人民法院依法予以支持。 22.【上市公司为他人提供担保】债权人根据上市公司公开披露的关于担保事项已经董事会或者股东大会决议通过的信息订立的担保合同，人民法院应当认定有效。 23.【债务加入准用担保规则】该约定的效力问题，参照本纪要关于公司为他人提供担保的有关规则处理。\n2020最高人民法院关于适用《中华人民共和国民法典》有关担保制度的解释 #  第七条 超越权限代表公司与相对人订立担保合同 （一）相对人善意的，担保合同对公司发生效力；相对人请求公司承担担保责任的，人民法院应予支持。 （二）相对人非善意的，担保合同对公司不发生效力；相对人请求公司承担赔偿责任的，参照适用本解释第十七条的有关规定。 法定代表人超越权限提供担保造成公司损失，公司请求法定代表人承担赔偿责任的，人民法院应予支持。 第一款 所称善意，是指相对人在订立担保合同时不知道且不应当知道法定代表人超越权限。相对人有证据证明已对公司决议进行了合理审查，人民法院应当认定其构成善意，但是公司有证据证明相对人知道或者应当知道决议系伪造、变造的除外。\n第十七条　主合同有效而第三人提供的担保合同无效，人民法院应当区分不同情形确定担保人的赔偿责任：　（一）债权人与担保人均有过错的，担保人承担的赔偿责任不应超过债务人不能清偿部分的二分之一；　（二）担保人有过错而债权人无过错的，担保人对债务人不能清偿的部分承担赔偿责任；　（三）债权人有过错而担保人无过错的，担保人不承担赔偿责任。　主合同无效导致第三人提供的担保合同无效，担保人无过错的，不承担赔偿责任；担保人有过错的，其承担的赔偿责任不应超过债务人不能清偿部分的三分之一。\n第八条 有下列情形之一，公司以其未依照公司法关于公司对外担保的规定作出决议为由主张不承担担保责任的，人民法院不予支持：（一）金融机构开立保函或者担保公司提供担保；（二）公司为其全资子公司开展经营活动提供担保；（三）担保合同系由单独或者共同持有公司三分之二以上对担保事项有表决权的股东签字同意。上市公司对外提供担保，不适用前款第二项、第三项的规定。\n第九条 相对人根据上市公司公开披露的关于担保事项已经董事会或者股东大会决议通过的信息，与上市公司订立担保合同，相对人主张担保合同对上市公司发生效力，并由上市公司承担担保责任的，人民法院应予支持。相对人未根据上市公司公开披露的关于担保事项已经董事会或者股东大会决议通过的信息，与上市公司订立担保合同，上市公司主张担保合同对其不发生效力，且不承担担保责任或者赔偿责任的，人民法院应予支持。相对人与上市公司已公开披露的控股子公司订立的担保合同，或者相对人与股票在国务院批准的其他全国性证券交易场所交易的公司订立的担保合同，适用前两款规定。\n第十条 一人有限责任公司为其股东提供担保，公司以违反公司法关于公司对外担保决议程序的规定为由主张不承担担保责任的，人民法院不予支持。公司因承担担保责任导致无法清偿其他债务，提供担保时的股东不能证明公司财产独立于自己的财产，其他债权人请求该股东承担连带责任的，人民法院应予支持。\n第十一条 公司的分支机构未经公司股东（大）会或者董事会决议以自己的名义对外提供担保，相对人请求公司或者其分支机构承担担保责任的，人民法院不予支持，但是相对人不知道且不应当知道分支机构对外提供担保未经公司决议程序的除外。金融机构的分支机构在其营业执照记载的经营范围内开立保函，或者经有权从事担保业务的上级机构授权开立保函，**金融机构或者其分支机构以违反公司法关于公司对外担保决议程序的规定为由主张不承担担保责任的，人民法院不予支持。**金融机构的分支机构未经金融机构授权提供保函之外的担保，金融机构或者其分支机构主张不承担担保责任的，人民法院应予支持，但是相对人不知道且不应当知道分支机构对外提供担保未经金融机构授权的除外。担保公司的分支机构未经担保公司授权对外提供担保，担保公司或者其分支机构主张不承担担保责任的，人民法院应予支持，但是相对人不知道且不应当知道分支机构对外提供担保未经担保公司授权的除外。公司的分支机构对外提供担保，相对人非善意，请求公司承担赔偿责任的，参照本解释第十七条的有关规定处理。\n第十二条 法定代表人依照民法典第五百五十二条的规定以公司名义加入债务的，人民法院在认定该行为的效力时，可以参照本解释关于公司为他人提供担保的有关规则处理。\n总结：对外 #  在最近的有关担保的司法解释的背景下，公司法有关担保的规定与合同中表见代理的规定一同构成了担保合同的判断，其中合同表见代理确定合同是否有效，公司法的条款作为具体的善意判断条款。\n 超越权限代表公司与相对人订立担保合同 （一）相对人善意的，担保合同对公司发生效力；相对人请求公司承担担保责任的，人民法院应予支持。 （二）相对人非善意的，担保合同对公司不发生效力；相对人请求公司承担赔偿责任的，参照适用本解释第十七条的有关规定。 法定代表人超越权限提供担保造成公司损失，公司请求法定代表人承担赔偿责任的，人民法院应予支持。 善意的判断：相对人有证据证明已对公司决议进行了合理审查，人民法院应当认定其构成善意，但是公司有证据证明相对人知道或者应当知道决议系伪造、变造的除外。担保解释将相对人的审查义务由九民纪要的“形式审查”提高到了“合理审查“。  担保合同无效时的责任承担（现在） #   合同有效的情形下，公司作为担保人须对外承担担保责任。 法定代表人超越权限提供担保造成公司损失，公司请求法定代表人承担赔偿责任的，人民法院应予支持。 合同无效的情况下：第十七条　主合同有效而第三人提供的担保合同无效，人民法院应当区分不同情形确定担保人的赔偿责任：　（一）债权人与担保人均有过错的，担保人承担的赔偿责任不应超过债务人不能清偿部分的二分之一；　（二）担保人有过错而债权人无过错的，担保人对债务人不能清偿的部分承担赔偿责任；　（三）债权人有过错而担保人无过错的，担保人不承担赔偿责任。　主合同无效导致第三人提供的担保合同无效，担保人无过错的，不承担赔偿责任；担保人有过错的，其承担的赔偿责任不应超过债务人不能清偿部分的三分之一。  主体利益分析 #  相对人、债务人、公司:合同无效意味着相对人不能凭担保合同要求公司承担担保义务，相对人受损失。\n既往司法裁判确定过了合同对公司不生效时应按照担保法及相关司法解释有关担保规定无效处理的裁判立场。有学者对此评判道：“学者对于第16条属性的理解差异悬殊，法院对于该条的理解亦歧见丛生，但者丝毫不影响法院关于责任承担最终裁判的一致性。\n罗伟华、南昌绿地申人置业有限公司民间借贷纠纷再审 #  基本事实： 债权人（相对人）：罗伟华 债务人：杨骏、黄继红 公司：南昌绿地申人置业有限公司 杨骏自绿地申人公司成立至2015年12月期间担任绿公司经理，公司的财务章、合同专用章等重要印章均由其实际管理。杨骏是公司实际控制人。\n2013年1月31日，杨骏出具《借条》一份，载明：今借到罗伟华人民币1000万元整，借期三个月。同日，罗伟华、杨骏、绿地申人公司签订《借款协议书》一份，载明：罗伟华借款给杨骏人民币1000万元，借款期间为三个月，自银行汇出之日起算，指定的收款账户为杨骏，账号：62×××09，借款期内利息按月息一分五计算，期满后，杨骏应将该借款本金归还罗伟华，如杨骏逾期未还，则每日按本金的0.2%支付违约金。绿地申人公司自愿为杨骏上述债务提供连带责任担保。2013年2月1日，罗伟华向杨骏上述指定账户存入人民币1000万元。 2013年11月8日，罗伟华与被告杨骏、绿地申人公司签订《借款合同》一份，载明：罗伟华借给杨骏人民币1300万元整，借款期间为3个月，以银行汇出之日起算，指定收款账户为杨骏，账号：62×××81，借款期内利息按月息2分计算，各方均同意预先扣减杨骏应承担的三个月利息人民币78万元，即罗伟华仅需向杨骏汇出1222万元即可，期满后杨骏应将该借款本金归还罗伟华，如杨骏逾期未还，除按前述标准支付利息外，还应每日按本金的0.2%支付逾期违约金。绿地申人公司自愿为杨骏上述借款提供连带责任担保。同日，罗伟华向杨骏上述指定账户分别汇入人民币99万元、99万元、99万元、99万元、99万元、99万元、99万元、82万元、99万元、99万元、99万元，共计1072万元。2013年11月8日，杨骏出具《收条》一份，载明收到罗伟华人民币1300万元，利息为月息2分，三个月的利息78万元已经扣减。 2014年8月19日，杨骏出具《借条》一份，载明：本人于2013年累计向罗伟华借款人民币2300万元整，由于资金紧张，该借款到期后仍未清偿完毕，截至2014年8月19日，尚欠借款本金1773万元，利息177.3元。本人承诺上述债务于2014年9月19日之前偿还，如再逾期不还，则逾期之后的利息将按月息6%计算。同日，绿地申人公司出具《承诺》一份，载明：对上述《借条》内容，我方不持异议并自愿继续为杨骏所欠债务提供连带责任担保，保证责任期间为上述借款期限届满后二年。 罗伟华自认于2014年3月5日收到还款人民币800万元，于2014年12月12日收到还款人民币1000万元。\n具体关系 #  罗伟华虽提交了2003年杨骏与黄继红的结婚证，证明杨骏与黄继红于2003年登记结婚，但罗伟华并未提交最新的婚姻登记情况，证明杨骏与黄继红在上述债务发生期间仍系夫妻关系，且未提交证据证实上述款项用于夫妻共同生活。 绿地申人公司上诉提出，杨骏自绿地申人公司成立至2015年12月期间担任绿公司经理，公司的财务章、合同专用章等重要印章均由其实际管理。杨骏是公司实际控制人。**根据《中华人民共和国公司法》第十六条第二款、《最高人民法院关于适用若干问题的解释》第四条规定，**绿地申人公司为杨骏提供担保，必须要经公司股东会决议通过，否则依法无效。本院认为，案涉借款合同（协议）签订于2013年1月31日、11月8日，绿地申人公司为案涉借款提供担保也是这个时间。故本案适用的《中华人民共和国公司法》应该是经中华人民共和国第十届全国人民代表大会常务委员会第十八次会议于2005年10月27日修订通过、2006年1月1日施行的《中华人民共和国公司法》。**该法第十六条规定，公司为公司股东或者实际控制人提供担保的，必须经股东会或者股东大会决议。第一百四十九条规定，董事、高级管理人员不得有下列行为：……（三）违反公司章程的规定，未经股东会、股东大会或者董事会同意，将公司资金借贷给他人或者以公司财产为他人提供担保。董事、高级管理人员违反前款规定，所得的收入应当归公司所有。**即1999年修订的《中华人民共和国公司法》第六十条“董事、经理不得以公司资产为本公司的股东或者其他个人债务提供担保”已修改为上述内容，但禁止公司董事、经理以公司财产为他人提供担保的基本内容未变。《最高人民法院关于适用若干问题的解释》第四条规定适用的基础仍然存在。经查，杨骏并非绿地申人公司的股东，也非《中华人民共和国公司法》所指的实际控制人，只是绿地申人公司聘用的经理，系其高级管理人员。故绿地申人公司为杨骏向罗伟华借款提供担保，不适用《中华人民共和国公司法》第十六条的规定，而应适用该法第一百四十九条的规定。**按照绿地申人公司章程规定，杨骏作为公司经理，其无权以公司名义对外提供担保。**其签署案涉借款合同，以绿地申人公司名义为其自己向罗伟华借款提供担保，也未经股东会议或董事会同意，确实违反了公司章程和《中华人民共和国公司法》（2005年修订）第一百四十九条的规定。根据《最高人民法院关于适用若干问题的解释》第四条的规定，绿地申人公司为杨骏向罗伟华借款提供担保应确认无效。绿地申人公司聘用杨骏为其公司经理，并经工商登记部门登记，该信息对外具有公示性，罗伟华应当知道杨骏系绿地申人公司的高级管理人员，且未要求绿地申人公司提供股东会或者董事会决议，故对案涉借款担保合同无效也存在过错，根据《最高人民法院关于适用若干问题的解释》第七条“主合同有效而担保合同无效，债权人无过错的，担保人与债务人对主合同债权人的经济损失，承担连带赔偿责任；债权人、担保人有过错的，担保人承担民事责任的部分，不应超过债务人不能清偿部分的二分之一”的规定，绿地申人公司应对杨骏不能偿还罗伟华借款本金及利息、逾期违约金的部分，在50%范围内承担赔偿责任。\n再审认定 #  本院认为，2013年《公司法》实施时间为2014年3月1日，而绿地申人公司为案涉借款提供担保的时间分别为2013年1月和11月，根据《最高人民法院关于适用若干问题的规定（一）》第一条“公司法实施后，人民法院尚未审结的和新受理的民事案件，其民事行为或事件发生在公司法实施以前的，适用当时的法律法规和司法解释”的规定，本案应当适用担保行为发生当时的法律，故二审法院适用2005年《公司法》并无不当。 根据本案已查明事实，2013年1月至2015年12月6日期间，杨骏担任绿地申人公司的经理，并实际管理该公司的财务章、法人章、公司公章、合同专用章等重要印章和相关文件。本案所涉绿地申人公司担保，系在未经该公司法定代表人签字、未经公司股东会或董事会决议的情况下，仅以在罗伟华、杨骏签订的《借款合同》《借款协议书》上加盖公司印章的方式为杨骏个人债务而提供，明显不当。罗伟华对绿地申人公司所提供担保未尽合理审查义务，具有过错。其仅以《公司法》第十六条系公司内部管理规范为由提出抗辩，理据不足。**二审判决适用2005年《公司法》第一百四十九条、《担保法解释》第四条的规定虽有瑕疵，但在判令绿地申人公司所提供担保无效的同时由绿地申人公司对于杨骏不能偿还的部分在50%范围内承担赔偿责任，**裁判结果并无不当，本院予以维持。\n问题所在 #  即使公司担保行为无效，共公司仍然普遍须承担实质上类似有效担保的责任。 在我国司法实践中，如果公司提供的担保无效，法院通常认为公司仍需承担与有效担保类似甚至相同的责任。而且，无论公司担保行为是否有效，公司总要承担责任。这种做法背离了合同无效责任的一般规则，可能使担保行为的效力判断在相当程度上失去意义，甚或妨碍担保经济功能的实现，其正当性需要予以额外论证。 图示统计表，说明案件多为公司须承担。\n争议分析 #  a担保合同与保证成立的冲突；b二主体错误的认识\n 按担保合同无效的情况中。担保合同无效和保证（物）的适用问题。 直接将欠缺决议或决议不正确直接等同于超越权限。从一般法理来看，的确担保合同无效或不成立时，担保人的责任应为缔约过失责任。然后，在法定代表人越权代表签订担保合同的场合，该担保合同本身并非无效或不成立，而只是对一般公司不生效。况且公司并无实际缔约行为，何谈缔约过失？因此，担保合同不生效时，公司便从担保关系中完全撤出，法律不应苛求其承担任何责任。此时法定代表人的行为后果只能由其自身承担，相对人应当向担任法定代表人的个人主张过错行为的赔偿责任。 公司一般需要承担责任。法律规范补充。法院会认为公司具有对行为人、公章等”监管不力“或”管理不善“的过错，因而应当承担责任，需要注意的是，法院往往不会具体讨论公司监管不善的表现，而是从结果反推过错，即只要存在代表人没有决议就定理担保合同或者斯盖公章等情形，法院就会认定公司具有过错。在这种过错认定标准下，公司很难不承担责任。 债权人有无过错的认定不清。即规范是否使债权人承担审查的义务，法院存在两种倾向，一种是直接认定公司法第十六条为效力性强制规范，直接认定该担保合同无效。另一种是认为该规范属于管理型规范，认为应当适用合同法善意取得的制度。第一种赋予了章程对世效力，应当认为债权人需要尽到相应的审查义务，但实务几乎不适用该种，也更无义务判定；另一种是适用善意取得的制度，但是却没有相应的更为可以进行判断。  规范思路整理 #   法律沿革（制度最开始的规定与演进）：法律规定、性质厘定、制度构建、融会贯通、寻找问题（参考相关的论文） 制度总结：从制度层面而非条文层面再做一次总结、厘定分析的焦点 理论研究：有争议的地方从实践、从论文、从条文，再做进一步的解读 国内立法：比较法、国内土壤国内问题国内法制  "},{"id":48,"href":"/docs/cs/basic/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"内存管理","section":"计算机基础知识","content":"内存管理 #  一、虚拟内存思想 #  我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套虚拟地址，人人都有，大家自己玩自己的地址就行，互不干涉。虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了（MMU）。\n二、内存分段 #  1、机制 #  虚拟地址和物理地址之间通过段表（段基地址+段大小）来映射。\n分段机制会把程序的虚拟地址分成 4 个段：代码分段、数据分段、堆段、栈段。\n2、不足 #  内存碎片问题（不连续的小物理内存，浪费） -\u0026gt; 并因此有内存交换的效率低的问题。\n三、内存分页 #  1、分页机制 #  分页是把整个虚拟和物理内存空间切分成一页一页，固定尺寸，Linux下一页是4KB。\n虚拟地址与物理地址之间通过页表来映射。\n2、多级页表 #  页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项。（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。\n3、缺页异常 #  而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。\n 最近最久未使用 LRU 先进先出 第二次机会算法  4、快表 #  局部性原理。\n 根据逻辑地址，得到页号+页内偏移，去快表里面，看是否命中。 如果命中，取出对应的内存块号，和页内偏移拼接得到物理地址。即：只需一次访存。 如果没命中，访问内存中的页表，找到对应表项，最后得到物理地址，访问内存。即：两次访存。同时，还要存入快表，如果满了，就进行替换。  5、好处和优点 #   解决了内存碎片问题 交换效率也更高 不需要一次性全部加载到物理内存  四、段页式内存管理 #    先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；\n  接着再把每个段划分为多个页。\n  这样，地址结构就由段号、段内页号和页内位移三部分组成。\n段页式地址变换中要得到物理地址须经过三次内存访问：\n  第一次访问段表，得到页表起始地址；\n  第二次访问页表，得到物理页号；\n  第三次将物理页号与页内位移组合，得到物理地址。\n  五、Linux 内存管理 #  内核空间 和 用户空间两部分：\n虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。且所有段的起始地址都一样。（共享和保护）\n通过这张图你可以看到，用户空间内存，从低到高分别是 7 种不同的内存段：\n  程序文件段，包括二进制可执行代码；\n  已初始化数据段，包括静态常量；\n  未初始化数据段，包括未初始化的静态变量；\n  堆段，包括动态分配的内存，从低地址开始向上增长；\n  文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）\n  栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；\n  在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。\n 比较  对程序员的透明姓 地址空间的维度 大小是否可改变 作用：虚拟内存更大空间；逻辑独立共享保护    "},{"id":49,"href":"/docs/cs/basic/%E6%AD%BB%E9%94%81/","title":"死锁","section":"计算机基础知识","content":"死锁 #  1、死锁怎么产生的？ #  两个或者多个进程相互等待对方资源，导致死锁。比如：\n 系统资源不足 资源分配不合理 进程运行推进顺序不合理  2、必要条件 ？\u0026mdash;\u0026gt; 预防方法？ #  一般来说，发生死锁有四个必要条件：\n 互斥：资源要么已经分配给了一个进程，要么就是可用的。\u0026ndash; A唯一拥有B 占有和等待：已经得到了某个资源的进程可以再请求新的资源。\u0026ndash; 开始前就把所有需要的资源都申请好 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或多个进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 \u0026ndash; 给资源统一编号  3、处理方法 #   鸵鸟策略：因为代价太高了，所以如果影响不大或概率低 死锁预防：运行之前破坏4个条件 死锁检测与死锁恢复：有向图是否存在环、抢占、回滚、杀死进程 死锁避免：运行时  安全状态：就算所有进程突然请求对资源的最大需求，也存在 单个资源的银行家算法：如果满足请求，状态是否安全，拒绝进入不安全状态 多个资源的银行家算法：拒绝进入不安全状态  检测一个状态是否安全：  还需要分配的矩阵是否存在一行小于等于向量A?没有的话就是不安全的 找到一行，就标记终止，并计入已分配资源 知道所有进程都被标记终止，则状态安全。        "},{"id":50,"href":"/docs/cs/basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"计算机网络","section":"计算机基础知识","content":"计算机网络 #  一、网络体系结构 #   分层原因：独立（更容易实现和维护）、标准化的制定 表示层的作用：数据转化，比如加解密、压缩和解压缩。如视频 会话层的作用：会话控制  二、传输层 TCP、UDP #  1-1、三次握手 #   服务端首先处于LISTEN状态，等待客户端的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x，发送完毕后，客户端就进入SYN_SENT状态 B 收到连接请求报文，进行第二次握手，向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。然后服务端进入SYN-RCVD. A 收到以后，进行第三次握手，向 B 发出确认报文，ACK=1，确认号为 y+1，序号为 x+1。然后进入ESTABLISHED状态，当服务器端收到以后，也进入ESTABLISHED状态。  1-2、为什么是三次握手，不是两次？ #  为了防止已失效的连接请求报文段突然又传送到了服务端，从而产生错误。\n 第一次握手请求，滞留，连接释放以后的某个时间到达。 服务端以为是新的连接请求，发确认报文，同意建立连接。 假设不采用“三次握手”，只要服务端确认了，新的连接就建立了。 但事实上客户端并没有，因此不会管服务端。但服务端一直等待数据，资源白白浪费。  从另外一个角度看，这个问题的本质是信道是不可靠的，但是通信的双方为了保证传输是可靠的，三次通信是理论上的最小值。例如TCP的可靠连接核心就是靠seq序列号来完成的。A会向B同步自己的初始序列号，B也会反过来向A同步自己的初始序列号，并且TCP规定，必须经过确认，也就是\u0026hellip;\n1-3、如果第三次握手报文丢了，会怎么样？ #  如果第三次握手报文丢了，A发完后就进入Established状态，但B还是SYN-RCVD：\n 如果双方都没有数据要发送，则B会周期性超时重传； 如果A有数据要发给B，会发送 Data + ACK, B就会进入Established状态，并接受数据； 如果B有数据要发给A，发不了。同1.  2-1、四次挥手 #   第一次挥手。客户端向服务器端发送一个FIN报文，通知服务器，我已经没有数据要发送了，进入FIN_WAIT_1状态。 第二次挥手。服务端返回一个ACK报文，告诉客户端，我知道你已经没有东西要发送了，但我还要再确认一下我是不是还有东西要给你。然后服务器端进入CLOSE_WAIT状态。客户端接收到确认包之后进入FIN_WAIT_2状态。此时TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 第三次挥手。服务器判断自己也没有数据需要发送给客户端，就向客户端发送ACK和FIN消息，告诉客户端，好了，我也没有东西要给你了，你可以关掉这个连接了。然后服务器端就进入了LAST_ACK状态。 最后是第四次挥手。客户端发送确认报文。发送完以后，进入TIME_WAIT状态，等待 2 MSL以后，关闭连接，进入CLOSED状态。服务器端接收到确认包以后，也关闭连接，进入CLOSED状态。   2-2、为什么要四次挥手？ #  是为了确保客户端和服务端双方都能通知对方释放连接。\n其中第二次挥手之后，服务端进入 CLOSE-WAIT 状态：让服务器端把还没发送完的数据发送过去。等发送完之后，再发送 FIN 连接释放报文。\n2-3、为什么要等2MSL时间？ #  客户端进入TIME_WAIT状态，而不是直接进入 CLOSED 状态的原因是为了确保最后一个确认报文能够到达。如果客户端发送的第四次挥手的报文丢了， B 没收到 A 发送来的确认报文，那么就会重新发送第三次挥手的报文，等待一段时间就是为了处理这种情况的发生。\n3、TCP怎么保证可靠传输？ #   用三次握手、四次挥手，保证传输的信道是可靠的 采用连续ARQ协议，超时自动重传 滑动窗口进行流量控制 拥塞控制 校验和   序列号  4、知道超时重传机制吗？ #  停止等待协议：过了timeout时间，还没收到ACK确认号，就重发。\n具体来说：\n A维护一个计时器，如果出现分组差错或者分组丢失，就超时重传 如果应答丢失或者应答迟到，就丢弃/补上确认等等。  5、怎么进行流量控制的？ #  流量控制：为了让接收方能来得及接收。用大小可变的滑动窗口进行流量控制。（连续ARQ协议）\n接收方给发送方回ACK报文时，把窗口大小写进去。如果窗口为 0，则发送方不能发送数据。\n滑动窗口：\n 发送窗口：已发送并确认、已发送未确认、待发送、不能发送 接受窗口：已确认并交付、允许接收的、不许接收的  6、怎么进行拥塞控制？ #  拥塞控制：降低整个网络的拥塞程度的同时，最大可能性地利用带宽。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。\n 慢启动技术。如果连接建立好，一上来就给对端发大量的报文，可能无法到达，并造成网络拥塞。慢启动技术是开始会发很小的报文给对端，收到对端的ACK判断可达后，会不断加倍发送给的报文量。 直到到达一个门限值，就进入拥塞避免，每次只加1。如果出现超时，则门限值就变为超时的时候的拥塞变量的一半，重新回到满开始。 如果出现丢包问题，收到三个连续的重复的确认报文，无需等待，直接重传，就是快重传。 快恢复是说让门限值变为之前拥塞变量的一半，然后直接进入拥塞避免，拥塞变量即为门限值，每次加1.  发送方维护一个拥塞窗口变量。\n 初始为1，收到ACK，指数增长。 到门限值，进入拥塞避免，每次加1 出现超时，门限值变为超时的时候的拥塞变量的一半。cwnd重新回到慢开始 如果出现丢包问题，连续收到三个重复的确认报文，无需等待，直接重传。进行快重传和快恢复 快恢复时，门限值为之前拥塞变量的一半，拥塞变量为门限值，直接进入拥塞避免。   7、知道 TCP 的报文头吗？ #  8、知道TCP的粘包和拆包吗？ #  什么意思：一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送。\n为什么会出现：\n 要发送的数据太少了，小于TCP发送缓冲区的大小-\u0026gt;封装成一个大的数据包一次发送。或者接收端没有及时读取接收缓冲区的数据-\u0026gt;一次读完 大于缓冲区 或 数据太大了-\u0026gt;拆  解决：\n 发送端：数据包固定长度， 数据分为头部和尾部，头部大小固定，且声名数据的大小。  13、TCP 几种报文和确认机制 #  TCP看似复杂，其实可以归纳为以下5种报文：\n SYN Data （唯一携带用户数据） FIN Reset ACK  其中1、2、3分别为建立连接、数据传输、断开连接，这三种报文对方接收到一定要ACK确认，为何要确认，因为这就是可靠传输的依赖的机制。如果对方在超时时间内不确认，发送方会一直重传，直到对方确认为止、或到达重传上限次数而Reset连接。\n4、5 为重置连接报文、确认ACK报文，这两种报文对方接收到要ACK确认吧？不需要！自然发送方也不会重传这2种类型的报文。\n为何Reset报文不需要ACK确认?\n因为发送Reset报文的一端，在发送完这个报文之后，和该TCP Session有关的内存结构体瞬间全部释放，无论对方收到或没有收到，关系并不大。 如果对方收到Reset报文，也会释放该TCP Session 的相关内存结构体。\n如果对方没有收到Reset 报文，可能会继续发送让接收方弹射出Reset报文的报文，到最后对方一样会收到Reset 报文，并最终释放内存。 为何ACK报文不需要ACK确认?\n这里的ACK报文，是指没有携带任何数据的裸ACK报文，对方收到这样的ACK报文，自然也不需要ACK。否则，对方为了ACK己方的ACK，那己方收到对方的ACK，也要ACK对方的ACK，这就是一个死循环，永无止息。所以为了避免这个死循环，一律不允许ACK对方的裸ACK报文。\n14、介绍一下UDP？ #   不可靠，只尽最大努力交付、无连接，效率高。 首部8字节：源、目的端口、校验和、长度 应用场景：音视频传输（涉及实时性，纠错没意义） 协议：DNS、DHCP、RIP  TCP和UDP的区别？ #   可靠传输 面向连接 数据有序 重量级协议，速度较慢，效率较低 有流量控制和拥塞控制 首部20字节 VS 8字节 面向字节流VS面向报文,不合并，不拆分，保留原报文的边界。  UDP如何实现可靠传输？ #  在应用层模仿TCP的可靠性传输。\n 添加seq/ack机制，确保数据发送到对端 添加发送和接收缓冲区，添加超时重传机制。  详细：\n 发送时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。 发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。  目前有一些开源程序利用udp实现了可靠的数据传输：RUDP、RTP、UDT。\n三、应用层：DNS协议 #   分布式数据库，主机域名和IP地址转换解析：  先检查浏览器缓存是否有这个域名，有就调IP地址 如果没有，查本地DNS缓存 如果没有，查本地DNS服务器 如果没有，本地服务器向根域名服务器发查询请求。返回：告诉要去查哪个顶级域名服务器 向顶级-发查请求，返回：告诉要去查那个权限域名服务器 向权限-发查请求，返回：对应的IP地址 本地-告诉主机对应的IP地址   HTTP协议、FTP、邮件传输协议（SMTP，POP3）  四、网络层 #  主机之间的通信。选择合适的路由和交换节点。简单灵活，无连接，尽最大努力交付\nIP 协议：IP地址=网络号+主机号\n路由器属于网络层，用来识别IP地址根据IP地址转发数据包，有路由选择和分组转发的功能\n交换机：链路层，用来识别MAC地址并根据MAC地址转发数据帧。\n1、了解ARP协议吗？ #  用来做IP地址和MAC地址的转换。每个主机有一个ARP高速缓存，存着本局域网里面的各个主机和路由器的IP地址和MAC地址的映射表。\n 在同一个局域网，主机A要向主机B发IP数据报，先查A的ARP缓存。有B的就把MAC地址写到MAC帧的首部 如果没有，A在局域网里广播一个ARP请求分组，所有主机都收到 B看到了，向A单播自己的MAC地址。A收到后写入缓存 如果不在同一个局域网，换成路由器（的MAC），转发  2-1、ICMP协议之Ping的大概过程？ #  测试主机间的连通性，流程：\n 主机A向B发送多个ICMP请求报文 根据B返回报文的时间 和 成功响应的次数，推出数据包往返时间和丢包率  2-2、ICMP协议之Traceroute了解过吗？ #  用来跟踪一个分组从源点到终点的路径。\nTraceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。\n 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。  3-1、路由选择之内部网关协议 RIP #  RIP 是一种比较简单的，基于距离向量的路由选择协议。距离即跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达，也就是说限制了网络的规模。\n大概过程：我和相邻路由器交换自己的路由表，经过好多次交换之后，我就知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达。\n优点：配置简单，开销小。\n不足：网络收敛慢，跳数最大为15，限制了网络的规模。\n适用：小型网络，对收敛时间不在意（如做路由实验）\n3-2、路由选择之 OSPF 协议 #  开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。\n方法是洪泛法，毫无保留第将消息传递到本自治系统中的所有路由器（而RIP只知道邻居告诉自己的消息）。并且只有当链路状态发生变化时，路由器才会发送信息。优点：所有路由器都具有全网的拓扑结构图，并且是一致的；收敛很快。\n不足：分享的信息太多、太精确了。也无法做路由过滤。\n使用：自治系统内部\n3-3、外部网关协议 BGP #  用于自治系统之间的通信。有强大的路由策略、路由过滤功能。比如运营商之间的路由过滤，对流量实现优化和调度。\n并且可以容纳超大容量的路由条目，配置比较复杂。\n基于TCP连接。\n4、路由分组转发的流程是怎么样的？ #  从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。\n 如果我和 N 直连，就直接交付； 若有到达网络 N 的下一跳路由，则转给下一跳路由器； 若有默认路由，转给默认路由器； 报告转发分组出错。  五、数据链路层与物理层1、链路层的功能？ #  链路之间的通信。为同一链路的主机提供数据传输服务\n差错检测：循环冗余检验CRC\nMAC地址：48位，唯一表示网卡\nPPP协议2、物理层都有什么？\n传输数据比特流\n3种通信方式（单工，半双，全双）\n带通调制：数字信号-\u0026gt;模拟信号\n"},{"id":51,"href":"/docs/cs/basic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"设计模式","section":"计算机基础知识","content":"设计模式 #  零、反射 #  含义 #  在程序运行时，动态获取对象信息以及调用对象方法的能力。\n要解决的问题 #  在程序运行时，通过类的名称字符串来生成类的对象。\n一、简单工厂模式 #  含义 #  把实例化的操作单独放到一个类中，即：工厂负责生产对象。\n要解决的问题 #  让使用者不需要知道内部细节，就能创建对象，实现解耦。\n组成 #   抽象的Product，描述接口。 具体Product, 创建的目标类。 工厂类，被外界调用，根据传入不同参数从而创建不同类的实例。  实际代码 #  工厂类有个静态方法，可以用switch case控制返回哪个类的实例。外界只要调用并传入参数即可。\n改进：通过反射机制，去掉switch case，添加新Product不用修改。\n应用场景 #   当外界/客户端只关心传入参数，不关心内部逻辑时，解耦  缺点 #   处于中心位置，需要知道所有创建细节，职责过于繁重； 要加新的产品时，要修改工厂类。  二、工厂方法模式 #  含义 #  定义一个用于创建对象的接口，由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。\n要解决的问题 #   让使用者不需要知道内部细节，就能创建对象，实现解耦。 新加产品时，只要添加具体产品和具体工厂就可以。  组成 #   抽象的Product：描述接口。 具体Product：具体产品。 抽象工厂类 具体工厂类  实际代码 #  客户端怎么调用？\n new 具体工厂，得到具体工厂实例； 用具体工厂，得到具体Product类。  应用场景 #   写日志到文件/数据库  三、抽象工厂 #  含义 #  创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。\n要解决的问题 #   让使用者不需要知道内部细节，就能创建对象，实现解耦。 新加产品时，只要添加具体产品和具体工厂就可以。  组成 #   抽象的Product：描述接口。 具体Product：具体产品。 抽象工厂类 具体工厂类  实际代码 #  Client 通过 AbstractFactory 同时调用两个方法来创建出两个对象\n客户端怎么调用？\n new 具体工厂，得到具体工厂实例； 用具体工厂，得到具体Product类。  应用场景 #  四、策略模式 #   目的：如果对象的某个行为，在不同的场景中有不同的实现方式，即有多种策略或算法，不要用很多个的if-else去做判断和选择，而是封装每个策略，并使它们可以切换，从而达到解耦的效果，满足开闭原则。 具体：三种角色  策略接口：负责定义接口 具体的策略：负责实现 Context上下文：保存具体策略的实例。可以动态地改变具体的策略。   实例：多种支付方法（支付宝、微信支付）、多种分享方法（微信、QQ）。  五、单例模式 #  含义 #  确保一个类只有一个实例，并提供该实例的全局访问点。\n实现方式 #   单例类：  构造函数私有化 有个私有的静态指针变量 有个共有的静态方法获取实例     饿汉式：还没被用到，就先初始化 懒汉式  class Singleton {  private:  Singleton() {};  ~Singleton() {};  Singleton(const Singleton\u0026amp;) {}; // 拷贝构造函数  Singleton\u0026amp; operator=(const Singleton\u0026amp;); // 赋值构造函数  public:  static Singleton\u0026amp; getInstance() {  static Singleton instance; // 保证内部静态变量的线程安全性  return instance;  } } "}]