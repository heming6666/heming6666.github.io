[{"id":0,"href":"/docs/example/","title":"Example Site","section":"Docs","content":"Introduction #  Ferre hinnitibus erat accipitrem dixi Troiae tollens #  Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\n Pedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret  Est simul fameque tauri qua ad #  Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol #  Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo;  Trepident sitimque #  Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"},{"id":1,"href":"/docs/example/table-of-contents/with-toc/","title":"Linux 进程调度","section":"Table of Contents","content":"Linux 进程调度 #  前言 #  在计算机科学中，调度就是一种将任务（Work）分配给资源的方法。任务可能是虚拟的计算任务，例如线程、进程或者数据流，这些任务会被调度到硬件资源上执行，例如：处理器 CPU 等设备。调度器或调度算法的设计与实现最终都会归结到一个问题上，即如何对有限的资源进行分配以实现资源利用率的最大化并满足特定的需求。\n调度器是操作系统中的重要组件，操作系统中有进程调度器（Process Scheduler）、网络调度器（Network Scheduler）和 I/O 调度器（I/O Scheduler）等组件，本文介绍的是进程调度器。\n进程调度器负责给系统中的所有进程分配有限的 CPU 时间资源。只有通过合理的调度算法，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。\n进程调度算法总是追求达到以下目标：\n 公平：保证每个进程得到合理的 CPU 时间，避免进程的饥饿现象。 高效：尽量充分使用 CPU，使 CPU 保持忙碌状态。 快速的响应时间：使交互用户的响应时间应尽可能短。 周转时间：使批处理用户等待输出的时间尽可能短。 吞吐量：单位时间内处理的进程数量尽可能多。  但是很显然，这几个目标是相互冲突的，不可能同时达到。因此只能在这几个方面进行取舍，从而确定自己的调度算法。\n进程调度器将进程分为三类：\n  交互式进程(Interactive process)：这些进程经常与用户进行交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如命令行 shell、文本编辑程序。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。\n  批处理进程(Batch process)：这些进程一般在后台运行，不必与用户交互，需要占用大量的系统资源。但是能够忍受响应延迟。典型的批处理程序如编译程序、数据库搜索引擎等。\n  实时进程(Real-time process)：这些进程对调度延迟的要求最高，往往执行非常重要的操作，要求立即响应并执行。典型的实时程序比如视频播放软件、或飞机飞行控制系统，很明显这类程序不能容忍长时间的调度延迟。\n  根据进程的不同分类 Linux 采用不同的调度策略。\n对于实时进程，采用 FIFO 或者 Round Robin 的调度策略。\n对于普通进程，则需要区分交互式和批处理式的不同。传统 Linux 调度器提高交互式应用的优先级，使得它们能更快地被调度。而 CFS 和 RSDL 等新的调度器的核心思想是“完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。\n以下列出了 Linux 不同版本调度器的历史：\n 初始调度器 · v0.01 ~ v2.4  由几十行代码实现，功能非常简陋； 同时最多处理 64 个任务；   O(n) 调度器 · v2.4 ~ v2.6  调度时需要遍历全部任务； 当待执行的任务较多时，同一个任务两次执行的间隔很长，会有比较严重的饥饿问题；   O(1) 调度器 · v2.6.0 ~ v2.6.22  通过引入运行队列和优先级数组实现 O(1) 的时间复杂度; 使用本地运行队列替代全局运行队列增强在对称多处理器的扩展性； 通过负载均衡保证多个运行队列中任务的平衡；   完全公平调度器 · v2.6.23 ~ 至今  引入红黑树和运行时间保证调度的公平性； 引入调度类实现不同任务类型的不同调度策略；    本文会详细介绍从最初的调度器到今天复杂的完全公平调度器（Completely Fair Scheduler，CFS）的演变过程。\nLinux 初始的调度算法 #  Linux 最初的进程调度器仅由 sched.h 和 sched.c 两个文件构成。你可能很难想象 Linux 早期版本使用只有几十行的 schedule 函数负责了操作系统进程的调度：\nvoid schedule(void) {  int i,next,c;  struct task_struct ** p;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) {  ...  }  while (1) {  c = -1;  next = 0;  i = NR_TASKS;  p = \u0026amp;task[NR_TASKS];  while (--i) {  if (!*--p) continue;  if ((*p)-\u0026gt;state == TASK_RUNNING \u0026amp;\u0026amp; (*p)-\u0026gt;counter \u0026gt; c)  c = (*p)-\u0026gt;counter, next = i;  }  if (c) break;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p)  if (*p)  (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority;  }  switch_to(next); } 无论是进程还是线程，在 Linux 中都被看做是 task_struct 结构体，所有的调度进程都存储在上限仅为 64 的数组中，调度器能够处理的进程上限也只有 64 个。\n上述函数会先唤醒获得信号的可中断进程，然后从队列倒序查找计数器 counter 最大的可执行进程，counter 是进程能够占用的时间切片数量，该函数会根据时间切片的值执行不同的逻辑：\n 如果最大的 counter 时间切片大于 0，调用汇编语言的实现的 switch_to 切换进程； 如果最大的 counter 时间切片等于 0，意味着所有进程的可执行时间都为 0，那么所有进程都会获得新的时间切片；  Linux 操作系统的计时器会每隔 10ms 触发一次 do_timer 将当前正在运行进程的 counter 减一，当前进程的计数器归零时就会重新触发调度。\nO(n) 调度算法 #  数据结构：进程描述符 #  每个进程都有一个 task_struct 结构。该结构定义在 \u0026lt;include/linux/sched.h\u0026gt; 文件中，其中部分与进程调度相关的字段说明如下：\n  need_resched：调度标志，决定是否调用 schedule() 函数。\n  counter：进程处于可运行状态时所剩于的时钟节拍数。每次时钟中断到来时，update_process_times()对该值减 1。\n 创建新进程时，do_fork()以下列方式设置 current(父)和 p(子)进程的 counter 字段：current-\u0026gt;counter \u0026gt;\u0026gt;=1; p-\u0026gt;counter = current-\u0026gt;counter. 也就是说，父进程剩余的节拍数被分为两部分，一部分给父进程，一部分给子进程。这样做时为了防止通过 fork 子进程的方法无限制地使用 CPU 的时间。    rt_priority：实时进程的实时优先级。取值范围 1-99。\n  nice: 进程的静态优先级，它的值决定了 counter 的初值。nice 的取值范围是-20(优先级高)~19(优先级低)，缺省为 0。该值可通过 nice 系统调用改变。\n  policy： 本进程的调度策：\n SCHED_RR 和 SCHED_FIFO 用于实时进程。SCHED_RR 和 SCHED_FIFO 的调度策略在 rt_priority 不同的时候，都是谁的优先级高谁先执行，唯一的不同是相同优先级的处理： SCHED_RR 是时间片轮转的实时进程。当多个进程具有同一优先级时，采用时间片轮转轮流调度运行。适用于实时性要求较高但每次运行耗时较长的进程。 SCHED_FIFO 是先入先出的实时进程，先占有 CPU 的进程会持续执行，直到退出或者阻塞的时候才会让出 CPU。也只有这时候，其他同优先级的实时进程才有机会执行。适应于实时性要求比较强、而每次运行的耗时又比较短的进程。 SCHED_OTHER 用于普通的分时进程。  除了上面描述的三种调度策略，policy 成员也可以设定 SCHED_YIELD 的标记，它和调度策略无关，主要处理 sched_yield 系统调用的。\n  state: 表示进程当前运行状态：\n  TASK_RUNNING ：该状态表示这个进程可被调度执行而成为当前进程，是进程表达了希望被调度运行的意愿，内核会将该进程的 task_struct 结构加入可运行队列。\n  TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE ：这两个状态都表示进程处于睡眠状态。前者表示浅度睡眠，可被信号唤醒；后者表示深度睡眠。sleep_on 和 wake_up 用于深度睡眠；而 interruptible_sleep_on 和 interruptible_wake_up 则用于浅度睡眠。\n  TASK_ZOMBIE 表示已退出而暂时没有被父进程收回资源的\u0026quot;僵尸\u0026quot;进程。\n  TASK_STOPPED 主要用于调试目的。进程接收到一个 SIGSTOP 信号后就将运行状态改成 TASK_STOPPED 而进入挂起状态，然后在接收到一个 SIGCONT 信号时又恢复继续运行。\n    调度的时机 #  Linux 的调度程序是一个叫 schedule()的函数，由它来执行具体的调度算法。调用 schedule()的时机主要包括：\n直接调用 #    进程入睡时主动调用 schedule()：当现运行进程请求资源被阻塞时，会调用 sleep_on()或 interruptible_sleep_on()进入睡眠状态，这时会执行以下步骤：\n  把当前进程 current 插入到合适的等待队列中。\n  把当前进程 current 的状态修改为 TASK_INTERUPTIBLE 或 TASK_UNINTERUPTIBLE。\n  调用 schedule() 函数。\n  检查那个资源是否可用。如果不，转到第 2 步。\n  一旦那个资源成为可用的，把 current 从等待队列中删除。\n    进程终止时主动调用 schedule()：当现运行进程终止时，会调用 exit() 终止运行，这时会主动调用 schedule() 函数。\n  设备驱动程序执行长而重复的任务时，主动调用 schedule()：驱动程序在每次循环中，都会去检查调度标志 need_resched 的值，如果必要，就调用 schedule()主动放弃 CPU。\n  创建新进程：在 do_fork()中也会调用 schedule() 函数。\n  延迟调用 #  延迟调用是指当系统需要调度时，通过置现运行进程 need_resched 标志为 1。然后在从中断、异常、系统调用等从内核返回用户态时，对该标志进行检测，如果该标志为 1，则调用 schedule()。主要包括以下情况：\n  在中断处理过程中，发现 current 用完了时间片，置 need_resched 标志为 1。\n  一个进程被唤醒，且它的优先级比现运行进程更高，置 need_resched 标志为 1。\n  当父进程 fork 子进程时，其时间片会均分到父子进程。\n 如果只剩下一个 tick，这个 tick 会分配给子进程，而父进程的时间片则被清零，这时候等同于情况 1。 否则，父子进程的时间片都不为 0，这时等同于情况 2。    一个进程通过系统调用改变调度政策(sched_setscheduler)或表示礼让(sched_yield)时，会设置 need_resched 标志为 1。\n  如何计算优先级：godness() #  调度算法的核心是在可运行队列链表中的所有进程中确定优先级最高的进程。goodness() 就是用来计算进程优先级。它接受两个输入参数：prev(前一个运行进程)和 p(要评估的进程)，返回一个整数值 c，表示进程 p 的“值得运行的程度(goodness)”。\ngoodness()函数将实时进程和普通进程区分计算。流程如下：\n 如果该进程的 policy 被置 SCHED_YIELD 标志为，直接返回 -1。表示进程愿意“礼让”。 如果该进程是 SCHED_FIFO 或 SCHED_RR，直接返回：1000+ p-\u0026gt;rt_priority。可以看出，实时进程的优先级很高，且与 counter 和 nice 无关，至少为 1000，保证了实时进程会完全优先于普通进程的调度。 如果该进程是 SCHED_OTHER： 如果 p-\u0026gt;counter 为 0，直接返回 0。即该进程已用完时间片。 否则，返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice。 此外，在 2 的情况下，如果候选进程 p 是内核进程（无用户空间），或者 p 的用户空间与当前进程 prev 的用户空间相同，则返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice + 1。因为如果 p 正好在 prev 之后运行，它们将使用同一页表。  调度流程：schedule() #  可以将 schedule()函数大致分为以下三个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作  具体过程如下：\n初始化部分 #   current 的值保存在 prev 局部变量中, 将 prev-\u0026gt;need_resched 字段设为 0 判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。 prev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));  检查 prev 的状态，  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒:  prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。    确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。 检查候选进程 next：  如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。   检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。  进程切换之后的操作 #  执行__schedule_tail()，置 prev-\u0026gt;police 的 SCHED_YIELD 为 0。 函数返回。  如何重新分配时间片 #  在上一小节提到，当 c 为 0 时，说明可运行队列中没有实时进程，只有普通进程，且队列中所有普通进程的时间片都已用完，这时需要重新系统中所有进程的时间片（而不仅仅是可运行队列中的进程），计算方法为：\nfor_each_task(p)  p-\u0026gt;counter = (p-\u0026gt;counter \u0026gt;\u0026gt; 1) + NICE_TO_TICKS(p-\u0026gt;nice); 宏 NICE_TO_TICKS 的定义如下。以 HZ 为 200 为例，每秒中断 200 次，那么一个时钟滴答 tick 为 5ms，20 - nice 的取值为[1 ,40]，缺省为 20，将 20 右移 1 位即除以 2 为 10，10 个滴答即 50ms。当时钟频率 HZ 越高，每个滴答所代表的时间越短，NICE_TO_TICKS 分配的滴答数越多，但最大只是 20 – nice 的值左移 2 位即乘以 4，最大值为 160，仍小于实时进程的 1000。\n#if HZ \u0026lt; 200 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 2) #elif HZ \u0026lt; 400 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 1) #elif HZ \u0026lt; 800 #define TICK_SCALE(x) (x) #elif HZ \u0026lt; 1600 #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 1) #else #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 2) #endif #define NICE_TO_TICKS(nice) (TICK_SCALE(20-(nice))+1) 可以发现，经过重新计算后，那些不在可运行队列中的普通进程，会获得较高的时间配额，在将来的调度中会占一定的优势。但即使无数次更新方之后，counter 的值也不会超过两倍的 NICE_TO_TICKS，也不会超过实时进程的优先级。\nSMP 系统下的调度程序 #  Linux 为了支持对称多处理器(SMP)体系结构，必须对 Linux 的调度程序稍作修改。实际上，每个处理器运行它自己的 schedule()函数，但是，处理器间必须交换信息以提高系统性能。\n数据结构 #  schedule_data 结构体 #  如下所示，schedule_data 结构体用来很快的获得当前进程的描述符，每个 CPU 上都有一个该结构体。该结构体包含：\n 该 CPU 上现运行进程的描述符 task_struct。 现运行进程上台的时刻，即 schedule()是什么时候选 curr 作为运行进程。  struct schedule_data{  struct task_struct *curr;  unsigned long last_schedule; } struct schedule_data aligned_data[NR_CPUS]; task_struct 进程描述符 #  除了在上文提到的一些与进程调度相关的字段外，task_struct 还包含了几个与 SMP 相关的字段，包括：\n processor：表示该进程上一次运行在哪个 CPU 上。 avg_slice：表示该进程的平均时间片，即每次运行时间的期望值。  cacheflush_time 变量 #  cacheflush_time 变量表示对硬件高速缓存内容全部重写所需要花费的时间。这个值只是一个估值，大约不到 100 微秒。计算公式为：以 kHZ 为单位的 CPU 频率*以 KB 大小为单位的缓存容量/5000 在后面将看到，当现运行进程的 avg_slice – (time – last_schedule) \u0026lt; cacheflush_time，就不会执行进行的抢占。\nSMP 系统下调度流程：schedule() #  具体过程如下：\n  current 的值保存在 prev 局部变量中。prev-\u0026gt;processor 的值存放在 this_cpu 局部变量中。aligned_data[this_cpu]的值存放在 sched_data 局部变量中。将 prev-\u0026gt;need_resched 字段设为 0。\nprev = current; this_cpu = prev-\u0026gt;processor; sched_data = aligned_data[this_cpu];   判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。\nprev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));   检查 prev 的状态:\n   如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒: prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。  确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。在 goodness 函数中，检查进程的 processor 字段，并对最后在 this_cpu CPU 上执行的进程给与一定奖赏(PROC_CHANGE_PENALTY，通常为 15). 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。除此之外，做一些跟 CPU 相关的操作：   把 sched_data-\u0026gt;curr 置为 next。 next-\u0026gt;has_cpu 置为 1，next-\u0026gt;processor 置为 this_cpu。 在 t 局部变量中存放 current 时间标记寄存器的值，并执行： this_slice = t – sched_data-\u0026gt;last_schedule; sched_data-\u0026gt;last_schedule = t; prev-\u0026gt;avg_slice = (prev-\u0026gt;avg_slice + this_slice) / 2   检查候选进程 next：   如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。  检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。 进程切换之后的操作 当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 schedule()时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。如果 prev(即为 prev_new)还依然是可运行的，并且不是这个 CPU 的空任务，那么，对 prev 调用 reschedule_idle()函数。 把 prev 的 has_cpu 字段清 0。 函数返回。  SMP 系统下的 reschedule_idle() #  当进程 p 变为可运行时，执行 reschedule_idle()函数决定进程是否应该抢占某一 CPU 上的当前进程。具体过程如下：\n 如果 p 是实时进程，总会试图抢占，转到 3。 如果有一个 CPU 上的当前进程满足下列两个条件，则立即返回(不试图抢占)：  cacheflush_time 大于当前进程的平均时间片。防止高速缓存变得太“脏”。 为了存取某一临界内核数据结构，p 和当前进程都需要全局内核锁。   接下来执行 CPU 选择算法：  如果 p-\u0026gt;processor (即 p 最后运行的 CPU)是空闲的，选它。 遍历所有 CPU，对其上正在运行的任务 tsk，计算以下差值：goodness(tsk, p) - goodness(tsk, tsk), 如果这个差值为正，就选择差值最大的 CPU。   如果选择了某个 CPU，给选中的 CPU 的正在运行进程的 need_resched 字段置 1，并向这个 CPU 发处理器间中断：RESCHEDULE_VECTOR interprocessor interrupt。  O(1) 调度算法 #  O(n) 调度算法缺陷 #  Linux2.4 之前的版本，用较为简单的调度算法实现了进程调度。但是该算法存在以下问题：\n  算法复杂度问题。遍历运行队列的算法复杂度为 O(n)，意味着队列越长，选中一个进程所需要的时间就越长。此外，每次调度周期结束后，为每一个进程计算其时间片的过程太耗费时间。\n  多处理器问题。多个处理器上的进程放在一个就绪队列中，使得这个就绪队列成为临界资源，为了实现内核同步机制，需要对其上自旋锁，降低了系统效率。\n  CPU 空转问题。在 runqueue 队列中的全部进程时间片被耗尽之前，系统总会处于这样一个状态：最后的一组尚存时间片的进程分分别调度到各个 CPU 上去。我们以 4 个 CPU 为例，T0 ～ T3 分别运行在 CPU0~CPU3 上。随着系统的运行，CPU2 上的 T2 首先耗尽了其时间片，但是这时候，其实 CPU2 上也是无法进行调度的，因为遍历 runqueue 链表，找不到适合的进程调度运行，因此它只能是处于 idle 状态。也许随后 T0 和 T3 也耗尽其时间片，从而导致 CPU0 和 CPU3 也进入了 idle 状态。现在只剩下最后一个进程 T1 仍然在 CPU1 上运行，而其他系统中的处理器处于 idle 状态，白白的浪费资源。唯一能改变这个状态的是 T1 耗尽其时间片，从而启动一个重新计算时间片的过程，这时候，正常的调度就可以恢复了。随着系统中 CPU 数目的加大，资源浪费会越来越严重。\n  SMP 亲和力问题。在一个新的周期开后，runqueue 中的进程时间片都是满满的，在各个 CPU 上调度进程的时候，它可选择的比较多，再加上调度器倾向于调度上次运行在本 CPU 的进程，因此调度器有很大的机会把上次运行的进程调度到同一个处理器上。但是随着 runqueue 中的进程一个个的耗尽其时间片，cpu 可选择的余地在不断的压缩，从而导致进程执行在一个和它亲和性不大的处理器（例如上次该进程运行在 CPU0，但是这个将其调度到 CPU1 执行，但是实际上该进程和 CPU0 的亲和性更大些）。\n  实时进程调度性能问题。实时进程和普通进程挂在一个链表中，当调度实时进程的时候，我们需要遍历整个 runqueue 列表，扫描并计算所有进程的优先级，再从中选择出最终要调度的实时进程，在这过程中，一些时间片已经耗完的进程在不可能参与调度的情况下，依然会参与调度选择的过程。此外，整个 linux 内核不是抢占式内核，对于一些比较耗时的系统调用或者中断处理，必须返回用户空间才启动调度，大大降低了实时进程的调度性能。\n  交互式普通进程的调度延迟问题。O（n）并不区分交互式进程和批处理进程，它只是奖励经常睡眠的那些进程。但是有些批处理进程也属于 IO-bound 进程，例如数据库服务进程，它本身是一个后台进程，对调度延迟不敏感，但是由于它需要和磁盘打交道，因此也会经常阻塞在 disk IO 上。对这样的后台进程进行动态优先级的升高其实是没有意义的，会增大其他交互式进程的调度延迟。\n  虽然 O（n）调度器存在不少的问题，但是社区的人还是基本认可这套算法的，因 此在设计新的调度器的时候并不是完全推翻 O（n）调度器的设计，而是针对 O（n）调度器的问题进行改进。\n从以上分析中可以看出，单运行队列是影响调度性能的主要问题之一，因此改进运行队列就成为改进调度算法的入口点。\n基于此，O(1)调度器为每个 CPU 设置一个运行队列，并且为每个运行队列再设置两个队列：活动队列和时间片过期队列。每个队列中的元素以优先级再进行分类，相同优先级的进程为一个队列，最多可以有 140 个优先级。为了快速选中要运行的进程，设置以优先级为序的队列位图，位图的每一位对应一个队列，只要队列中有一个可运行进程，该位置 1，否则置 0。这样，无需遍历所有队列，而只要遍历位图，找到有可运行进程的队列，该队列的第一个进程就是被选中的进程。该算法的复杂度为 O(1). 如图所示：\n通过将单链表变成多个链表，可以解决上述大部分问题：\n 算法复杂度问题：O(1)调度器算法通过优先级位图，以及活动队列与过期队列指针交换，实现了 O(1)的复杂度，而不是遍历运行队列，并重新计算所有进程的时间片。 多处理器问题：由于每个 CPU 都有一个运行队列，因此 O(1)调度器就不需要全局运行队列的自旋锁，而只需要把这个自旋锁放入到每个 CPU 的运行队列数据结构中，通过把一个大锁细分成小锁，可以大大降低调度延迟，提升系统响应时间。。 CPU 空转问题：O(1)调度器每个 CPU 都有一个运行队列，当一个进程的时间片耗尽，在被移动到过期数组之前，会重新计算其时间片，而不是等到一个调度周期结束再重新计算进程时间片，因此解决了 CPU 空转问题。 SMP 亲和力问题：O(1)调度器设置了较为合理的负载均衡算法，只有在需要平衡任务队列大小时才在 CPU 之间移动进程。 实时进程与交互式调度性能问题：为了提高交互时进程和实时进程的响应时间，当前进程的时间片为 0 时，判断当前进程的类型，如果时交互式进程或实时进程，则重置其时间片并重新插入活动队列，否则插入过期队列，这样交互式进程和实时进程总能优先获得 CPU。然而当这些进程已经占用 CPU 时间超过一个固定值后，也会被移到过期队列中，避免其他进程产生饥饿现象。  数据结构 #  runqueue 数据结构 #  runqueue 可执行队列是调度程序中最基本的数据结构。定义于 kernel/sched.c 中。如上所述，每个 CPU 包含一个可执行队列；每个就绪进程都唯一地归属于某一个可执行队列。此外，可执行队列中还包含着每个 CPU 的调度信息。其包含的字段如下图所示：\n优先级数组 #  如上所述，每个运行队列有活动队列和过期队列两个优先级数组，每个数组是一个 prio_array 类型的结构体。优先级数组使得该调度算法复杂度为 O(1)。\n 计数器 nr_active 是一个计数器，保存可运行进程数目。 bitmap 是优先级位图数组。其中 BITMAP_SIZE 是位图数组的大小，类型为 unsigned long 长整型，长 32 位，每一位包含一个优先级，140 个优先级需要 5 个长整型数表示。bitmap 一开始所有的位都被置 0。当某个进程状态变为 TASK_RUNNING 时，对应的位被置 1。这样，查找系统中最高的优先级就变成了查找位图中被设置的第一个位。 queue 是优先级链表数组，一个链表对应一种优先级。每个链表包含了该 CPU 上相应优先级的全部可运行进程。其中 MAX_PRIO 定义了系统拥有的优先级个数，默认为 140。  进程描述符 #  与 linux 2.4 的进程描述符有些差异，其与调度相关的字段如下：\n进程的优先级 #  普通进程 #  静态优先级 #  普通进程的静态优先级保存在 static_prio 成员中，取值范围是 100（优先级最高）～ 139（优先级最低），分别对应 nice 值的-20 ～ 19。静态优先级本质上决定了进程的基本时间片，对应公式如下：\n由该公式得到一些普通进程优先级的典型值如下：\n动态优先级 #  在实际调度的时候使用的是动态优先级。普通进程的动态优先级保存在进程描述符的 prio 成员中。取值范围是 100（优先级最高）～ 139（优先级最低），和静态优先级一致。动态优先级根据以下公式得出：\n其中，bonus 取值范围 0~10，值小于 5 表示惩罚，大于 5 表示奖赏。bonus 的取值与进程的平均睡眠时间相关，如下表。需要说明的是，平均睡眠时间是进程在睡眠状态所消耗的平均纳秒数，但不是对过去时间的求平均值操作。例如，在 TASK_INTERRUPTIBLE 状态与在 TASK_UNINTERRUPTIBLE 状态所计算出的平均睡眠时间是不同的。而且，平均睡眠时间永远不会大于 1s.\n平均睡眠时间也被调度程序用来确定一个给定进程是交互式进程还是批处理进程。如果满足下列公式，则被看作是交互式进程：\n其中，静态优先级/4-28 被称为交互时的 δ。可以推出，高优先级的进程比低优先级的进程更容易成为交互式进程。例如，最高静态优先级(100)的进程，当他的 bonus 值超过 2，即睡眠时间超过 200ms 时，就被看作是交互式进程。\n实时进程 #  实时进程的实时优先级，存在进程描述符的 rt_priority 成员中，取值范围是 1（优先级最低）～ 99（优先级最高）。需要注意的是，当系统调用 nice()和 setpriority()用于基于时间片轮转的实时进程时，不改变实时进程的优先级，而会改变其基本时间片的长度。也就是说，基于时间片轮转的实时进程的基本时间片的长度与实时进程的优先级无关，而依赖于进程的静态优先级，它们的关系同普通进程下的公式一样。\n普通进程采用复杂的公式计算动态优先级，而实时进程不计算动态优先级，保证了给定优先级别的实时进程总能抢占优先级比它低的进程。\n调度程序所使用的函数 #  调度程序使用几个函数来完成调度工作，其中最重要的函数说明如下：\nscheduler_tick() #  每次时钟节拍到来时，scheduler_tick()被调用，执行以下步骤：\n 把转换为纳秒的 TSC 的当前值存到本地运行队列的 timestamp_last_tick 字段。这个时间戳是从 sched_clock()函数得到。 检查当前进程是不是本地 CPU 的 swapper 进程，如果是，则检查本地运行队列除了 swagger 进程外，是不是还有另外的可运行进程，如果是，就设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。之所以会出现这种情况，是因为如果内核支持超线程技术，那么只要一个逻辑 CPU 运行队列中的所有进程都比另一个逻辑 CPU 上已经在执行的进程优先级低得多，而两个逻辑 CPU 是对应同一个物理 CPU 的，因此，前一个逻辑 CPU 就可能空闲，即使它的运行队列中也有可运行的进程。执行完上述检查后，直接跳到第 7 步，因为不需要更新 swagger 进程的时间片。 检查 current-\u0026gt;array 是否指向本地运行队列的活动链表，如果不是，说明进程已经过期但还没有被替换，则设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。然后直接跳到第 7 步。 获得 this_rq()-\u0026gt;lock 自旋锁 根据进程不同类型执行不同操作：    如果当前进程是 FIFO 的实时进程，则什么也不做，跳到 6。\n  当前进程是基于时间片轮转的实时进程：递减当前进程时间片，如果时间片已经用完，则：\n 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice= 0。该字段是在 fork()系统调用服务例程中的 copy_process()中设置，并在进程的第一个时间片用完时清 0。 调用 set_tsk_need_resched()设置进程的 TIF_NEED_RESCHED 字段。 iv. 把当前进程移到当前的运行队列尾部。    当前进程是普通进程：递减当前进程时间片，如果时间片已经用完：\n 将当前进程从活动队列(this_rq()-\u0026gt;active)中移除。 调用 set_tsk_need_resched() 设置进程的 TIF_NEED_RESCHED 字段。 更新当前进程的动态优先级。current-\u0026gt;prio = effective_prio(current). 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice 清 0。 如果 this_rq()-\u0026gt;expired_timestamp 字段为 0（表示过期队列为空），把当前进程的时钟节拍 jiffies 赋值给 this_rq()-\u0026gt;expired_timestamp。 把当前进程插入活动队列或过期队列：  if (!TASK_INTERACTIVE(current) || EXPIRED_STARVING(this_rq()))  enqueue_task(current, this_rq()-\u0026gt;expired); else  enqueue_task(current, this_rq()-\u0026gt;active); 其中, TASK_INTERACTIVE 宏用于识别一个进程是不是交互式进程。EXPIRED_STARVING 宏负责检查过期队列中的进程是否处于饥饿状态：如果已经有相对较长时间没有发生数组切换了，那么再把当前的进程放置到活动数组，则会加重过期队列中进程的饥饿状态。\n否则，如果时间片没有用完，检查当前进程的剩余时间片是否太长：\nif (TASK_INTERACTIVE(p) \u0026amp;\u0026amp; !((task_timeslice(p) – p-\u0026gt;time_slice) %TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;time_slice \u0026gt;= TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;array == rq-\u0026gt;active)) {  list_del(\u0026amp;current-\u0026gt;run_list);  list_add_tail(\u0026amp;current -\u0026gt; run_list, this_rq()-\u0026gt;active-\u0026gt;queue+current-\u0026gt;prio);  set_tsk_need_resched(p); } 其中，宏 TIMESLICE_GRANULARITY 产生两个数的乘积给当前进程的 bonus，其中一个数为系统中 CPU 的数量，另一个为成比例的常量。基本上，具有高静态优先级的交互式进程，其时间片被分成大小为 TIMESLICE_GRANULARITY 的几个片段，以使这些进程不会独占 CPU。\n  释放 this_rq()-\u0026gt;lock 自旋锁。 调用 rebalance_tick()函数，保证不同 CPU 的运行队列包含数量基本相同的可运行进程。  从第 5 步中可以看出，对于 O(1)调度器，时间片的重新赋值是分散处理的，在各个进程耗尽其时间片之后立刻进行的。修正了 O(n)调度器一次性的遍历系统所有进程，重新为时间片赋值的过程。\n唤醒：try_to_wake_up() #  该函数通过把进程状态设置为 TASK_RUNNING，并调用 activate_task()函数将此进程放入对应的可运行队列中来唤醒睡眠或停止的进程。\n该函数接受的参数有：\n 被唤醒进程的描述符指针 p. 可以被唤醒的进程状态掩码(state)。 一个标志(syn)，用来禁止被唤醒的进程抢占本地 CPU 上正在运行的进程。  该函数执行以下操作：\n 禁本地中断，并获得最后执行该进程的 CPU 的运行队列的锁。 检查进程状态 p-\u0026gt;state == state。如果不是，直接跳到 9 终止函数。 如果 p-\u0026gt;arrray != NULL ,说明该进程已经属于某个运行队列，跳到 8. 确定目标 CPU：  如果有空闲的 CPU，就选空闲的 CPU。 如果先前执行进程的 CPU 的工作量远小于本地 CPU 的工作量，选前者。 如果进程最近被执行过，就选这个老的运行队列。 如果把进程迁移到本地 CPU 可以缓解 CPU 之间的不平衡，则选本地 CPU。   如果进程处于 TASK_UNINTERRUPTIBLE 状态，则递减目标运行队列的 nr_uninterruptible 字段，并把 p-\u0026gt;activated 字段置为-1。 调用 activate_task()函数，执行：  调用 sched_clock()获取以纳秒为单位的当前时间戳。如果目标 CPU 不是本地 CPU，就要补偿本地时钟中断的偏差：now=(shced_clock()–this_rq()-\u0026gt;timesamp_last_tick)+rq-\u0026gt;timestamp_last_tick 调用 recalc_task_prio()。 设置 p-\u0026gt;activated 字段的值。 使用 now 设置 p-\u0026gt;timestamp 字段。 把进程描述符插入活动队列，且 rq-\u0026gt;nr_running++。   如果目标 CPU 不是本地 CPU，或者没有设置 sync 标志，则，如果该进程优先级更高 p-\u0026gt;prio \u0026gt; rq-\u0026gt;curr-\u0026gt;prio，就调用 resched_task()抢占 rq-\u0026gt;curr。  单处理器系统，设置 rq-\u0026gt;curr 进程的 TIF_NEED_RESCHED 标志。 多处理器系统，如果 TIF_NEED_RESCHED 旧值为 0，且目标 CPU 没有轮询进程 TIF_NEED_RESCHED 标志的值，则发送处理器间中断 IPI，强制目标 CPU 重新调度。   把当前进程 p-\u0026gt;state 字段设为 TASK_RUNNING。 开 rq 运行队列的锁，打开本地中断。 如果成功唤醒返回 1，否则返回 0.  计算动态优先级：recalc_task_prio() #  recalc_task_prio() 函数更新进程的平均睡眠时间和动态优先级。\n该函数接受的参数有：\n 进程描述符指针 p。 当前时间戳 now。  该函数执行以下操作：\n 把 min(now – p-\u0026gt;timestamp, 109)的结果赋值给局部变量 sleep_time，表示进程消耗在睡眠状态的纳秒数。如果超过 1 秒，就设为 1 秒. 如果 sleep_time 不大于 0，直接跳到 8. 检查进程是不是内核线程、进程是否从 TASK_UNINTERRUPTIBLE 状态（即 p-\u0026gt;activated 为-1）被唤醒、进程连续睡眠的时间是否超过给定的睡眠时间期限。如果这三个条件都满足，把 p-\u0026gt;sleep_avg 字段设置位相当于 900 个时钟节拍的值（用最大平均睡眠时间减去一个标准进程的基本时间片长度获得的一个经验值）。然后跳到 8. 计算进程原来的平均睡眠时间的 bonus 值。如果 10-bonus\u0026gt;0,则把 sleep_time 乘以 10-bonus。所以原来的 p-\u0026gt;sleep_avg 越小，bonus 值越小，10-bonus 越大，sleep_time 越大，最终的 p-\u0026gt;sleep_avg 增加的就越快。 如果进程处于 TASK_UNINTERRUPTIBLE 状态而且不是内核线程：  检查平均睡眠时间 p-\u0026gt;sleep_avg 是否大于等于进程的睡眠时间极限。如果是，把 sleep_time 置为 0，直接跳到 6. 如果 sleep_time + p-\u0026gt;sleep_avg 大于等于睡眠时间极限，把 p-\u0026gt;sleep_avg 设为睡眠时间极限并把 sleep_time 置为 0 通过对进程平均睡眠时间的轻微限制，函数不会对睡眠时间很长的批处理进程给与过多的奖赏。   把 sleep_time 加到进程的平均睡眠时间 p-\u0026gt;sleep_avg 上。 检查 p-\u0026gt;sleep_avg 是否超过 1000 个时钟节拍，如果是，就置为 1000 个时钟节拍。 更新进程的动态优先级。p-\u0026gt;prio = effective_prio(p).  可以看到，在评估用户交互指数上，O(n)调度器仅仅考虑了睡眠进程的剩余时间片，而 O(1)调度器的“平均睡眠时间”算法考虑了更多的因素：在 cpu 上的执行时间、在 runqueue 中的等待时间、睡眠时间、睡眠时候的进程状态（是否可被信号打断），什么上下文唤醒（中断上下文唤醒还是在进程上下文中唤醒），因此 O(1)调度器更好的判断了进程是否属于交互式进程。\n调度流程： #  schedule() 与 O(n) 调度器类似，可以将 schedule() 函数大致分为以下四个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作 具体过程如下： 初始化部分 禁用内核抢占。current 的值保存在 prev 局部变量中，本地 CPU 的运行队列保存在 rq 局部变量中。 preempt_disable(); prev = current; rq = this_rq();  保证 prev 不占用大内核锁。通过进程切换会自动释放和重新获取大内核锁。 if (prev-\u0026gt;lock_dept \u0026gt;= 0)  up(\u0026amp;kernel_sem);  计算 prev 所用的 CPU 时间片长度： now = sched_clock(); run_time = now – prev-\u0026gt;timesamp; if (run_time \u0026gt; 1000000000)  run_time = 1000000000 run_time /= (CURRENT_BONUS(PREV) ? : 1) run_time 用来限制进程对 CPU 的使用，最多 1 秒。不过，当进程有较长睡眠时间时，CURRENT_BONUS()返回值越大，run_time 就会被降低。这是对较长平均睡眠时间的奖赏。 关本地中断，获得运行队列的自旋锁：spin_lock_irq(\u0026amp;rq-\u0026gt;lock) 检查 prev 是不是一个正在被终止的进程： if (prev-\u0026gt;flags \u0026amp; PF_DEAD)  prev-\u0026gt;state = EXIT_DEAD;  检查 prev 的状态，如果不是 TASK_RUNNING 可运行状态，而且没有在内核态被抢占：  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就让其变为可运行状态：prev-\u0026gt;state = TASK_RUNNING 以唤醒这个进程。 否则，调用 deactivate_task()函数从运行队列中删除 prev 进程,。同时，如果该进程状态是 TASK_UNINTERUPTIBLE，则 rq-\u0026gt;nr_uniterruptible++.  rq-\u0026gt;nr_running--; dequeue_task(p, p-\u0026gt;array); p-\u0026gt;array = NULL;  检查运行队列中剩于的可运行进程数。如果有可运行进程，但是当前内核支持超线程技术，且可运行进程比在相同物理 CPU 的某个逻辑 CPU 上运行的兄弟进程优先级低，p-\u0026gt;sleep_avg直接去执行 swapper 进程。 如果没有可运行进程，函数调用 idle_balance()，从其他 CPU 迁移一些可运行进程到本地队列中。如果本地队列还是没有可运行进程，就重新调度空闲 CPU 的可运行进程。如果还是没有，则直接去执行 swapper 进程。 到这里运行队列中一定有可运行进程。检查运行队列中是否至少有一个进程是活动的(rq-\u0026gt;active-\u0026gt;nr_active\u0026gt;0)。如果没有，交换活动队列和过期队列的指针。  确定优先级最高的进程 next #   在优先级数组中查找第一个非 0 的位图对应的链表的第一个进程描述符，并赋值给 next。\n  检查 next-\u0026gt;activate 字段，该字段编码值表示进程在被唤醒时的状态，如下表：\n如果 next 是一个普通进程，并且 activate 为 1 或 2，就把自从进程插入运行队列开始所经过的纳秒数加到进程的平均睡眠时间。但是 1 和 2 的情况还是有区别，在 2 的情况下，增加全部运行队列等待时间，在 1 的情况下，只增加等待时间的部分。这是因为交互式进程更可能被异步事件(如键盘)而不是同步事件唤醒。\nif (next-\u0026gt;prio \u0026gt;= 100 \u0026amp;\u0026amp; next-\u0026gt; activate \u0026gt; 0){  unsigned long long delta = now – next-\u0026gt;timestamp;  if ( next-\u0026gt; activate == 1)  delta = (delta * 38) / 128;  array = next-\u0026gt;array;  dequeue_task(next, array);  recalc_task_prio(next, next-\u0026gt;timestamp + delt- ;  enqueue_task(next, array); } next-\u0026gt; activate = 0;   完成进程切换 #  如果最终的候选进程就是当前进程，释放自旋锁，不做进程切换，直接结束。 否则执行进程切换： next-\u0026gt;timestamp = now; rq-\u0026gt;nr_switches ++; rq-\u0026gt;current = next; prev = context_switch(rq, prev, next) 其中 context_switch()函数建立 next 的地址空间。  如果 next 是内核进程，则借用 prev 的 active_mm。 if ( ! next_mm ){ next-\u0026gt;active_mm = prev-\u0026gt;active_mm; atomic_inc(\u0026amp;prev-\u0026gt;active_mm-\u0026gt;mm_count); enter_lazy_tlb( prev-\u0026gt;active_mm, next) }  如果 next 是普通进程，则执行 switch_mm 切换用户空间，把虚拟内存从上一个进程映射切换到新进程中。 if ( next_mm ){ switch_mm( prev-\u0026gt;active_mm, next-\u0026gt;mm, next); }    如果 prev 是内核进程或正在退出的进程： if ( ! prev_mm ){  rq-\u0026gt;prev_mm = prev-\u0026gt;active_mm;  prev-\u0026gt;active_mm = NULL; }  调用 switch_to()进行真正的进程切换，从上一个进程的处理器状态切换到新进程的处理器状态，包括保存、恢复栈信息和寄存器信息。 switch_to( prev, next, prev);   进程切换之后的操作 #   当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 p-\u0026gt;sleep_avg时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。进程切换后的第一部分指令是：\nbarrier(); finish_task_switch( prev); 其中 finish_task_switch(prev) 函数如下：\nmm = this_rq()-\u0026gt;prev_mm; this_rq()-\u0026gt;prev_mm = NULL; prev_task_flags = prev-\u0026gt;flags; spin_unlock_irq(\u0026amp; this_rq()-\u0026gt;lock); if (mm)  mmdrop(mm) if (prev_task_flags \u0026amp; PF_DEAD)  put_task_struct( prev); 其中 mmdrop()减少内存描述符的使用计数器。如果减到了 0，释放与页表相关的所有描述符和虚拟存储区。put_task_struct()释放进程描述符使用计数器，并撤销所有其余对该进程的引用。\n  p-\u0026gt;sleep_avg函数最后一部分代码如下。包括在需要的时候重新获得大内核锁，重新启用内核抢占，并检查是否一些其他的进程已经设置了当前进程的 TIF_NEED_RESCHED。如果是，则整个 p-\u0026gt;sleep_avg函数重新执行，否则函数结束。\nprev = current; if (prev-\u0026gt;lock_depth \u0026gt;= 0)  __reacquire_kernel_lock(); preempt_enable_no_resched(); if (test_bit(TIF_NEED_RESCHED, \u0026amp;current_thread_info() -\u0026gt; flags))  goto need_resched; return;   多处理器系统中运行队列的平衡 #  从 Linux2.6.7 版本开始，Linux 提出一种基于“调度域”概念的复杂的运行队列平衡算法，从而能够容易适应各种已有的多处理器体系结构。并提供了以下函数：\n  rebalance_tick()函数会在每一次时钟节拍到来时由 scheduler_tick()调用，负责周期性、在需要的时候调用 load_balance()函数。\n  load_balance()函数检查调度域是否处于严重的不平衡状态，如果是，将会尝试调用 move_task()函数把一些进程从一个运行队列迁移到另一个运行队列。\n  move_task()函数负责把进程从源运行队列迁移到本地运行队列。\n  其中比较重要的 load_balance()函数可简单描述为如下操作：\n1、 调用 find_busiest_queue()，找到最繁忙的可运行队列，即该队列中的进程数目最多。如果没有哪个可运行队列中进程的数目比当前队列中的数目多 25%或更多，就返回 NULL，并且 load_balance()函数也返回。否则返回最繁忙的可运行队列。\n2、 从最繁忙的运行队列中选择一个优先级数组以便抽取进程，最好是过期数组，因为那里面的进程已经相当较长一段时间没有运行了，很可能不在 CPU 的高速缓存中。如果过期数组为空，那就只能选活动数组。\n3、 找到含有进程并且优先级最高的链表。\n4、 分析找到的所有这些优先级相同的进程，选择一个不是正在执行，也不会因为 CPU 相关性而不可移动，并且不在高速缓存中的进程。如果有进程满足以上条件，调用 move_task()将其从最繁忙的队列迁移到当前队列。\n5、 只要可运行队列之间仍然不平衡，就重复上面两个步骤，最终达到平衡。此时，解除对当前运行队列的锁定，从 load_balance()返回。\n抢占 #  用户抢占 #  用户抢占是指在内核即将返回用户空间的时候，如果 need_resched 标志被设置，会导致 p-\u0026gt;sleep_avg被调用，此时就发生了用户抢占。与延迟调用小节描述的一样，用户抢占在从系统调用或中断处理程序返回用户空间时发生。\n内核抢占 #  在不支持内核抢占的内核中，内核代码可以一直执行，直到完成返回用户空间或者明显的阻塞为止。也就是说，调度程序没办法在一个内核任务正在执行的时候发起调度。在 2.6 版本的内核中，引入了内核抢占能力，只要重新调度是安全的，即，只要没有持有锁，那么正在执行的代码就是可重新导入的，内核就可以在任何时间抢占正在执行的任务。\n为了支持内核抢占，为每个进程的 thread_info 引入了 preempt_count 计数器。该计数器初始值为 0，每当使用锁的时候加 1，释放锁的时候减 1.当该值为 0 时，表示内核可以抢占。\n因此，从中断返回内核空间的时候，内核会检查 need_resched 和 preempt_count 的值。如果 need_resched 被设置，且 preempt_count 为 0，说明有一个更为重要的任务需要执行并且可以安全的抢占，此时，调度程序就会被调用。此外，如果当前进程持有的所有锁都被释放了，此时会去检查 need_resched 是否被设置，如果是就调用调度程序。\n如果内核中的进程被阻塞了，或它显示地调用 p-\u0026gt;sleep_avg，内核抢占就显式地发生，这种形式的内核抢占一直都是支持的，因为无需额外的逻辑来保证内核可以安全的被抢占。\n楼梯调度算法与 RSDL 调度算法 #  O(1)调度器区分交互式进程和批处理进程的算法与以前虽大有改进，但仍然在很多情况下会失效。有一些著名的程序(如 fiftyp.c, thud.c, chew.c, ring-test.c)总能让该调度器性能下降，导致交互式进程反应缓慢。\n为了解决这些问题，大量难以维护和阅读的复杂代码被加入 Linux2.6.0 的调度器模块，虽然很多性能问题因此得到了解决，可是另外一个严重问题始终困扰着许多内核开发者。那就是代码的复杂度问题。这些不足催生了 Con Kolivas 的楼梯调度算法 SD，为调度器设计提供了一个新的思路。之后的 RSDL 和 CFS 都基于 SD 的许多基本思想。\n楼梯调度算法 #  O(1)调度器算法的主要复杂性来自动态优先级的计算，调度器根据平均睡眠时间和一些很难理解的经验公式来修正进程的优先级以及区分交互式进程。这样的代码很难阅读和维护。\n楼梯调度算法(staircase scheduler)抛弃了动态优先级的概念，而采用了一种完全公平的思路。其思路虽然简单，但是实验证明它对应交互式进程的响应比 O(1)调度器更好，而且极大地简化了代码。\n和 O(1)调度器一样，楼梯算法也同样为每一个优先级维护一个进程队列，并将这些队列组织在 active 数组中。当选取下一个被调度进程时，SD 算法也同样从 active 数组中直接读取。 与 O(1)算法不同在于，当进程用完了自己的时间片后，并不是被移到 expire 数组中。而是被加入 active 数组的低一优先级列表中，即将其降低一个级别。不过请注意这里只是将该任务插入低一级优先级任务列表中，任务本身的优先级并没有改变。当时间片再次用完，任务被再次放入更低一级优先级任务队列中。就像一部楼梯，任务每次用完了自己的时间片之后就下一级楼梯。\n任务下到最低一级楼梯时，如果时间片再次用完，它会回到初始优先级的下一级任务队列中。比如某进程的优先级为 1，当它到达最后一级台阶 140 后，再次用完时间片时将回到优先级为 2 的任务队列中，即第二级台阶。不过此时分配给该任务的 time_slice 将变成原来的 2 倍。比如原来该任务的时间片 time_slice 为 10ms，则现在变成了 20ms。基本的原则是，当任务下到楼梯底部时，再次用完时间片就回到上次下楼梯的起点的下一级台阶。并给予该任务相同于其最初分配的时间片。总结如下：设任务本身优先级为 P，当它从第 N 级台阶开始下楼梯并到达底部后，将回到第 N+1 级台阶。并且赋予该任务 N+1 倍的时间片。\n以上描述的是普通进程的调度算法，实时进程还是采用原来的调度策略，即 FIFO 或者 Round Robin。\n楼梯算法能避免进程饥饿现象，高优先级的进程会最终和低优先级的进程竞争，使得低优先级进程最终获得执行机会。\n对于交互式应用，当进入睡眠状态时，与它同等优先级的其他进程将一步一步地走下楼梯，进入低优先级进程队列。当该交互式进程再次唤醒后，它还留在高处的楼梯台阶上，从而能更快地被调度器选中，加速了响应时间。\n从实现角度看，SD 基本上还是沿用了 O(1)的整体框架，只是删除了 O(1)调度器中动态修改优先级的复杂代码；还淘汰了 expire 数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。\nRSDL 调度算法 #  RSDL（The Rotating Staircase Deadline Schedule）也是由 Con Kolivas 开发的，它是对 SD 算法的改进。核心的思想还是“完全公平”。没有复杂的动态优先级调整策略。\nRSDL 重新引入了 expire 数组。它为每一个优先级都分配了一个 “组时间配额”， 我们将组时间配额标记为 Tg；同一优先级的每个进程都拥有同样的\u0026quot;优先级时间配额\u0026quot;，本文中用 Tp 表示，以便于后续描述。\n当进程用完了自身的 Tp 时，就下降到下一优先级进程组中。这个过程和 SD 相同，在 RSDL 中这个过程叫做 minor rotation。请注意 Tp 不等于进程的时间片，而是小于进程的时间片。下图表示了 minor rotation。进程从 priority1 的队列中一步一步下到 priority140 之后回到 priority2 的队列中，这个过程如下图左边所示，然后从 priority 2 开始再次一步一步下楼，到底后再次反弹到 priority3 队列中。\n在 SD 算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得 CPU。因此低优先级进程的等待时间无法确定。RSDL 中，当高优先级进程组用完了它们的 Tg(即组时间配额)时，无论该组中是否还有进程 Tp 尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是 RSDL 中 Deadline 代表的含义。 进程用完了自己的时间片 time_slice 时（下图中 T2），将放入 expire 数组中它初始的优先级队列中(priority 1)。\n当 active 数组为空，或者所有的进程都降低到最低优先级时就会触发 major rotation：。Major rotation 交换 active 数组和 expire 数组，所有进程都恢复到初始状态，再一次从新开始 minor rotation 的过程。\n和 SD 同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为 minor rotation 而降到了低优先级进程队列中。当它重新进入 RUNNING 状态时，就获得了相对较高的优先级，从而能被迅速响应。\nCFS 完全公平调度算法 #  CFS 是最终被内核采纳的调度器。它从 RSDL/SD 中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS 的算法和实现都相当简单，众多的测试表明其性能也非常优越。\n按照作者 Ingo Molnar 的说法：\u0026ldquo;CFS 百分之八十的工作可以用一句话概括：CFS 在真实的硬件上模拟了完全理想的多任务处理器\u0026rdquo;。在“完全理想的多任务处理器“下，每个进程都能同时获得 CPU 的执行时间。当系统中有两个进程时，CPU 的计算时间被分成两份，每个进程获得 50%。然而在实际的硬件上，当一个进程占用 CPU 时，其它进程就必须等待。这就产生了不公平。\n假设 runqueue 中有 n 个进程，当前进程运行了 10ms。在“完全理想的多任务处理器”中，10ms 应该平分给 n 个进程(不考虑各个进程的 nice 值)，因此当前进程应得的时间是(10/n)ms，但是它却运行了 10ms。所以 CFS 将惩罚当前进程，使其它进程能够在下次调度时尽可能取代当前进程。最终实现所有进程的公平调度。下面将介绍 CFS 实现的一些重要部分，以便深入地理解 CFS 的工作原理[5]。\nCFS 如何选取下一个要调度的进程 #  CFS 抛弃了 active/expire 数组，而使用红黑树选取下一个被调度进程。所有状态为 RUNABLE 的进程都被插入红黑树。在每个调度点，CFS 调度器都会选择红黑树的最左边的叶子节点作为下一个将获得 cpu 的进程。\ntick 中断 #  在 CFS 中，tick 中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记 need_resched 标志，中断返回时就会调用 scheduler()完成进程切换。否则当前进程继续占用 CPU。从这里可以看到 CFS 抛弃了传统的时间片概念。Tick 中断只需更新红黑树，以前的所有调度器都在 tick 中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。\n红黑树键值计算 #  理解 CFS 的关键就是了解红黑树键值的计算方法。该键值由三个因子计算而得：一是进程已经占用的 CPU 时间；二是当前进程的 nice 值；三是当前的 cpu 负载。\n进程已经占用的 CPU 时间对键值的影响最大，其实很大程度上我们在理解 CFS 时可以简单地认为键值就等于进程已占用的 CPU 时间。因此该值越大，键值越大，从而使得当前进程向红黑树的右侧移动。另外 CFS 规定，nice 值为 1 的进程比 nice 值为 0 的进程多获得 10%的 CPU 时间。在计算键值时也考虑到这个因素，因此 nice 值越大，键值也越大。\n在本文中，我们将为每个进程维护的变量称为进程级变量，为每个 CPU 维护的称作 CPU 级变量，为每个 runqueue 维护的称为 runqueue 级变量。\nCFS 为每个进程都维护两个重要变量：fair_clock 和 wait_runtime。进程插入红黑树的键值即为 fair_clock – wait_runtime。\n fair_clock 从其字面含义上讲就是一个进程应获得的 CPU 时间，即等于进程已占用的 CPU 时间除以当前 runqueue 中的进程总数； wait_runtime 是进程的等待时间。它们的差值代表了一个进程的公平程度。该值越大，代表当前进程相对于其它进程越不公平。  对于交互式任务，wait_runtime 长时间得不到更新，因此它能拥有更高的红黑树键值，更靠近红黑树的左边。从而得到快速响应。 红黑树是平衡树，调度器每次总最左边读出一个叶子节点，该读取操作的时间复杂度是 O(LgN)。\n调度器管理器 #  为了支持实时进程，CFS 提供了调度器模块管理器。各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块。2.6.23 中，CFS 实现了两个调度算法，CFS 算法模块和实时调度模块。对应实时进程，将使用实时调度模块。对应普通进程则使用 CFS 算法。Ingo Molnar 还邀请 Con Kolivas 可以将 RSDL/SD 写成一个调度算法模块。\nCFS 源代码分析 #  每次时钟中断会调用 scheduler_tick()函数。它首先更新 runqueue 级变量 clock；然后调用 CFS 的 tick 处理函数 task_tick_fair()。task_tick_fair 主要工作是调用 entity_tick()。函数 entiry_tick 源代码如下：\nstatic void entity_tick(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  struct sched_entity _next;  dequeue_entity(cfs_rq, curr, 0);  enqueue_entity(cfs_rq, curr, 0);  next = **pick_next_entity(cfs_rq);  if (next == curr)  return;  __check_preempt_curr_fair(cfs_rq, next, curr,  sched_granularity(cfs_rq)); } 首先调用 dequeue_entity()函数将当前进程从红黑树中删除，再调用 enqueue_entity()重新插入。这两个动作就调整了当前进程在红黑树中的位置。_pick_next_entity()返回红黑树中最左边的节点，如果不再是当前进程，就调用_check_preempt_curr_fair。该函数设置调度标志，当中断返回时就会调用 p-\u0026gt;sleep_avg进行调度。 函数 enqueue_entity()的源码如下:\nenqueue_entity(struct cfs_rq _cfs_rq, struct sched_entity _se, int wakeup) {  update_curr(cfs_rq);  if (wakeup)  enqueue_sleeper(cfs_rq, se);  update_stats_enqueue(cfs_rq, se);  __enqueue_entity(cfs_rq, se); } 它的第一个工作是更新调度信息。然后将进程插入红黑树中。其中 update_curr()函数是核心。完成调度信息的更新:\nstatic void update_curr(struct cfs_rq _cfs_rq) { struct sched_entity _curr = cfs_rq_curr(cfs_rq); unsigned long delta_exec; if (unlikely(!curr)) return; delta_exec = (unsigned long)(rq_of(cfs_rq)-\u0026gt;clock - curr-\u0026gt;exec_start); curr-\u0026gt;delta_exec += delta_exec; if (unlikely(curr-\u0026gt;delta_exec \u0026gt; sysctl_sched_stat_granularity)) { __update_curr(cfs_rq, curr); curr-\u0026gt;delta_exec = 0; } curr-\u0026gt;exec_start = rq_of(cfs_rq)-\u0026gt;clock; } 该函数首先统计当前进程所获得的 CPU 时间，rq_of(cfs_rq)-\u0026gt;clock 值在 tick 中断中被更新，curr-\u0026gt;exec_start 就是当前进程开始获得 CPU 时的时间戳。两值相减就是当前进程所获得的 CPU 时间。将该变量存入 curr-\u0026gt;delta_exec 中。然后调用__update_curr():\n__update_curr(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  unsigned long delta, delta_exec, delta_fair, delta_mine;  struct load_weight _lw = \u0026amp;cfs_rq-load;  unsigned long load = lw-\u0026gt;weight;  delta_exec = curr-\u0026gt;delta_exec;  schedstat_set(curr-\u0026gt;exec_max, max((u64)delta_exec, curr-\u0026gt;exec_max));  curr-\u0026gt;sum_exec_runtime += delta_exec;  cfs_rq-\u0026gt;exec_clock += delta_exec;  if (unlikely(!load)) return;  delta_fair = calc_delta_fair(delta_exec, lw);  delta_mine = calc_delta_mine(delta_exec, curr-\u0026gt;load.weight, lw);  if (cfs_rq-\u0026gt;sleeper_bonus \u0026gt; sysctl_sched_min_granularity) {  delta = min((u64)delta_mine, cfs_rq-\u0026gt;sleeper_bonus);  delta = min(delta, (unsigned long)((long)sysctl_sched_runtime_limit - curr-\u0026gt;wait_runtime));  cfs_rq-\u0026gt;sleeper_bonus -= delta;  delta_mine -= delta;  }  cfs_rq-\u0026gt;fair_clock += delta_fair;  add_wait_runtime(cfs_rq, curr, delta_mine - delta_exec); } __update_curr()的主要工作就是更新前面提到的 fair_clock 和 wait_runtime。这两个值的差值就是后面进程插入红黑树的键值。变量 Delta_exec 保存了前面获得的当前进程所占用的 CPU 时间。函数 calc_delta_fair()根据 cpu 负载（保存在 lw 变量中），对 delta_exec 进行修正，然后将结果保存到 delta_fair 变量中，随后将 fair_clock 增加 delta_fair。函数 calc_delta_mine()根据 nice 值（保存在 curr-\u0026gt;load.weight 中）和 cpu 负载修正 delta_exec，将结果保存在 delta_mine 中。根据源代码中的注释，delta_mine 就表示当前进程应该获得的 CPU 时间。\n随后将 delta_fair 加给 fair_clock 而将 delta_mine-delta_exec 加给 wait_runtime。函数 add_wait_runtime 中两次将 wait_runtime 减去 delta_mine-delta_exec。由于 calc_delt_xx()函数对 delta_exec 仅做了较小的修改，为了讨论方便，我们可以忽略它们对 delta_exec 的修改。最终的结果可以近似看成 fair_clock 增加了一倍的 delta_exec，而 wait_runtime 减小了两倍的 delta_exec。因此键值 fair_clock-wait_runtime 最终增加了一倍的 delta_exec 值。键值增加，使得当前进程再次插入红黑树中就向右移动了。\nCFS 小结 #  以上的讨论看出 CFS 对以前的调度器进行了很大改动。用红黑树代替优先级数组；用完全公平的策略代替动态优先级策略；引入了模块管理器；它修改了原来 Linux2.6.0 调度器模块 70%的代码。结构更简单灵活，算法适应性更高。相比于 RSDL，虽然都基于完全公平的原理，但是它们的实现完全不同。相比之下，CFS 更加清晰简单，有更好的扩展性。\nCFS 还有一个重要特点，即调度粒度小。CFS 之前的调度器中，除了进程调用了某些阻塞函数而主动参与调度之外，每个进程都只有在用完了时间片或者属于自己的时间配额之后才被抢占。而 CFS 则在每次 tick 都进行检查，如果当前进程不再处于红黑树的左边，就被抢占。在高负载的服务器上，通过调整调度粒度能够获得更好的调度性能。\n在最新版本的 CFS 实现中，内核使用虚拟运行时间 vruntime 替代了等待时间，但是基本的调度原理和排序方式没有太多变化。\n参考资料 #  [1] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核[M]. 中国电力出版社, 2001.\n[2] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核(第三版)[M]. 中国电力出版社, 2007.\n[3] 陈莉君, 康华. Linux 操作系统原理与应用[M]. 清华大学出版社, 2006.\n[4] RobertLove, 洛夫, 陈莉君, et al. Linux 内核设计与实现[M]. 机械工业出版社, 2006.\n[5] Linux 调度器发展简述 https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/\n[6] O(n)、O(1)和 CFS 调度器 http://www.wowotech.net/process_management/scheduler-history.html\n[7] 调度系统设计精要 https://draveness.me/system-design-scheduler/\n[8] 进程调度之 6：进程的调度与切换 https://my.oschina.net/u/3857782/blog/1857556\n"},{"id":2,"href":"/docs/algorithm/tree/","title":"二叉树","section":"算法","content":"二叉树 #  1、解题思路 #    遍历：通过遍历一遍树可以完成任务，则用 traverse 函数配合外部变量实现。 =》回溯\n  递归分解：通过子问题/子树的答案得到问题的解，则用 traverse 函数递归，利用返回值。=》 动态规划 =》后序\n  2、关注点 #  单独抽出一个节点，它需要做什么？在前/中/后序什么时候做？\n3、融会贯通 #  3.1、遍历函数 traverse() 的理解 #  迭代/递归遍历数组、链表、树没什么区别！\n数组 #  /* 迭代遍历数组 */ void traverse(int[] arr) {  for (int i = 0; i \u0026lt; arr.length; i++) {   } }  /* 递归遍历数组 */ void traverse(int[] arr, int i) {  if (i == arr.length) {  return;  }  // 前序位置  traverse(arr, i + 1);  // 后序位置 }   链表 #  /* 迭代遍历单链表 */ void traverse(ListNode head) {  for (ListNode p = head; p != null; p = p.next) {   } }  /* 递归遍历单链表 */ void traverse(ListNode head) {  if (head == null) {  return;  }  // 前序位置  traverse(head.next);  // 后序位置 }    3.2、快速排序 -\u0026gt; 前序遍历 #  构造分界点 -\u0026gt; 递归左右  Expand ↕  vector\u0026lt;int\u0026gt; sortArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  quickSort(nums, 0, nums.size()-1);  return nums;  }   void quickSort (vector\u0026lt;int\u0026gt; \u0026amp;nums, int low, int high) {  if (low \u0026lt; high) {  int index = partition(nums,low,high);  quickSort(nums,low,index-1);  quickSort(nums,index+1,high);  }  }   int partition (vector\u0026lt;int\u0026gt; \u0026amp;nums, int low, int high) {  int mid = low + ((high-low) \u0026gt;\u0026gt; 1);  if (nums[low] \u0026gt; nums[high]) swap(nums,low,high);  if (nums[mid] \u0026gt; nums[high]) swap(nums,mid,high);  if (nums[mid] \u0026gt; nums[low]) swap(nums,mid,low);   int pivot = nums[low];  int start = low;   while (low \u0026lt; high) {  while (low \u0026lt; high \u0026amp;\u0026amp; nums[high] \u0026gt;= pivot) high--;  while (low \u0026lt; high \u0026amp;\u0026amp; nums[low] \u0026lt;= pivot) low++;  if (low \u0026gt;= high) break;  swap(nums, low, high);  }  //基准值归位  swap(nums,start,low);  return low;  }     3.3、归并排序 -\u0026gt; 后序遍历 #  先排左右 -\u0026gt; 合并  Expand ↕  // 定义：排序 nums[lo..hi] void sort(int[] nums, int lo, int hi) {  int mid = (lo + hi) / 2;  // 排序 nums[lo..mid]  sort(nums, lo, mid);  // 排序 nums[mid+1..hi]  sort(nums, mid + 1, hi);   /****** 后序位置 ******/  // 合并 nums[lo..mid] 和 nums[mid+1..hi]  merge(nums, lo, mid, hi);  /*********************/ }     "},{"id":3,"href":"/docs/cs/linux/1/","title":"从开机 main 函数执行","section":"Linux","content":"Linux 从开机到加电执行 main 函数之前的过程 #  1.1 启动 BIOS，准备中断向量表和中断服务程序 #   加电时，内存 RAM 是空的 BIOS 负责把操作系统内核程序加载到内存中  具体过程：\n 靠硬件完成，将 CPU 的硬件逻辑设计为加电瞬间 CS:IP 指向 0xFFFF0, 即 BIOS 程序入口地址。 BIOS 在内存中建立中断向量表和中断服务程序。利用中断，加载内核程序。 产生 int 0x19 中断，找到并加载启动扇区，从而 bootsecct 程序被拷贝到内存。 BIOS 负责找到并加载第一扇区，与具体的Linux内核无关，即两头约定 + 定位识别。    "},{"id":4,"href":"/docs/law/dept/","title":"何为债","section":"法类","content":"何为债 #  债，以及其他的法律概念，从事实到概念形成，规定明确要件和法律效果，核心是法律的构建。因而，学习制度的思考路径，至少应当事实与法律并重。\n观察债的典型事实，其并非有共同构成要件，而是有同样的法律效果，即一方得以向另一方要求给付。此为债的基础原则。\n而债，实乃最基础的公式，其具有基础的要件，但加入具体的事实因素，则构成复杂的具体法律关系。而习得公式只是第一步，不同于数学公式的引用变形，每一个法律规则的使用，都是对于具体个体事实的讨论，都有十分重要的意义。\n因而，析得债实乃第一步，还应明确为何种债，并且需要进入到实际的具体概念和规则的讨论。\n“一方得以向对另一方要求给付”性质 #  该性质为债的基本原则，强调双方。如有突破的，需要有法律的明确规定。\n相对性 #  “债权为对于特定人之权利，债权人只能向债务人请求给付，而不能向债务人以外之人请求给付”。\n非支配性，没有绝对性和排他性。数个债权不论其发生先后，均以同等地位并存。（1）平等性：甲将房屋先后出卖给乙、丙、丁时买卖契约均属有效，三人均可请求甲交付该屋。（2）相对性：设甲将屋所有权移转于丁，乙、丙的债权随发生在前，仍不能向丁主张任何权利，仅得依债务不履行规定向甲请求损害赔偿。（3）非排他：债务人破产时，债权不论其发生先后，均依比例参加分配。\n第三人侵害债权 #  该理论寓有一项法律政策上的价值判断，即适当维护第三人的活动自由。\n例如，A驾车不慎，撞伤将在B歌厅作个人秀的歌星C。（1）A侵害了C的人身权，对其负是损害赔偿责任；（2）a.A的行为导致C无法演出，构成B的损失。b.C对于B的演出义务，产生于B与C之间的合同约定，该约定不可以用来规制A，B不可主张A侵害了自己能够使C来演出的权利。c.B可以依A故意以悖于善良风俗之方法，加损害于自己，来主张损害赔偿。\n即，债权的规制范围仅限于债权双方，第三人即使造成债权实际损害的结果，由于其并不受债权的约束，因此不可以主张第三人侵害债权。\n特殊：债权物权化 #  债权的物权化，即产生对抗一般人的法律效果，来源于法律的具体规定。\n 租赁权的物权化：租赁在先，即使出租人将租赁物所有权转移给第三人，无论第三人是否知道或知道应当知道该租赁合同的存在，承租人的租赁权依旧可以对抗第三人存在（“买卖不破租赁”）。 预告登记：预告登记的内容为债权，债权成立而登记后，任何处分该标的物的行为违背该预告登记的债权的，物权的变动无效。 基于约定产生的涉他关系  债的实现 #  实现的范围（债权角度） 。 债的内容即请求为给付，其目的是得到给付，如果交货付款同时完成，那么债权的存在没有那么大的意义。问题是，随着交易生活的不断变迁，债并非能够即时充分兑现。因此，债与债的实现一分为二。债的存在是为了保障债的实现，而债能够实现是债存在的基础。\n以当事人自治为原则，法律不直接参与债与债的实现。 债的内容是课债务人以给付义务，并赋予债权人以请求给付的权利。法律并不主动参与到这个过程中去，因为债是相对人之间的事，债权人可以主动选择是否实现请求以得到给付的权利。法律对债权人决定行使债权的给予权威、力量和制度，使其利益得到实现。\n此外，必要时法律予以强制性并于特殊情形下允许债权人自力实现其债权。\n一般权能 #   请求力：债的基本要义就是债权人能够诉请债务人履行义务。 执行力：诉请债务人履行后，债务人不履行的，法院得依债务的内容对债务人强制履行。具体有金钱请求权、物之交付请求权、行为及不行为请求权、假扣押假处分执行等。 私力实现：于特殊情况下，可以正当防卫紧急避险自助行为。除此之外，由于未涉及“实力”，五海域法律秩序及社会平和，允许抵抵销。 处分：由于法律赋予债权强的可实现力，因而债权富有价值，债权人可以对其进行处分，包括转让、免除、质押。 保持力：债务人给付后，债权人得以保有该给付，不致构成不当得利。债权具有保持给付之法律上的原因，该给付包括自动与法律强制下的给付。  特殊情形 #   请求力不完全：婚约，婚姻强调意志自由，履行以后不可强制；罹于消灭时效的债权请求力减损，不可诉请执行。 强制力排除：夫妻间的同居义务；与人身相关的义务：eg绘像，可以损害赔偿但不可直接强制； 处分排除：破产人因破产之宣告，对于其财产，丧失管理及处分权；约定债权不可让与的。  自然债务 #  婚姻居间报酬：成功才具有保有力；赌债：仅具有保有力。\n债务与责任 #  负担的范围（债务的角度）\n一般负担 #  责任即强制实现此项义务的手段，亦即履行此项义务的担保。即债务人的一般负担是为给付以自己的全部（或是特定）财产担保债务的实现。\n债务与责任问题是从债务人的角度来看债的实现，即债权人有权请求债务人使债实现，债务人如何积极配合债的实现，如何进行给付，给付不成怎么办。\n从这个角度上看，债务就是为给付“原始义务”，责任就是给付不能而生的“第二性义务”。责任是辅助于债务的存在，如同债权的其他权能辅助于请求权存在。债务本身就是负担，这个负担不仅仅包括为给付，还包括责任的负担。\n 无限责任：以自己的全部财产供债权人得依法强制执行 有限责任：以特定财产为限度，对于其他财产不得再为强制执行。  债权保全与担保制度 #  此即为特殊的负担，担保的财产涉及第三人或特定物。\n= 债的保全：责任财产的减少有两种情况，一种是债务人怠于行使自己的债权，一种是债务人积极赠与等不当使自己的财产减少的行为。 - 代位权：债务人怠于行使自己的到期债务，导致债权人不能实现债权，债权人可以直接找第三人要求其履行债务。 - 撤销权：债务人为有害债权的行为，倒是债权无法实现，债权人可以诉请法院撤销其不当行为，以恢复债务人之财产。\n 保证与担保  保证：保证人得以债权人约定，于主债务人不履行债务时，得由其代负履行责任。 担保：即以特定物担保债务的履行，包括抵押权、质押、动产抵押权、保留所有权及信托占有。   顺序总结：一般债权、优先受偿的债权（法律的规定）、有担保的债权、税收债权  债权的交易 #  包括债权让与与权利质权。\n债的义务群 #  债的微观内容，实际应为。\n 现行“民法”系以主给付义务为规律对象，基于诚信原则，由近而远，见渐次发生从积分义务，以及其他附随义务，辅助实现给付利益及维护他方当事人的人身及财产上利益，因此组成的义务体系。 在处理债之问题时，必须考虑：相对人负有何种义务，得否请求履行，得否主张同时履行抗辩，违反义务时的法律效果，得否请求损害赔偿或解除契约等。 债之关系上义务群的发展，赖乎判例学说，名称犹未统一，界限亦难完全确定，尤其从给付义务与附随义务，二者的区别从与主给付义务的远近来判断，存在模糊，二者的区别在于得否主张履行抗辩与得否解除契约，存在极大分野。  给付义务 #   主给付义务  决定债的性质的基本义务，固有、必备。 就双务合同而言，主给付义务构成对待给付义务，于他方当事人未为对待给付前，得拒绝自己之给付。 因可归责于债务人之事由，致给付不能、给付迟延或不完全给付时，债权人得请求赔偿损害或解除契约。   从给付义务  基于法律明文规定；基于当事人约定；基于诚实信用原则及补充的契约解释。 从给付义务与主给付义务关系密切，是使主给付义务得以满足而生的义务，固其得以请求履行，单独提起诉讼。 是否能够发生同时抗辩，应视具体的从给付义务是否为契约目的之达成是否必要而定。 其能够请求损害赔偿，但是否能够解除契约，依具体的从给付义务与契约目的之达成是否必要而定。    原给付义务与次给付义务 #  次给付义务是在原给付义务履行过程中，因特定事由演变而生的义务。次给付义务系根基于原来债之关系，其内容虽有所改变或扩张，但同一性仍维持不变。\n 因原给付义务给付不能、给付迟延或不完全给付而生成的赔偿损害义务，该义务既有替代给付义务的，亦有与原给付义务并存的。 契约解除时所生恢复原状之义务。  附随义务 #   促进实现主给付义务，使债权人的给付利益获得最大可能的满足，eg妥善包装花瓶；维护他方当事人人身或财产上的利益（保护功能），侵权行为法的社会安全义务来源。 性质：非给付义务，不发生同时履行抗辩，不得解除契约。德国法以是否能够提起单独诉讼作为区分附随义务与从给付义务的标准。 附随义务的违反与不完全履行给付：  不完全给付的法律后果是债权人得依关于给付迟延或者给付不能之规定行使其权利，因不完全给付而生前项义务之损害者，债权人并得请求赔偿。 法律没有设定附随义务得一般规定，附随义务的违反与不完全给付介于侵权责任与契约责任之间。  依照不完全给付的规定，不完全给付如为加害给付，除发生原来债务不履行之损害歪，更发生超过履行利益之损害，出卖人交付病鸡致买受人之鸡群亦感染而死亡。固可依侵权行为之规定请求损害赔偿，但被害人应就加害人之过失行为负举证责任，保护尚嫌不周，因此明定除了依侵权外，也可依不完全给付之理论请求损害赔偿。 依侵权行为法，因故意或过失侵害不法侵害他人权利者，负损害赔偿责任，其保护客体不及于纯财产上损害。同样思路，将附随义务的违法设定为符合不完全给付的规定，补充“侵权行为法”。     先合同义务  当事人为缔结契约而接触、准备或磋商时，发生的说明、告知、保密、保护扽跟其他义务。 具体规定（待补）   后合同义务  契约关系消灭后，当事人尚负有某种作为或不作为义务，以维护给付效果，或协助相对人处理契约终了的善后义务。 债务人违反后契约义务时，于违反一般契约义务同，依债务不履行负其责任。    不真正义务 #   相对人通常不得请求履行，而其违反并不发生损害赔偿责任，仅使负担此项义务者遭受权利减损或丧失的不利益而已。 不真正义务依诚实信用原则而生，为了最大程度上防止经济上的不效益。  标的物毁损灭失或其他情形不能返还：因可归责于解除权人自己的事由，解除权消灭。 损害扩大：被害人在法律上虽未富有不损害自己权益的义务，但既因自己之疏懈造成损害之发生或扩大，与有责任，依公平原则，自应依其程度忍受减免赔偿金额的不利益。    债法的体系 #   债法的适用逻辑：于处理相关问题时，应先检查债各是否设有规定，无特别规定时才可适用债总的一般规定。eg以不能之给付为契约标的，其契约始为无效；债权或其他权利之出卖人，应担保其权利确系存在。对于债权等权利的出卖契约规定了特别规定，这是因为立法者认为权利欠缺外部可见的形体，买受人必须信赖出卖人，故应受较为周全的保护。   甲于3月3日出售房屋给乙，约定3月10日交付。 乙于3月4日出售其对甲之债权与丙。 其后发现该屋于3月1日灭失。  甲乙买卖房屋的契约：为不能给付之契约标的，契约始为无效。房屋已经灭失，故甲乙的买卖合同无效。 乙丙之间的买卖契约：权利出卖人负有担保权利存在的义务，故乙丙的买卖合同有效。     民法的适用逻辑：以请求权基础为出发点，综合整部民法相关规定而为适用。并同样是特别优于一般。 实例探究：   甲欲丢弃旧笔A，误取新笔B丢弃。 乙先占之。 甲于次日发现其事，即向乙请求返还B笔。 乙表示已将该笔与丙的C书互易，并已同时履行。  甲基于错误的认识处分其B笔，该处分行为无效，不产生物权变动效力。 不是无主物，乙无法实现先占事实取得物权。 丙为善意第三人，并且满足善意取得要件。     故：甲得以向乙为返还原物请求权，侵权的损害赔偿请求权。甲得向丙请求返还原物请求权。  "},{"id":5,"href":"/docs/cs/linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/","title":"Linux 进程调度","section":"计算机","content":"Linux 进程调度 #  前言 #  在计算机科学中，调度就是一种将任务（Work）分配给资源的方法。任务可能是虚拟的计算任务，例如线程、进程或者数据流，这些任务会被调度到硬件资源上执行，例如：处理器 CPU 等设备。调度器或调度算法的设计与实现最终都会归结到一个问题上，即如何对有限的资源进行分配以实现资源利用率的最大化并满足特定的需求。\n调度器是操作系统中的重要组件，操作系统中有进程调度器（Process Scheduler）、网络调度器（Network Scheduler）和 I/O 调度器（I/O Scheduler）等组件，本文介绍的是进程调度器。\n进程调度器负责给系统中的所有进程分配有限的 CPU 时间资源。只有通过合理的调度算法，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。\n进程调度算法总是追求达到以下目标：\n 公平：保证每个进程得到合理的 CPU 时间，避免进程的饥饿现象。 高效：尽量充分使用 CPU，使 CPU 保持忙碌状态。 快速的响应时间：使交互用户的响应时间应尽可能短。 周转时间：使批处理用户等待输出的时间尽可能短。 吞吐量：单位时间内处理的进程数量尽可能多。  但是很显然，这几个目标是相互冲突的，不可能同时达到。因此只能在这几个方面进行取舍，从而确定自己的调度算法。\n进程调度器将进程分为三类：\n  交互式进程(Interactive process)：这些进程经常与用户进行交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如命令行 shell、文本编辑程序。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。\n  批处理进程(Batch process)：这些进程一般在后台运行，不必与用户交互，需要占用大量的系统资源。但是能够忍受响应延迟。典型的批处理程序如编译程序、数据库搜索引擎等。\n  实时进程(Real-time process)：这些进程对调度延迟的要求最高，往往执行非常重要的操作，要求立即响应并执行。典型的实时程序比如视频播放软件、或飞机飞行控制系统，很明显这类程序不能容忍长时间的调度延迟。\n  根据进程的不同分类 Linux 采用不同的调度策略。\n对于实时进程，采用 FIFO 或者 Round Robin 的调度策略。\n对于普通进程，则需要区分交互式和批处理式的不同。传统 Linux 调度器提高交互式应用的优先级，使得它们能更快地被调度。而 CFS 和 RSDL 等新的调度器的核心思想是“完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。\n以下列出了 Linux 不同版本调度器的历史：\n 初始调度器 · v0.01 ~ v2.4  由几十行代码实现，功能非常简陋； 同时最多处理 64 个任务；   O(n) 调度器 · v2.4 ~ v2.6  调度时需要遍历全部任务； 当待执行的任务较多时，同一个任务两次执行的间隔很长，会有比较严重的饥饿问题；   O(1) 调度器 · v2.6.0 ~ v2.6.22  通过引入运行队列和优先级数组实现 O(1) 的时间复杂度; 使用本地运行队列替代全局运行队列增强在对称多处理器的扩展性； 通过负载均衡保证多个运行队列中任务的平衡；   完全公平调度器 · v2.6.23 ~ 至今  引入红黑树和运行时间保证调度的公平性； 引入调度类实现不同任务类型的不同调度策略；    本文会详细介绍从最初的调度器到今天复杂的完全公平调度器（Completely Fair Scheduler，CFS）的演变过程。\nLinux 初始的调度算法 #  Linux 最初的进程调度器仅由 sched.h 和 sched.c 两个文件构成。你可能很难想象 Linux 早期版本使用只有几十行的 schedule 函数负责了操作系统进程的调度：\nvoid schedule(void) {  int i,next,c;  struct task_struct ** p;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) {  ...  }  while (1) {  c = -1;  next = 0;  i = NR_TASKS;  p = \u0026amp;task[NR_TASKS];  while (--i) {  if (!*--p) continue;  if ((*p)-\u0026gt;state == TASK_RUNNING \u0026amp;\u0026amp; (*p)-\u0026gt;counter \u0026gt; c)  c = (*p)-\u0026gt;counter, next = i;  }  if (c) break;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p)  if (*p)  (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority;  }  switch_to(next); } 无论是进程还是线程，在 Linux 中都被看做是 task_struct 结构体，所有的调度进程都存储在上限仅为 64 的数组中，调度器能够处理的进程上限也只有 64 个。\n上述函数会先唤醒获得信号的可中断进程，然后从队列倒序查找计数器 counter 最大的可执行进程，counter 是进程能够占用的时间切片数量，该函数会根据时间切片的值执行不同的逻辑：\n 如果最大的 counter 时间切片大于 0，调用汇编语言的实现的 switch_to 切换进程； 如果最大的 counter 时间切片等于 0，意味着所有进程的可执行时间都为 0，那么所有进程都会获得新的时间切片；  Linux 操作系统的计时器会每隔 10ms 触发一次 do_timer 将当前正在运行进程的 counter 减一，当前进程的计数器归零时就会重新触发调度。\nO(n) 调度算法 #  数据结构：进程描述符 #  每个进程都有一个 task_struct 结构。该结构定义在 \u0026lt;include/linux/sched.h\u0026gt; 文件中，其中部分与进程调度相关的字段说明如下：\n  need_resched：调度标志，决定是否调用 schedule() 函数。\n  counter：进程处于可运行状态时所剩于的时钟节拍数。每次时钟中断到来时，update_process_times()对该值减 1。\n 创建新进程时，do_fork()以下列方式设置 current(父)和 p(子)进程的 counter 字段：current-\u0026gt;counter \u0026gt;\u0026gt;=1; p-\u0026gt;counter = current-\u0026gt;counter. 也就是说，父进程剩余的节拍数被分为两部分，一部分给父进程，一部分给子进程。这样做时为了防止通过 fork 子进程的方法无限制地使用 CPU 的时间。    rt_priority：实时进程的实时优先级。取值范围 1-99。\n  nice: 进程的静态优先级，它的值决定了 counter 的初值。nice 的取值范围是-20(优先级高)~19(优先级低)，缺省为 0。该值可通过 nice 系统调用改变。\n  policy： 本进程的调度策：\n SCHED_RR 和 SCHED_FIFO 用于实时进程。SCHED_RR 和 SCHED_FIFO 的调度策略在 rt_priority 不同的时候，都是谁的优先级高谁先执行，唯一的不同是相同优先级的处理： SCHED_RR 是时间片轮转的实时进程。当多个进程具有同一优先级时，采用时间片轮转轮流调度运行。适用于实时性要求较高但每次运行耗时较长的进程。 SCHED_FIFO 是先入先出的实时进程，先占有 CPU 的进程会持续执行，直到退出或者阻塞的时候才会让出 CPU。也只有这时候，其他同优先级的实时进程才有机会执行。适应于实时性要求比较强、而每次运行的耗时又比较短的进程。 SCHED_OTHER 用于普通的分时进程。  除了上面描述的三种调度策略，policy 成员也可以设定 SCHED_YIELD 的标记，它和调度策略无关，主要处理 sched_yield 系统调用的。\n  state: 表示进程当前运行状态：\n  TASK_RUNNING ：该状态表示这个进程可被调度执行而成为当前进程，是进程表达了希望被调度运行的意愿，内核会将该进程的 task_struct 结构加入可运行队列。\n  TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE ：这两个状态都表示进程处于睡眠状态。前者表示浅度睡眠，可被信号唤醒；后者表示深度睡眠。sleep_on 和 wake_up 用于深度睡眠；而 interruptible_sleep_on 和 interruptible_wake_up 则用于浅度睡眠。\n  TASK_ZOMBIE 表示已退出而暂时没有被父进程收回资源的\u0026quot;僵尸\u0026quot;进程。\n  TASK_STOPPED 主要用于调试目的。进程接收到一个 SIGSTOP 信号后就将运行状态改成 TASK_STOPPED 而进入挂起状态，然后在接收到一个 SIGCONT 信号时又恢复继续运行。\n    调度的时机 #  Linux 的调度程序是一个叫 schedule()的函数，由它来执行具体的调度算法。调用 schedule()的时机主要包括：\n直接调用 #    进程入睡时主动调用 schedule()：当现运行进程请求资源被阻塞时，会调用 sleep_on()或 interruptible_sleep_on()进入睡眠状态，这时会执行以下步骤：\n  把当前进程 current 插入到合适的等待队列中。\n  把当前进程 current 的状态修改为 TASK_INTERUPTIBLE 或 TASK_UNINTERUPTIBLE。\n  调用 schedule() 函数。\n  检查那个资源是否可用。如果不，转到第 2 步。\n  一旦那个资源成为可用的，把 current 从等待队列中删除。\n    进程终止时主动调用 schedule()：当现运行进程终止时，会调用 exit() 终止运行，这时会主动调用 schedule() 函数。\n  设备驱动程序执行长而重复的任务时，主动调用 schedule()：驱动程序在每次循环中，都会去检查调度标志 need_resched 的值，如果必要，就调用 schedule()主动放弃 CPU。\n  创建新进程：在 do_fork()中也会调用 schedule() 函数。\n  延迟调用 #  延迟调用是指当系统需要调度时，通过置现运行进程 need_resched 标志为 1。然后在从中断、异常、系统调用等从内核返回用户态时，对该标志进行检测，如果该标志为 1，则调用 schedule()。主要包括以下情况：\n  在中断处理过程中，发现 current 用完了时间片，置 need_resched 标志为 1。\n  一个进程被唤醒，且它的优先级比现运行进程更高，置 need_resched 标志为 1。\n  当父进程 fork 子进程时，其时间片会均分到父子进程。\n 如果只剩下一个 tick，这个 tick 会分配给子进程，而父进程的时间片则被清零，这时候等同于情况 1。 否则，父子进程的时间片都不为 0，这时等同于情况 2。    一个进程通过系统调用改变调度政策(sched_setscheduler)或表示礼让(sched_yield)时，会设置 need_resched 标志为 1。\n  如何计算优先级：godness() #  调度算法的核心是在可运行队列链表中的所有进程中确定优先级最高的进程。goodness() 就是用来计算进程优先级。它接受两个输入参数：prev(前一个运行进程)和 p(要评估的进程)，返回一个整数值 c，表示进程 p 的“值得运行的程度(goodness)”。\ngoodness()函数将实时进程和普通进程区分计算。流程如下：\n 如果该进程的 policy 被置 SCHED_YIELD 标志为，直接返回 -1。表示进程愿意“礼让”。 如果该进程是 SCHED_FIFO 或 SCHED_RR，直接返回：1000+ p-\u0026gt;rt_priority。可以看出，实时进程的优先级很高，且与 counter 和 nice 无关，至少为 1000，保证了实时进程会完全优先于普通进程的调度。 如果该进程是 SCHED_OTHER： 如果 p-\u0026gt;counter 为 0，直接返回 0。即该进程已用完时间片。 否则，返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice。 此外，在 2 的情况下，如果候选进程 p 是内核进程（无用户空间），或者 p 的用户空间与当前进程 prev 的用户空间相同，则返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice + 1。因为如果 p 正好在 prev 之后运行，它们将使用同一页表。  调度流程：schedule() #  可以将 schedule()函数大致分为以下三个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作  具体过程如下：\n初始化部分 #   current 的值保存在 prev 局部变量中, 将 prev-\u0026gt;need_resched 字段设为 0 判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。 prev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));  检查 prev 的状态，  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒:  prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。    确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。 检查候选进程 next：  如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。   检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。  进程切换之后的操作 #  执行__schedule_tail()，置 prev-\u0026gt;police 的 SCHED_YIELD 为 0。 函数返回。  如何重新分配时间片 #  在上一小节提到，当 c 为 0 时，说明可运行队列中没有实时进程，只有普通进程，且队列中所有普通进程的时间片都已用完，这时需要重新系统中所有进程的时间片（而不仅仅是可运行队列中的进程），计算方法为：\nfor_each_task(p)  p-\u0026gt;counter = (p-\u0026gt;counter \u0026gt;\u0026gt; 1) + NICE_TO_TICKS(p-\u0026gt;nice); 宏 NICE_TO_TICKS 的定义如下。以 HZ 为 200 为例，每秒中断 200 次，那么一个时钟滴答 tick 为 5ms，20 - nice 的取值为[1 ,40]，缺省为 20，将 20 右移 1 位即除以 2 为 10，10 个滴答即 50ms。当时钟频率 HZ 越高，每个滴答所代表的时间越短，NICE_TO_TICKS 分配的滴答数越多，但最大只是 20 – nice 的值左移 2 位即乘以 4，最大值为 160，仍小于实时进程的 1000。\n#if HZ \u0026lt; 200 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 2) #elif HZ \u0026lt; 400 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 1) #elif HZ \u0026lt; 800 #define TICK_SCALE(x) (x) #elif HZ \u0026lt; 1600 #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 1) #else #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 2) #endif #define NICE_TO_TICKS(nice) (TICK_SCALE(20-(nice))+1) 可以发现，经过重新计算后，那些不在可运行队列中的普通进程，会获得较高的时间配额，在将来的调度中会占一定的优势。但即使无数次更新方之后，counter 的值也不会超过两倍的 NICE_TO_TICKS，也不会超过实时进程的优先级。\nSMP 系统下的调度程序 #  Linux 为了支持对称多处理器(SMP)体系结构，必须对 Linux 的调度程序稍作修改。实际上，每个处理器运行它自己的 schedule()函数，但是，处理器间必须交换信息以提高系统性能。\n数据结构 #  schedule_data 结构体 #  如下所示，schedule_data 结构体用来很快的获得当前进程的描述符，每个 CPU 上都有一个该结构体。该结构体包含：\n 该 CPU 上现运行进程的描述符 task_struct。 现运行进程上台的时刻，即 schedule()是什么时候选 curr 作为运行进程。  struct schedule_data{  struct task_struct *curr;  unsigned long last_schedule; } struct schedule_data aligned_data[NR_CPUS]; task_struct 进程描述符 #  除了在上文提到的一些与进程调度相关的字段外，task_struct 还包含了几个与 SMP 相关的字段，包括：\n processor：表示该进程上一次运行在哪个 CPU 上。 avg_slice：表示该进程的平均时间片，即每次运行时间的期望值。  cacheflush_time 变量 #  cacheflush_time 变量表示对硬件高速缓存内容全部重写所需要花费的时间。这个值只是一个估值，大约不到 100 微秒。计算公式为：以 kHZ 为单位的 CPU 频率*以 KB 大小为单位的缓存容量/5000 在后面将看到，当现运行进程的 avg_slice – (time – last_schedule) \u0026lt; cacheflush_time，就不会执行进行的抢占。\nSMP 系统下调度流程：schedule() #  具体过程如下：\n  current 的值保存在 prev 局部变量中。prev-\u0026gt;processor 的值存放在 this_cpu 局部变量中。aligned_data[this_cpu]的值存放在 sched_data 局部变量中。将 prev-\u0026gt;need_resched 字段设为 0。\nprev = current; this_cpu = prev-\u0026gt;processor; sched_data = aligned_data[this_cpu];   判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。\nprev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));   检查 prev 的状态:\n   如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒: prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。  确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。在 goodness 函数中，检查进程的 processor 字段，并对最后在 this_cpu CPU 上执行的进程给与一定奖赏(PROC_CHANGE_PENALTY，通常为 15). 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。除此之外，做一些跟 CPU 相关的操作：   把 sched_data-\u0026gt;curr 置为 next。 next-\u0026gt;has_cpu 置为 1，next-\u0026gt;processor 置为 this_cpu。 在 t 局部变量中存放 current 时间标记寄存器的值，并执行： this_slice = t – sched_data-\u0026gt;last_schedule; sched_data-\u0026gt;last_schedule = t; prev-\u0026gt;avg_slice = (prev-\u0026gt;avg_slice + this_slice) / 2   检查候选进程 next：   如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。  检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。 进程切换之后的操作 当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 schedule()时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。如果 prev(即为 prev_new)还依然是可运行的，并且不是这个 CPU 的空任务，那么，对 prev 调用 reschedule_idle()函数。 把 prev 的 has_cpu 字段清 0。 函数返回。  SMP 系统下的 reschedule_idle() #  当进程 p 变为可运行时，执行 reschedule_idle()函数决定进程是否应该抢占某一 CPU 上的当前进程。具体过程如下：\n 如果 p 是实时进程，总会试图抢占，转到 3。 如果有一个 CPU 上的当前进程满足下列两个条件，则立即返回(不试图抢占)：  cacheflush_time 大于当前进程的平均时间片。防止高速缓存变得太“脏”。 为了存取某一临界内核数据结构，p 和当前进程都需要全局内核锁。   接下来执行 CPU 选择算法：  如果 p-\u0026gt;processor (即 p 最后运行的 CPU)是空闲的，选它。 遍历所有 CPU，对其上正在运行的任务 tsk，计算以下差值：goodness(tsk, p) - goodness(tsk, tsk), 如果这个差值为正，就选择差值最大的 CPU。   如果选择了某个 CPU，给选中的 CPU 的正在运行进程的 need_resched 字段置 1，并向这个 CPU 发处理器间中断：RESCHEDULE_VECTOR interprocessor interrupt。  O(1) 调度算法 #  O(n) 调度算法缺陷 #  Linux2.4 之前的版本，用较为简单的调度算法实现了进程调度。但是该算法存在以下问题：\n  算法复杂度问题。遍历运行队列的算法复杂度为 O(n)，意味着队列越长，选中一个进程所需要的时间就越长。此外，每次调度周期结束后，为每一个进程计算其时间片的过程太耗费时间。\n  多处理器问题。多个处理器上的进程放在一个就绪队列中，使得这个就绪队列成为临界资源，为了实现内核同步机制，需要对其上自旋锁，降低了系统效率。\n  CPU 空转问题。在 runqueue 队列中的全部进程时间片被耗尽之前，系统总会处于这样一个状态：最后的一组尚存时间片的进程分分别调度到各个 CPU 上去。我们以 4 个 CPU 为例，T0 ～ T3 分别运行在 CPU0~CPU3 上。随着系统的运行，CPU2 上的 T2 首先耗尽了其时间片，但是这时候，其实 CPU2 上也是无法进行调度的，因为遍历 runqueue 链表，找不到适合的进程调度运行，因此它只能是处于 idle 状态。也许随后 T0 和 T3 也耗尽其时间片，从而导致 CPU0 和 CPU3 也进入了 idle 状态。现在只剩下最后一个进程 T1 仍然在 CPU1 上运行，而其他系统中的处理器处于 idle 状态，白白的浪费资源。唯一能改变这个状态的是 T1 耗尽其时间片，从而启动一个重新计算时间片的过程，这时候，正常的调度就可以恢复了。随着系统中 CPU 数目的加大，资源浪费会越来越严重。\n  SMP 亲和力问题。在一个新的周期开后，runqueue 中的进程时间片都是满满的，在各个 CPU 上调度进程的时候，它可选择的比较多，再加上调度器倾向于调度上次运行在本 CPU 的进程，因此调度器有很大的机会把上次运行的进程调度到同一个处理器上。但是随着 runqueue 中的进程一个个的耗尽其时间片，cpu 可选择的余地在不断的压缩，从而导致进程执行在一个和它亲和性不大的处理器（例如上次该进程运行在 CPU0，但是这个将其调度到 CPU1 执行，但是实际上该进程和 CPU0 的亲和性更大些）。\n  实时进程调度性能问题。实时进程和普通进程挂在一个链表中，当调度实时进程的时候，我们需要遍历整个 runqueue 列表，扫描并计算所有进程的优先级，再从中选择出最终要调度的实时进程，在这过程中，一些时间片已经耗完的进程在不可能参与调度的情况下，依然会参与调度选择的过程。此外，整个 linux 内核不是抢占式内核，对于一些比较耗时的系统调用或者中断处理，必须返回用户空间才启动调度，大大降低了实时进程的调度性能。\n  交互式普通进程的调度延迟问题。O（n）并不区分交互式进程和批处理进程，它只是奖励经常睡眠的那些进程。但是有些批处理进程也属于 IO-bound 进程，例如数据库服务进程，它本身是一个后台进程，对调度延迟不敏感，但是由于它需要和磁盘打交道，因此也会经常阻塞在 disk IO 上。对这样的后台进程进行动态优先级的升高其实是没有意义的，会增大其他交互式进程的调度延迟。\n  虽然 O（n）调度器存在不少的问题，但是社区的人还是基本认可这套算法的，因 此在设计新的调度器的时候并不是完全推翻 O（n）调度器的设计，而是针对 O（n）调度器的问题进行改进。\n从以上分析中可以看出，单运行队列是影响调度性能的主要问题之一，因此改进运行队列就成为改进调度算法的入口点。\n基于此，O(1)调度器为每个 CPU 设置一个运行队列，并且为每个运行队列再设置两个队列：活动队列和时间片过期队列。每个队列中的元素以优先级再进行分类，相同优先级的进程为一个队列，最多可以有 140 个优先级。为了快速选中要运行的进程，设置以优先级为序的队列位图，位图的每一位对应一个队列，只要队列中有一个可运行进程，该位置 1，否则置 0。这样，无需遍历所有队列，而只要遍历位图，找到有可运行进程的队列，该队列的第一个进程就是被选中的进程。该算法的复杂度为 O(1). 如图所示：\n通过将单链表变成多个链表，可以解决上述大部分问题：\n 算法复杂度问题：O(1)调度器算法通过优先级位图，以及活动队列与过期队列指针交换，实现了 O(1)的复杂度，而不是遍历运行队列，并重新计算所有进程的时间片。 多处理器问题：由于每个 CPU 都有一个运行队列，因此 O(1)调度器就不需要全局运行队列的自旋锁，而只需要把这个自旋锁放入到每个 CPU 的运行队列数据结构中，通过把一个大锁细分成小锁，可以大大降低调度延迟，提升系统响应时间。。 CPU 空转问题：O(1)调度器每个 CPU 都有一个运行队列，当一个进程的时间片耗尽，在被移动到过期数组之前，会重新计算其时间片，而不是等到一个调度周期结束再重新计算进程时间片，因此解决了 CPU 空转问题。 SMP 亲和力问题：O(1)调度器设置了较为合理的负载均衡算法，只有在需要平衡任务队列大小时才在 CPU 之间移动进程。 实时进程与交互式调度性能问题：为了提高交互时进程和实时进程的响应时间，当前进程的时间片为 0 时，判断当前进程的类型，如果时交互式进程或实时进程，则重置其时间片并重新插入活动队列，否则插入过期队列，这样交互式进程和实时进程总能优先获得 CPU。然而当这些进程已经占用 CPU 时间超过一个固定值后，也会被移到过期队列中，避免其他进程产生饥饿现象。  数据结构 #  runqueue 数据结构 #  runqueue 可执行队列是调度程序中最基本的数据结构。定义于 kernel/sched.c 中。如上所述，每个 CPU 包含一个可执行队列；每个就绪进程都唯一地归属于某一个可执行队列。此外，可执行队列中还包含着每个 CPU 的调度信息。其包含的字段如下图所示：\n优先级数组 #  如上所述，每个运行队列有活动队列和过期队列两个优先级数组，每个数组是一个 prio_array 类型的结构体。优先级数组使得该调度算法复杂度为 O(1)。\n 计数器 nr_active 是一个计数器，保存可运行进程数目。 bitmap 是优先级位图数组。其中 BITMAP_SIZE 是位图数组的大小，类型为 unsigned long 长整型，长 32 位，每一位包含一个优先级，140 个优先级需要 5 个长整型数表示。bitmap 一开始所有的位都被置 0。当某个进程状态变为 TASK_RUNNING 时，对应的位被置 1。这样，查找系统中最高的优先级就变成了查找位图中被设置的第一个位。 queue 是优先级链表数组，一个链表对应一种优先级。每个链表包含了该 CPU 上相应优先级的全部可运行进程。其中 MAX_PRIO 定义了系统拥有的优先级个数，默认为 140。  进程描述符 #  与 linux 2.4 的进程描述符有些差异，其与调度相关的字段如下：\n进程的优先级 #  普通进程 #  静态优先级 #  普通进程的静态优先级保存在 static_prio 成员中，取值范围是 100（优先级最高）～ 139（优先级最低），分别对应 nice 值的-20 ～ 19。静态优先级本质上决定了进程的基本时间片，对应公式如下：\n由该公式得到一些普通进程优先级的典型值如下：\n动态优先级 #  在实际调度的时候使用的是动态优先级。普通进程的动态优先级保存在进程描述符的 prio 成员中。取值范围是 100（优先级最高）～ 139（优先级最低），和静态优先级一致。动态优先级根据以下公式得出：\n其中，bonus 取值范围 0~10，值小于 5 表示惩罚，大于 5 表示奖赏。bonus 的取值与进程的平均睡眠时间相关，如下表。需要说明的是，平均睡眠时间是进程在睡眠状态所消耗的平均纳秒数，但不是对过去时间的求平均值操作。例如，在 TASK_INTERRUPTIBLE 状态与在 TASK_UNINTERRUPTIBLE 状态所计算出的平均睡眠时间是不同的。而且，平均睡眠时间永远不会大于 1s.\n平均睡眠时间也被调度程序用来确定一个给定进程是交互式进程还是批处理进程。如果满足下列公式，则被看作是交互式进程：\n其中，静态优先级/4-28 被称为交互时的 δ。可以推出，高优先级的进程比低优先级的进程更容易成为交互式进程。例如，最高静态优先级(100)的进程，当他的 bonus 值超过 2，即睡眠时间超过 200ms 时，就被看作是交互式进程。\n实时进程 #  实时进程的实时优先级，存在进程描述符的 rt_priority 成员中，取值范围是 1（优先级最低）～ 99（优先级最高）。需要注意的是，当系统调用 nice()和 setpriority()用于基于时间片轮转的实时进程时，不改变实时进程的优先级，而会改变其基本时间片的长度。也就是说，基于时间片轮转的实时进程的基本时间片的长度与实时进程的优先级无关，而依赖于进程的静态优先级，它们的关系同普通进程下的公式一样。\n普通进程采用复杂的公式计算动态优先级，而实时进程不计算动态优先级，保证了给定优先级别的实时进程总能抢占优先级比它低的进程。\n调度程序所使用的函数 #  调度程序使用几个函数来完成调度工作，其中最重要的函数说明如下：\nscheduler_tick() #  每次时钟节拍到来时，scheduler_tick()被调用，执行以下步骤：\n 把转换为纳秒的 TSC 的当前值存到本地运行队列的 timestamp_last_tick 字段。这个时间戳是从 sched_clock()函数得到。 检查当前进程是不是本地 CPU 的 swapper 进程，如果是，则检查本地运行队列除了 swagger 进程外，是不是还有另外的可运行进程，如果是，就设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。之所以会出现这种情况，是因为如果内核支持超线程技术，那么只要一个逻辑 CPU 运行队列中的所有进程都比另一个逻辑 CPU 上已经在执行的进程优先级低得多，而两个逻辑 CPU 是对应同一个物理 CPU 的，因此，前一个逻辑 CPU 就可能空闲，即使它的运行队列中也有可运行的进程。执行完上述检查后，直接跳到第 7 步，因为不需要更新 swagger 进程的时间片。 检查 current-\u0026gt;array 是否指向本地运行队列的活动链表，如果不是，说明进程已经过期但还没有被替换，则设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。然后直接跳到第 7 步。 获得 this_rq()-\u0026gt;lock 自旋锁 根据进程不同类型执行不同操作：    如果当前进程是 FIFO 的实时进程，则什么也不做，跳到 6。\n  当前进程是基于时间片轮转的实时进程：递减当前进程时间片，如果时间片已经用完，则：\n 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice= 0。该字段是在 fork()系统调用服务例程中的 copy_process()中设置，并在进程的第一个时间片用完时清 0。 调用 set_tsk_need_resched()设置进程的 TIF_NEED_RESCHED 字段。 iv. 把当前进程移到当前的运行队列尾部。    当前进程是普通进程：递减当前进程时间片，如果时间片已经用完：\n 将当前进程从活动队列(this_rq()-\u0026gt;active)中移除。 调用 set_tsk_need_resched() 设置进程的 TIF_NEED_RESCHED 字段。 更新当前进程的动态优先级。current-\u0026gt;prio = effective_prio(current). 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice 清 0。 如果 this_rq()-\u0026gt;expired_timestamp 字段为 0（表示过期队列为空），把当前进程的时钟节拍 jiffies 赋值给 this_rq()-\u0026gt;expired_timestamp。 把当前进程插入活动队列或过期队列：  if (!TASK_INTERACTIVE(current) || EXPIRED_STARVING(this_rq()))  enqueue_task(current, this_rq()-\u0026gt;expired); else  enqueue_task(current, this_rq()-\u0026gt;active); 其中, TASK_INTERACTIVE 宏用于识别一个进程是不是交互式进程。EXPIRED_STARVING 宏负责检查过期队列中的进程是否处于饥饿状态：如果已经有相对较长时间没有发生数组切换了，那么再把当前的进程放置到活动数组，则会加重过期队列中进程的饥饿状态。\n否则，如果时间片没有用完，检查当前进程的剩余时间片是否太长：\nif (TASK_INTERACTIVE(p) \u0026amp;\u0026amp; !((task_timeslice(p) – p-\u0026gt;time_slice) %TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;time_slice \u0026gt;= TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;array == rq-\u0026gt;active)) {  list_del(\u0026amp;current-\u0026gt;run_list);  list_add_tail(\u0026amp;current -\u0026gt; run_list, this_rq()-\u0026gt;active-\u0026gt;queue+current-\u0026gt;prio);  set_tsk_need_resched(p); } 其中，宏 TIMESLICE_GRANULARITY 产生两个数的乘积给当前进程的 bonus，其中一个数为系统中 CPU 的数量，另一个为成比例的常量。基本上，具有高静态优先级的交互式进程，其时间片被分成大小为 TIMESLICE_GRANULARITY 的几个片段，以使这些进程不会独占 CPU。\n  释放 this_rq()-\u0026gt;lock 自旋锁。 调用 rebalance_tick()函数，保证不同 CPU 的运行队列包含数量基本相同的可运行进程。  从第 5 步中可以看出，对于 O(1)调度器，时间片的重新赋值是分散处理的，在各个进程耗尽其时间片之后立刻进行的。修正了 O(n)调度器一次性的遍历系统所有进程，重新为时间片赋值的过程。\n唤醒：try_to_wake_up() #  该函数通过把进程状态设置为 TASK_RUNNING，并调用 activate_task()函数将此进程放入对应的可运行队列中来唤醒睡眠或停止的进程。\n该函数接受的参数有：\n 被唤醒进程的描述符指针 p. 可以被唤醒的进程状态掩码(state)。 一个标志(syn)，用来禁止被唤醒的进程抢占本地 CPU 上正在运行的进程。  该函数执行以下操作：\n 禁本地中断，并获得最后执行该进程的 CPU 的运行队列的锁。 检查进程状态 p-\u0026gt;state == state。如果不是，直接跳到 9 终止函数。 如果 p-\u0026gt;arrray != NULL ,说明该进程已经属于某个运行队列，跳到 8. 确定目标 CPU：  如果有空闲的 CPU，就选空闲的 CPU。 如果先前执行进程的 CPU 的工作量远小于本地 CPU 的工作量，选前者。 如果进程最近被执行过，就选这个老的运行队列。 如果把进程迁移到本地 CPU 可以缓解 CPU 之间的不平衡，则选本地 CPU。   如果进程处于 TASK_UNINTERRUPTIBLE 状态，则递减目标运行队列的 nr_uninterruptible 字段，并把 p-\u0026gt;activated 字段置为-1。 调用 activate_task()函数，执行：  调用 sched_clock()获取以纳秒为单位的当前时间戳。如果目标 CPU 不是本地 CPU，就要补偿本地时钟中断的偏差：now=(shced_clock()–this_rq()-\u0026gt;timesamp_last_tick)+rq-\u0026gt;timestamp_last_tick 调用 recalc_task_prio()。 设置 p-\u0026gt;activated 字段的值。 使用 now 设置 p-\u0026gt;timestamp 字段。 把进程描述符插入活动队列，且 rq-\u0026gt;nr_running++。   如果目标 CPU 不是本地 CPU，或者没有设置 sync 标志，则，如果该进程优先级更高 p-\u0026gt;prio \u0026gt; rq-\u0026gt;curr-\u0026gt;prio，就调用 resched_task()抢占 rq-\u0026gt;curr。  单处理器系统，设置 rq-\u0026gt;curr 进程的 TIF_NEED_RESCHED 标志。 多处理器系统，如果 TIF_NEED_RESCHED 旧值为 0，且目标 CPU 没有轮询进程 TIF_NEED_RESCHED 标志的值，则发送处理器间中断 IPI，强制目标 CPU 重新调度。   把当前进程 p-\u0026gt;state 字段设为 TASK_RUNNING。 开 rq 运行队列的锁，打开本地中断。 如果成功唤醒返回 1，否则返回 0.  计算动态优先级：recalc_task_prio() #  recalc_task_prio() 函数更新进程的平均睡眠时间和动态优先级。\n该函数接受的参数有：\n 进程描述符指针 p。 当前时间戳 now。  该函数执行以下操作：\n 把 min(now – p-\u0026gt;timestamp, 109)的结果赋值给局部变量 sleep_time，表示进程消耗在睡眠状态的纳秒数。如果超过 1 秒，就设为 1 秒. 如果 sleep_time 不大于 0，直接跳到 8. 检查进程是不是内核线程、进程是否从 TASK_UNINTERRUPTIBLE 状态（即 p-\u0026gt;activated 为-1）被唤醒、进程连续睡眠的时间是否超过给定的睡眠时间期限。如果这三个条件都满足，把 p-\u0026gt;sleep_avg 字段设置位相当于 900 个时钟节拍的值（用最大平均睡眠时间减去一个标准进程的基本时间片长度获得的一个经验值）。然后跳到 8. 计算进程原来的平均睡眠时间的 bonus 值。如果 10-bonus\u0026gt;0,则把 sleep_time 乘以 10-bonus。所以原来的 p-\u0026gt;sleep_avg 越小，bonus 值越小，10-bonus 越大，sleep_time 越大，最终的 p-\u0026gt;sleep_avg 增加的就越快。 如果进程处于 TASK_UNINTERRUPTIBLE 状态而且不是内核线程：  检查平均睡眠时间 p-\u0026gt;sleep_avg 是否大于等于进程的睡眠时间极限。如果是，把 sleep_time 置为 0，直接跳到 6. 如果 sleep_time + p-\u0026gt;sleep_avg 大于等于睡眠时间极限，把 p-\u0026gt;sleep_avg 设为睡眠时间极限并把 sleep_time 置为 0 通过对进程平均睡眠时间的轻微限制，函数不会对睡眠时间很长的批处理进程给与过多的奖赏。   把 sleep_time 加到进程的平均睡眠时间 p-\u0026gt;sleep_avg 上。 检查 p-\u0026gt;sleep_avg 是否超过 1000 个时钟节拍，如果是，就置为 1000 个时钟节拍。 更新进程的动态优先级。p-\u0026gt;prio = effective_prio(p).  可以看到，在评估用户交互指数上，O(n)调度器仅仅考虑了睡眠进程的剩余时间片，而 O(1)调度器的“平均睡眠时间”算法考虑了更多的因素：在 cpu 上的执行时间、在 runqueue 中的等待时间、睡眠时间、睡眠时候的进程状态（是否可被信号打断），什么上下文唤醒（中断上下文唤醒还是在进程上下文中唤醒），因此 O(1)调度器更好的判断了进程是否属于交互式进程。\n调度流程： #  schedule() 与 O(n) 调度器类似，可以将 schedule() 函数大致分为以下四个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作 具体过程如下： 初始化部分 禁用内核抢占。current 的值保存在 prev 局部变量中，本地 CPU 的运行队列保存在 rq 局部变量中。 preempt_disable(); prev = current; rq = this_rq();  保证 prev 不占用大内核锁。通过进程切换会自动释放和重新获取大内核锁。 if (prev-\u0026gt;lock_dept \u0026gt;= 0)  up(\u0026amp;kernel_sem);  计算 prev 所用的 CPU 时间片长度： now = sched_clock(); run_time = now – prev-\u0026gt;timesamp; if (run_time \u0026gt; 1000000000)  run_time = 1000000000 run_time /= (CURRENT_BONUS(PREV) ? : 1) run_time 用来限制进程对 CPU 的使用，最多 1 秒。不过，当进程有较长睡眠时间时，CURRENT_BONUS()返回值越大，run_time 就会被降低。这是对较长平均睡眠时间的奖赏。 关本地中断，获得运行队列的自旋锁：spin_lock_irq(\u0026amp;rq-\u0026gt;lock) 检查 prev 是不是一个正在被终止的进程： if (prev-\u0026gt;flags \u0026amp; PF_DEAD)  prev-\u0026gt;state = EXIT_DEAD;  检查 prev 的状态，如果不是 TASK_RUNNING 可运行状态，而且没有在内核态被抢占：  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就让其变为可运行状态：prev-\u0026gt;state = TASK_RUNNING 以唤醒这个进程。 否则，调用 deactivate_task()函数从运行队列中删除 prev 进程,。同时，如果该进程状态是 TASK_UNINTERUPTIBLE，则 rq-\u0026gt;nr_uniterruptible++.  rq-\u0026gt;nr_running--; dequeue_task(p, p-\u0026gt;array); p-\u0026gt;array = NULL;  检查运行队列中剩于的可运行进程数。如果有可运行进程，但是当前内核支持超线程技术，且可运行进程比在相同物理 CPU 的某个逻辑 CPU 上运行的兄弟进程优先级低，p-\u0026gt;sleep_avg直接去执行 swapper 进程。 如果没有可运行进程，函数调用 idle_balance()，从其他 CPU 迁移一些可运行进程到本地队列中。如果本地队列还是没有可运行进程，就重新调度空闲 CPU 的可运行进程。如果还是没有，则直接去执行 swapper 进程。 到这里运行队列中一定有可运行进程。检查运行队列中是否至少有一个进程是活动的(rq-\u0026gt;active-\u0026gt;nr_active\u0026gt;0)。如果没有，交换活动队列和过期队列的指针。  确定优先级最高的进程 next #   在优先级数组中查找第一个非 0 的位图对应的链表的第一个进程描述符，并赋值给 next。\n  检查 next-\u0026gt;activate 字段，该字段编码值表示进程在被唤醒时的状态，如下表：\n如果 next 是一个普通进程，并且 activate 为 1 或 2，就把自从进程插入运行队列开始所经过的纳秒数加到进程的平均睡眠时间。但是 1 和 2 的情况还是有区别，在 2 的情况下，增加全部运行队列等待时间，在 1 的情况下，只增加等待时间的部分。这是因为交互式进程更可能被异步事件(如键盘)而不是同步事件唤醒。\nif (next-\u0026gt;prio \u0026gt;= 100 \u0026amp;\u0026amp; next-\u0026gt; activate \u0026gt; 0){  unsigned long long delta = now – next-\u0026gt;timestamp;  if ( next-\u0026gt; activate == 1)  delta = (delta * 38) / 128;  array = next-\u0026gt;array;  dequeue_task(next, array);  recalc_task_prio(next, next-\u0026gt;timestamp + delt- ;  enqueue_task(next, array); } next-\u0026gt; activate = 0;   完成进程切换 #  如果最终的候选进程就是当前进程，释放自旋锁，不做进程切换，直接结束。 否则执行进程切换： next-\u0026gt;timestamp = now; rq-\u0026gt;nr_switches ++; rq-\u0026gt;current = next; prev = context_switch(rq, prev, next) 其中 context_switch()函数建立 next 的地址空间。  如果 next 是内核进程，则借用 prev 的 active_mm。 if ( ! next_mm ){ next-\u0026gt;active_mm = prev-\u0026gt;active_mm; atomic_inc(\u0026amp;prev-\u0026gt;active_mm-\u0026gt;mm_count); enter_lazy_tlb( prev-\u0026gt;active_mm, next) }  如果 next 是普通进程，则执行 switch_mm 切换用户空间，把虚拟内存从上一个进程映射切换到新进程中。 if ( next_mm ){ switch_mm( prev-\u0026gt;active_mm, next-\u0026gt;mm, next); }    如果 prev 是内核进程或正在退出的进程： if ( ! prev_mm ){  rq-\u0026gt;prev_mm = prev-\u0026gt;active_mm;  prev-\u0026gt;active_mm = NULL; }  调用 switch_to()进行真正的进程切换，从上一个进程的处理器状态切换到新进程的处理器状态，包括保存、恢复栈信息和寄存器信息。 switch_to( prev, next, prev);   进程切换之后的操作 #   当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 p-\u0026gt;sleep_avg时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。进程切换后的第一部分指令是：\nbarrier(); finish_task_switch( prev); 其中 finish_task_switch(prev) 函数如下：\nmm = this_rq()-\u0026gt;prev_mm; this_rq()-\u0026gt;prev_mm = NULL; prev_task_flags = prev-\u0026gt;flags; spin_unlock_irq(\u0026amp; this_rq()-\u0026gt;lock); if (mm)  mmdrop(mm) if (prev_task_flags \u0026amp; PF_DEAD)  put_task_struct( prev); 其中 mmdrop()减少内存描述符的使用计数器。如果减到了 0，释放与页表相关的所有描述符和虚拟存储区。put_task_struct()释放进程描述符使用计数器，并撤销所有其余对该进程的引用。\n  p-\u0026gt;sleep_avg函数最后一部分代码如下。包括在需要的时候重新获得大内核锁，重新启用内核抢占，并检查是否一些其他的进程已经设置了当前进程的 TIF_NEED_RESCHED。如果是，则整个 p-\u0026gt;sleep_avg函数重新执行，否则函数结束。\nprev = current; if (prev-\u0026gt;lock_depth \u0026gt;= 0)  __reacquire_kernel_lock(); preempt_enable_no_resched(); if (test_bit(TIF_NEED_RESCHED, \u0026amp;current_thread_info() -\u0026gt; flags))  goto need_resched; return;   多处理器系统中运行队列的平衡 #  从 Linux2.6.7 版本开始，Linux 提出一种基于“调度域”概念的复杂的运行队列平衡算法，从而能够容易适应各种已有的多处理器体系结构。并提供了以下函数：\n  rebalance_tick()函数会在每一次时钟节拍到来时由 scheduler_tick()调用，负责周期性、在需要的时候调用 load_balance()函数。\n  load_balance()函数检查调度域是否处于严重的不平衡状态，如果是，将会尝试调用 move_task()函数把一些进程从一个运行队列迁移到另一个运行队列。\n  move_task()函数负责把进程从源运行队列迁移到本地运行队列。\n  其中比较重要的 load_balance()函数可简单描述为如下操作：\n1、 调用 find_busiest_queue()，找到最繁忙的可运行队列，即该队列中的进程数目最多。如果没有哪个可运行队列中进程的数目比当前队列中的数目多 25%或更多，就返回 NULL，并且 load_balance()函数也返回。否则返回最繁忙的可运行队列。\n2、 从最繁忙的运行队列中选择一个优先级数组以便抽取进程，最好是过期数组，因为那里面的进程已经相当较长一段时间没有运行了，很可能不在 CPU 的高速缓存中。如果过期数组为空，那就只能选活动数组。\n3、 找到含有进程并且优先级最高的链表。\n4、 分析找到的所有这些优先级相同的进程，选择一个不是正在执行，也不会因为 CPU 相关性而不可移动，并且不在高速缓存中的进程。如果有进程满足以上条件，调用 move_task()将其从最繁忙的队列迁移到当前队列。\n5、 只要可运行队列之间仍然不平衡，就重复上面两个步骤，最终达到平衡。此时，解除对当前运行队列的锁定，从 load_balance()返回。\n抢占 #  用户抢占 #  用户抢占是指在内核即将返回用户空间的时候，如果 need_resched 标志被设置，会导致 p-\u0026gt;sleep_avg被调用，此时就发生了用户抢占。与延迟调用小节描述的一样，用户抢占在从系统调用或中断处理程序返回用户空间时发生。\n内核抢占 #  在不支持内核抢占的内核中，内核代码可以一直执行，直到完成返回用户空间或者明显的阻塞为止。也就是说，调度程序没办法在一个内核任务正在执行的时候发起调度。在 2.6 版本的内核中，引入了内核抢占能力，只要重新调度是安全的，即，只要没有持有锁，那么正在执行的代码就是可重新导入的，内核就可以在任何时间抢占正在执行的任务。\n为了支持内核抢占，为每个进程的 thread_info 引入了 preempt_count 计数器。该计数器初始值为 0，每当使用锁的时候加 1，释放锁的时候减 1.当该值为 0 时，表示内核可以抢占。\n因此，从中断返回内核空间的时候，内核会检查 need_resched 和 preempt_count 的值。如果 need_resched 被设置，且 preempt_count 为 0，说明有一个更为重要的任务需要执行并且可以安全的抢占，此时，调度程序就会被调用。此外，如果当前进程持有的所有锁都被释放了，此时会去检查 need_resched 是否被设置，如果是就调用调度程序。\n如果内核中的进程被阻塞了，或它显示地调用 p-\u0026gt;sleep_avg，内核抢占就显式地发生，这种形式的内核抢占一直都是支持的，因为无需额外的逻辑来保证内核可以安全的被抢占。\n楼梯调度算法与 RSDL 调度算法 #  O(1)调度器区分交互式进程和批处理进程的算法与以前虽大有改进，但仍然在很多情况下会失效。有一些著名的程序(如 fiftyp.c, thud.c, chew.c, ring-test.c)总能让该调度器性能下降，导致交互式进程反应缓慢。\n为了解决这些问题，大量难以维护和阅读的复杂代码被加入 Linux2.6.0 的调度器模块，虽然很多性能问题因此得到了解决，可是另外一个严重问题始终困扰着许多内核开发者。那就是代码的复杂度问题。这些不足催生了 Con Kolivas 的楼梯调度算法 SD，为调度器设计提供了一个新的思路。之后的 RSDL 和 CFS 都基于 SD 的许多基本思想。\n楼梯调度算法 #  O(1)调度器算法的主要复杂性来自动态优先级的计算，调度器根据平均睡眠时间和一些很难理解的经验公式来修正进程的优先级以及区分交互式进程。这样的代码很难阅读和维护。\n楼梯调度算法(staircase scheduler)抛弃了动态优先级的概念，而采用了一种完全公平的思路。其思路虽然简单，但是实验证明它对应交互式进程的响应比 O(1)调度器更好，而且极大地简化了代码。\n和 O(1)调度器一样，楼梯算法也同样为每一个优先级维护一个进程队列，并将这些队列组织在 active 数组中。当选取下一个被调度进程时，SD 算法也同样从 active 数组中直接读取。 与 O(1)算法不同在于，当进程用完了自己的时间片后，并不是被移到 expire 数组中。而是被加入 active 数组的低一优先级列表中，即将其降低一个级别。不过请注意这里只是将该任务插入低一级优先级任务列表中，任务本身的优先级并没有改变。当时间片再次用完，任务被再次放入更低一级优先级任务队列中。就像一部楼梯，任务每次用完了自己的时间片之后就下一级楼梯。\n任务下到最低一级楼梯时，如果时间片再次用完，它会回到初始优先级的下一级任务队列中。比如某进程的优先级为 1，当它到达最后一级台阶 140 后，再次用完时间片时将回到优先级为 2 的任务队列中，即第二级台阶。不过此时分配给该任务的 time_slice 将变成原来的 2 倍。比如原来该任务的时间片 time_slice 为 10ms，则现在变成了 20ms。基本的原则是，当任务下到楼梯底部时，再次用完时间片就回到上次下楼梯的起点的下一级台阶。并给予该任务相同于其最初分配的时间片。总结如下：设任务本身优先级为 P，当它从第 N 级台阶开始下楼梯并到达底部后，将回到第 N+1 级台阶。并且赋予该任务 N+1 倍的时间片。\n以上描述的是普通进程的调度算法，实时进程还是采用原来的调度策略，即 FIFO 或者 Round Robin。\n楼梯算法能避免进程饥饿现象，高优先级的进程会最终和低优先级的进程竞争，使得低优先级进程最终获得执行机会。\n对于交互式应用，当进入睡眠状态时，与它同等优先级的其他进程将一步一步地走下楼梯，进入低优先级进程队列。当该交互式进程再次唤醒后，它还留在高处的楼梯台阶上，从而能更快地被调度器选中，加速了响应时间。\n从实现角度看，SD 基本上还是沿用了 O(1)的整体框架，只是删除了 O(1)调度器中动态修改优先级的复杂代码；还淘汰了 expire 数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。\nRSDL 调度算法 #  RSDL（The Rotating Staircase Deadline Schedule）也是由 Con Kolivas 开发的，它是对 SD 算法的改进。核心的思想还是“完全公平”。没有复杂的动态优先级调整策略。\nRSDL 重新引入了 expire 数组。它为每一个优先级都分配了一个 “组时间配额”， 我们将组时间配额标记为 Tg；同一优先级的每个进程都拥有同样的\u0026quot;优先级时间配额\u0026quot;，本文中用 Tp 表示，以便于后续描述。\n当进程用完了自身的 Tp 时，就下降到下一优先级进程组中。这个过程和 SD 相同，在 RSDL 中这个过程叫做 minor rotation。请注意 Tp 不等于进程的时间片，而是小于进程的时间片。下图表示了 minor rotation。进程从 priority1 的队列中一步一步下到 priority140 之后回到 priority2 的队列中，这个过程如下图左边所示，然后从 priority 2 开始再次一步一步下楼，到底后再次反弹到 priority3 队列中。\n在 SD 算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得 CPU。因此低优先级进程的等待时间无法确定。RSDL 中，当高优先级进程组用完了它们的 Tg(即组时间配额)时，无论该组中是否还有进程 Tp 尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是 RSDL 中 Deadline 代表的含义。 进程用完了自己的时间片 time_slice 时（下图中 T2），将放入 expire 数组中它初始的优先级队列中(priority 1)。\n当 active 数组为空，或者所有的进程都降低到最低优先级时就会触发 major rotation：。Major rotation 交换 active 数组和 expire 数组，所有进程都恢复到初始状态，再一次从新开始 minor rotation 的过程。\n和 SD 同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为 minor rotation 而降到了低优先级进程队列中。当它重新进入 RUNNING 状态时，就获得了相对较高的优先级，从而能被迅速响应。\nCFS 完全公平调度算法 #  CFS 是最终被内核采纳的调度器。它从 RSDL/SD 中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS 的算法和实现都相当简单，众多的测试表明其性能也非常优越。\n按照作者 Ingo Molnar 的说法：\u0026ldquo;CFS 百分之八十的工作可以用一句话概括：CFS 在真实的硬件上模拟了完全理想的多任务处理器\u0026rdquo;。在“完全理想的多任务处理器“下，每个进程都能同时获得 CPU 的执行时间。当系统中有两个进程时，CPU 的计算时间被分成两份，每个进程获得 50%。然而在实际的硬件上，当一个进程占用 CPU 时，其它进程就必须等待。这就产生了不公平。\n假设 runqueue 中有 n 个进程，当前进程运行了 10ms。在“完全理想的多任务处理器”中，10ms 应该平分给 n 个进程(不考虑各个进程的 nice 值)，因此当前进程应得的时间是(10/n)ms，但是它却运行了 10ms。所以 CFS 将惩罚当前进程，使其它进程能够在下次调度时尽可能取代当前进程。最终实现所有进程的公平调度。下面将介绍 CFS 实现的一些重要部分，以便深入地理解 CFS 的工作原理[5]。\nCFS 如何选取下一个要调度的进程 #  CFS 抛弃了 active/expire 数组，而使用红黑树选取下一个被调度进程。所有状态为 RUNABLE 的进程都被插入红黑树。在每个调度点，CFS 调度器都会选择红黑树的最左边的叶子节点作为下一个将获得 cpu 的进程。\ntick 中断 #  在 CFS 中，tick 中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记 need_resched 标志，中断返回时就会调用 scheduler()完成进程切换。否则当前进程继续占用 CPU。从这里可以看到 CFS 抛弃了传统的时间片概念。Tick 中断只需更新红黑树，以前的所有调度器都在 tick 中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。\n红黑树键值计算 #  理解 CFS 的关键就是了解红黑树键值的计算方法。该键值由三个因子计算而得：一是进程已经占用的 CPU 时间；二是当前进程的 nice 值；三是当前的 cpu 负载。\n进程已经占用的 CPU 时间对键值的影响最大，其实很大程度上我们在理解 CFS 时可以简单地认为键值就等于进程已占用的 CPU 时间。因此该值越大，键值越大，从而使得当前进程向红黑树的右侧移动。另外 CFS 规定，nice 值为 1 的进程比 nice 值为 0 的进程多获得 10%的 CPU 时间。在计算键值时也考虑到这个因素，因此 nice 值越大，键值也越大。\n在本文中，我们将为每个进程维护的变量称为进程级变量，为每个 CPU 维护的称作 CPU 级变量，为每个 runqueue 维护的称为 runqueue 级变量。\nCFS 为每个进程都维护两个重要变量：fair_clock 和 wait_runtime。进程插入红黑树的键值即为 fair_clock – wait_runtime。\n fair_clock 从其字面含义上讲就是一个进程应获得的 CPU 时间，即等于进程已占用的 CPU 时间除以当前 runqueue 中的进程总数； wait_runtime 是进程的等待时间。它们的差值代表了一个进程的公平程度。该值越大，代表当前进程相对于其它进程越不公平。  对于交互式任务，wait_runtime 长时间得不到更新，因此它能拥有更高的红黑树键值，更靠近红黑树的左边。从而得到快速响应。 红黑树是平衡树，调度器每次总最左边读出一个叶子节点，该读取操作的时间复杂度是 O(LgN)。\n调度器管理器 #  为了支持实时进程，CFS 提供了调度器模块管理器。各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块。2.6.23 中，CFS 实现了两个调度算法，CFS 算法模块和实时调度模块。对应实时进程，将使用实时调度模块。对应普通进程则使用 CFS 算法。Ingo Molnar 还邀请 Con Kolivas 可以将 RSDL/SD 写成一个调度算法模块。\nCFS 源代码分析 #  每次时钟中断会调用 scheduler_tick()函数。它首先更新 runqueue 级变量 clock；然后调用 CFS 的 tick 处理函数 task_tick_fair()。task_tick_fair 主要工作是调用 entity_tick()。函数 entiry_tick 源代码如下：\nstatic void entity_tick(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  struct sched_entity _next;  dequeue_entity(cfs_rq, curr, 0);  enqueue_entity(cfs_rq, curr, 0);  next = **pick_next_entity(cfs_rq);  if (next == curr)  return;  __check_preempt_curr_fair(cfs_rq, next, curr,  sched_granularity(cfs_rq)); } 首先调用 dequeue_entity()函数将当前进程从红黑树中删除，再调用 enqueue_entity()重新插入。这两个动作就调整了当前进程在红黑树中的位置。_pick_next_entity()返回红黑树中最左边的节点，如果不再是当前进程，就调用_check_preempt_curr_fair。该函数设置调度标志，当中断返回时就会调用 p-\u0026gt;sleep_avg进行调度。 函数 enqueue_entity()的源码如下:\nenqueue_entity(struct cfs_rq _cfs_rq, struct sched_entity _se, int wakeup) {  update_curr(cfs_rq);  if (wakeup)  enqueue_sleeper(cfs_rq, se);  update_stats_enqueue(cfs_rq, se);  __enqueue_entity(cfs_rq, se); } 它的第一个工作是更新调度信息。然后将进程插入红黑树中。其中 update_curr()函数是核心。完成调度信息的更新:\nstatic void update_curr(struct cfs_rq _cfs_rq) { struct sched_entity _curr = cfs_rq_curr(cfs_rq); unsigned long delta_exec; if (unlikely(!curr)) return; delta_exec = (unsigned long)(rq_of(cfs_rq)-\u0026gt;clock - curr-\u0026gt;exec_start); curr-\u0026gt;delta_exec += delta_exec; if (unlikely(curr-\u0026gt;delta_exec \u0026gt; sysctl_sched_stat_granularity)) { __update_curr(cfs_rq, curr); curr-\u0026gt;delta_exec = 0; } curr-\u0026gt;exec_start = rq_of(cfs_rq)-\u0026gt;clock; } 该函数首先统计当前进程所获得的 CPU 时间，rq_of(cfs_rq)-\u0026gt;clock 值在 tick 中断中被更新，curr-\u0026gt;exec_start 就是当前进程开始获得 CPU 时的时间戳。两值相减就是当前进程所获得的 CPU 时间。将该变量存入 curr-\u0026gt;delta_exec 中。然后调用__update_curr():\n__update_curr(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  unsigned long delta, delta_exec, delta_fair, delta_mine;  struct load_weight _lw = \u0026amp;cfs_rq-load;  unsigned long load = lw-\u0026gt;weight;  delta_exec = curr-\u0026gt;delta_exec;  schedstat_set(curr-\u0026gt;exec_max, max((u64)delta_exec, curr-\u0026gt;exec_max));  curr-\u0026gt;sum_exec_runtime += delta_exec;  cfs_rq-\u0026gt;exec_clock += delta_exec;  if (unlikely(!load)) return;  delta_fair = calc_delta_fair(delta_exec, lw);  delta_mine = calc_delta_mine(delta_exec, curr-\u0026gt;load.weight, lw);  if (cfs_rq-\u0026gt;sleeper_bonus \u0026gt; sysctl_sched_min_granularity) {  delta = min((u64)delta_mine, cfs_rq-\u0026gt;sleeper_bonus);  delta = min(delta, (unsigned long)((long)sysctl_sched_runtime_limit - curr-\u0026gt;wait_runtime));  cfs_rq-\u0026gt;sleeper_bonus -= delta;  delta_mine -= delta;  }  cfs_rq-\u0026gt;fair_clock += delta_fair;  add_wait_runtime(cfs_rq, curr, delta_mine - delta_exec); } __update_curr()的主要工作就是更新前面提到的 fair_clock 和 wait_runtime。这两个值的差值就是后面进程插入红黑树的键值。变量 Delta_exec 保存了前面获得的当前进程所占用的 CPU 时间。函数 calc_delta_fair()根据 cpu 负载（保存在 lw 变量中），对 delta_exec 进行修正，然后将结果保存到 delta_fair 变量中，随后将 fair_clock 增加 delta_fair。函数 calc_delta_mine()根据 nice 值（保存在 curr-\u0026gt;load.weight 中）和 cpu 负载修正 delta_exec，将结果保存在 delta_mine 中。根据源代码中的注释，delta_mine 就表示当前进程应该获得的 CPU 时间。\n随后将 delta_fair 加给 fair_clock 而将 delta_mine-delta_exec 加给 wait_runtime。函数 add_wait_runtime 中两次将 wait_runtime 减去 delta_mine-delta_exec。由于 calc_delt_xx()函数对 delta_exec 仅做了较小的修改，为了讨论方便，我们可以忽略它们对 delta_exec 的修改。最终的结果可以近似看成 fair_clock 增加了一倍的 delta_exec，而 wait_runtime 减小了两倍的 delta_exec。因此键值 fair_clock-wait_runtime 最终增加了一倍的 delta_exec 值。键值增加，使得当前进程再次插入红黑树中就向右移动了。\nCFS 小结 #  以上的讨论看出 CFS 对以前的调度器进行了很大改动。用红黑树代替优先级数组；用完全公平的策略代替动态优先级策略；引入了模块管理器；它修改了原来 Linux2.6.0 调度器模块 70%的代码。结构更简单灵活，算法适应性更高。相比于 RSDL，虽然都基于完全公平的原理，但是它们的实现完全不同。相比之下，CFS 更加清晰简单，有更好的扩展性。\nCFS 还有一个重要特点，即调度粒度小。CFS 之前的调度器中，除了进程调用了某些阻塞函数而主动参与调度之外，每个进程都只有在用完了时间片或者属于自己的时间配额之后才被抢占。而 CFS 则在每次 tick 都进行检查，如果当前进程不再处于红黑树的左边，就被抢占。在高负载的服务器上，通过调整调度粒度能够获得更好的调度性能。\n在最新版本的 CFS 实现中，内核使用虚拟运行时间 vruntime 替代了等待时间，但是基本的调度原理和排序方式没有太多变化。\n参考资料 #  [1] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核[M]. 中国电力出版社, 2001.\n[2] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核(第三版)[M]. 中国电力出版社, 2007.\n[3] 陈莉君, 康华. Linux 操作系统原理与应用[M]. 清华大学出版社, 2006.\n[4] RobertLove, 洛夫, 陈莉君, et al. Linux 内核设计与实现[M]. 机械工业出版社, 2006.\n[5] Linux 调度器发展简述 https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/\n[6] O(n)、O(1)和 CFS 调度器 http://www.wowotech.net/process_management/scheduler-history.html\n[7] 调度系统设计精要 https://draveness.me/system-design-scheduler/\n[8] 进程调度之 6：进程的调度与切换 https://my.oschina.net/u/3857782/blog/1857556\n"},{"id":6,"href":"/docs/cs/the-clean-coder/","title":"The Clean Coder","section":"计算机","content":"《The Clean Coder》 阅读记录 #  术道结合，这本书不教术，更多的传道，且不仅仅适用于职业，还适用于处理其他事物。尽管是只可意会的道，依然可以通过娓娓道来的叙述与提炼，使读者联系自身经历，揣摩体悟，纳为己用。\n0、关于职业素养 #  如何体现职业素养？\n从自身出发，回答一个问题：在过去的工作中，遇到过哪些印象深刻的困难，最后是怎么解决的？ 问题不在于问题的难度，而在于反思的程度：怎么分析问题、查阅什么资料、采取解决问题的方式步骤、采取什么措施避免和改进。\n从外部出发，是否对外展示了专业精神获得外部人员的信任？是否需要对你进行微观管理才能令人放心？\n总结起来，职业素养 = 能力（技术） + 素质（价值观、原则、态度）+ 持续的积累和养成。\n关于价值观，可阅读前言部分 “挑战者”号航天飞机工程师的故事。  1、专业主义 #  “哦！笑吧，科延，老伙计。这是上帝，或者也可以说时命运或自然，跟我们开的一个玩笑。不过，不管这家伙是谁或是什么，他真幽默！哈哈！” —— 霍华德，《碧血金沙》    清楚你到底要的是什么？真的是成为专业人士吗？不仅仅是荣誉与骄傲，更多的是责任与义务。\n  担当责任，不仅如何保全自己，还有客户及他人。\n  不行损害之事：让 QA 找不出任何问题 + TDD 100% 覆盖率的要求 + 随时重构 + 自动化 QA  0、就像医生一样，虽然 Bug 无法避免，但是需要为出现的 Bug 负责。 1、练习道歉，道歉时必要的。 2、不能铭记过去的人，注定要重蹈覆辙。有责任让失误率无限接近零。     专业人士的职业生涯：\n 了解你的领域，如设计模式。过去来之不易的理念，大部分依然像过去一样富有价值。 坚持学习，与时俱进：想想你会去找已经不看医学期刊的医生看病、会聘请不了解最新税法和判例的税务律师吗？ 需要投入时间和精力去追求和练习（想想音乐家的表演和练习）。因为热爱，额外的20小时能让你免于枯竭匮乏。 合作与辅导是必要的。 了解业务领域：不可以不求甚解，能辨别与质疑。 与雇主 / 客户保持一致：站在雇主的角度思考，而开发人员之间互相认同是容易的，应当避免狭隘之见。 谦逊。  编程是及其自负的行为，专业人士知道此，因此不会故作谦逊：他们熟知自己的工作，并引以为荣；他们对自己的能力充满自信，并因此用于承担有把握的风险。专业人士不是胆小鬼。 然而，专业人士也知道自己会摔跟头，自己的风险评估也有出错的时候，自己也有力不从心的时候。这时候，如果他们照照镜子，会看到那个自负的傻瓜正对着自己笑。 因此，在发现自己成为笑柄时，专业人士会第一个发笑。他从不会嘲讽别人，自作自受时他会接受别人的嘲讽。反之，他则会一笑了之。他不会因别人犯错就对之横加贬损，因为他知道，自己就是下一个犯错的人。 专业人士都清楚自己的自负，也知道上天会注意到这种自负，并加以惩戒。如若果真遭遇挫折，最好的办法就是按照霍华德说的————一笑了之吧！       2、说不 #  “能就是能，不能就是不能。不要说‘试试看’。” ———— 尤达  奴隶没有权利说“不”。劳工或许也对说“不”有所顾虑。但是专业人士应该懂得说“不”。只有敢于说“不”，才能真正做成一些事情。  2.1 对抗角色 #  13、团队与项目 #   有凝聚力的团队：团队组建、克服差异（一起搞定一切）、多个项目中整体移动 给足时间，成为引擎，军团  14、辅导、学徒期与职业素养 #   导师很重要，可以更好、更加顺利地跨过一些坎。 可以有多种形式的辅导。 软件学徒期是必要的，类比医学生（人命关天） 职业素养：能力（技术）和素质（价值观、原则、态度），以及持续的积累和养成。 非理性决策，非感情用事，只要能被人观察到，便具有传染性：成为表率，向人展示即可。  15、工具 #   使用工具，不再是思考下一步要键入什么字符或代码，而是思考接下来要对代码进行什么样的变换。  "},{"id":7,"href":"/docs/example/table-of-contents/without-toc/","title":"Without ToC","section":"Table of Contents","content":"At me ipso nepotibus nunc celebratior genus #  Tanto oblite #  Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius #  Quibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\n Remansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit  Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae #  Credulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\n Baculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra  Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"},{"id":8,"href":"/docs/algorithm/tree/1/","title":"二叉树 - 子树分解题","section":"二叉树","content":"二叉树 - 子树分解题 #  基础 #   https://leetcode-cn.com/problems/diameter-of-binary-tree/ https://leetcode-cn.com/problems/invert-binary-tree/submissions/ https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/  构造题 #   https://leetcode-cn.com/problems/maximum-binary-tree/  "},{"id":9,"href":"/docs/algorithm/tree/3/","title":"二叉树 - 构造题","section":"二叉树","content":"二叉树 - 构造题 #   https://leetcode-cn.com/problems/maximum-binary-tree/ https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/  "},{"id":10,"href":"/docs/algorithm/tree/2/","title":"二叉树 - 遍历题","section":"二叉树","content":"二叉树 - 遍历题 #   https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/  "},{"id":11,"href":"/docs/law/shang-ru-gong-si-fa/","title":"商入公司法","section":"法类","content":"“商入公司法” #  商法调整的是商事关系，商事几乎包括各种以营利为的商品交换以及与此相关的其他活动。\n一般而言，商事关系具有以下特征：一是主体的平等性；二是只发生在以营利为目的而进行的商事活动过程，这是商事关系区分于其他法律关系尤其是普通民事关系的最重要的特点。营利至少包括获取利益、常业性。\n商法按内容来分包括商事组织法与商事行为法。\n 商组织作为从事商活动的主体，关系到方方面面，法律自然要设定规范，规制其准入与存续。商组织法包括商事主体的设立、组织、管理、变更、解散、破产、清算而发生的内外关系。对外关系主要由债等民法调整，因而主要是对内关系。 商行为存在着商活动的特性，有别于一般的民事行为，因而也被特殊规定。商行为法包括票据法、证券法、保险法和海商法等商法部门。  公司法是最主要的商组织法。\n公司本质 #  公司的法律性质即为最底层的法律原则。\n公司概念 #  在大陆法系国家，公司仅指具有法人资格的营利性社团，从实质来看，它至少具有三个要素构成，即独立的人格、个人结合的社团、以营利为目的；在形式上它还要满足依法设立，即依据商事法律规定的条件和程序而设立公司。\n人格性 #  指公司具有独立的人格，这种独立的人格使其能够区别于其成员而独立存在。\n人格是权利义务的归属点，拥有人格意味着公司具有权利能力和行为能力，能够享有权利，承担义务。能够独立从事经营活动，实施法律行为，并能够依法承担民事责任。\n公司人格的外征表现：名称（区分）、独立财产（承担责任，公司的财产丧失可能导致人格也消灭）、自己的组织机构（意志形成、行为执行）。\n公司需要依法登记才能取得独立人格地位。因此在一定意义上可以说完全是法律的产物，是法律上的一种拟制。（1）采用二元主体的民事架构，最主要的目的在于方便公司从事各种经营活动；（2）拟制并不意味着有实体，因而公司人格具有可否认性。\n社团性 #  即以社员的结合作为其成立基础，我国《公司法》采用的是企业法人，民法典表达为“营利主义”。现代公司法显示承认一人公司的存在已成为时代的潮流，我国现行公司法也已经突破了公司的社团性，规定了一人有限责任公司。\n营利性 #  以营利为目的指组织公司成员各自以其出资经营某项事业并将公司所获得的利益分配给它的社员作为最终目的。\n公司企业存在的目的在于追求利润最大化，表现为（1）股利的分配；（2）剩余财产的分配。\n现代公司法要求公司在考虑利润最大化目标时，也要兼顾“利益相关者（stakeholder/other constituencies）”的利益，即承担一定的社会责任。\n公司特征 #  制度的价值、作用，主要内容，法律立场。\n即公司这种企业区别于其他商事组织，而使其成功的原因特征：集中管理、所有人的有限责任、的股权自由转让和公司的永久存在。\n集中管理 #  所有权和经营权的分离，将公司交给更具备专业技术经验的经营者。但集中管理在封闭公司是不明显的。\n 投资者有限责任的产生：既然股东不能直接参与企业管理，又怎么能够像合伙人承担无限责任呢 所有者权益的自由转让：如果股东对公司经营不满意，他可以通过股权转让退出公司。 公司的独立主体地位：只要投资人愿意，公司可以无限期地存在。  有限责任 #  按认缴的出资额或认购的股份份额承担责任。核心是在公司和其股东划出一条明显的界限。“简单来讲，对于投资者而言其可以多项投资，更敢更省事；对于实际经营管理者而言，只有公司经营良好才不至于使股权被收购自己被替换。”\n 降低监控代理人的成本，投资人可以多样化投资来分散风险，也可以多样化和消极监督 降低监控其他股东的成本，合伙制情形下合伙人还要监督其他合伙人的财产状况 股份自由转让会刺激管理层进行更为有效的管理 有限责任存在股份交易的公开市场，价格能够极大的企业价值的附加信息，减少投资人花费大量资源去考察附加信息 投资者可以多样化投资，这也大大降低了企业筹资成本 促进投资者投资风险事业的投资而不至于遭受毁灭性损失  股权自由转让 #  公众公司存在为其股份转让的公开市场。\n 股东可以自由退出而公司资本不致减少 促使公司管理水平的提高 公开市场能够最大限度地反映财产的价值  公司的永久存在 #  实际含义是公司不会像合伙企业那样因为成员的退出而导致解散，合伙的存在依附于合伙协议。公司”永续存在“，但其控制权却可能发生了无数次的易手。\n公司法律性质探讨 #  基于法理和体系的视角中，进一步挖掘的公司的本质特征。\n法人说 #  公司是法人，具有独立的主体地位。公司完全是法律的产物，公司的设立和运作均需要依照法律的规定进行。公司法具有明显的强制性特征。\n法人理论受到了相当的批评，其认为法人说片面强调形式主义，公司是一种虚拟的实体，而非真实意义上的人，公司之所以是”法人“，只不过是因为法律进行了这样的，而公司之所以讲公司拟人化，主要是为了方便人们从事商事经营活动。\n批评者进一步分析，人们常将有限责任、法人身份以及永久存在视为公司的显著特征，这其实是一种误导性陈述。\n 有限责任只是意味着投资者所承担的企业风险不会超过其初始成本，这是投资的特征而非公司的特征。 法人身份和永久存在仅仅意味着公司在解散之前持续存在，并且有一个名称以便于交易和应付诉讼，否则公司在进行某一项交易时，公司都需要次次明确公司所有投资者的名单及份额。  公司法人虚拟性的一个反正是在特定而有限的情况下，如果这种虚拟实体实施了欺诈行为或明显违反法律政策或是实施了其他有害行为，法律可以适用“揭开公司面纱”原则否认其人格。\n契约关系说 #  公司完全是由当事人一系列协议构成，当事人有权对诸如公司治理等问题进行自主安排。\n契约关系理论认为企业是雇员、管理者、股东等资源结合起来自行安排各种交易，他们共同收到一种复杂的契约关系链条的约束。\n企业并不是某种人格化的东西，而是在组成企业的各种要素之间确定了一系列合约安排，即一系列合同束。除了当事人约定的合同之外，有一些合同体现着法院和立法者的意志，这类合同的作用在于，它有如人们在遇到类似问题而真正订立合同时必然会采用这样的条款一样。\n其中体现了经济学家与法学家极为不同的差异，即对于隐形合同的认可与否，法学家认为合同在于传统的要约承诺，公众公司从来没有阅读过公司章程，最多只能说他们接受这份章程，而不可能认定是预定的。\n契约论实际上是应然而非实然，即这样的合同内容符合追利人的期待，是节省成本的一种安排，自由订立也会选择该规范。\n契约关系论反对公司法人理论，认为“公司的法人性恰恰掩盖了交易的本质”，因为每一根人只拥有自己投入的一部分，任何人无权对公司享有全部所有权。公司中的中心人物是管理者。\n相反地，其认为公司只不过是一种契约关系，政府不能对私人商业活动干预，政府不应该通过制定法形式讲强制性规范加于公司或当事人。而政府的特许令状不过是对于公司这种契约的承认而已，并诉讼方便，交易便利。\n契约论最重要的优点在于转变公司法的规范态度，给公司更多的活性，能够更加充分的发挥公司的优势，自由管理主体优势。\n"},{"id":12,"href":"/docs/example/table-of-contents/","title":"Table of Contents","section":"Example Site","content":"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":13,"href":"/docs/example/collapsed/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":"4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":14,"href":"/docs/example/collapsed/3rd-level/","title":"3rd Level","section":"Collapsed","content":"3rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":15,"href":"/docs/example/hidden/","title":"Hidden","section":"Example Site","content":"This page is hidden in menu #  Quondam non pater est dignior ille Eurotas #  Latent te facies #  Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona #  O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris #  Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":16,"href":"/docs/other/%E6%9E%97%E6%AF%85%E5%A4%AB%E8%A7%A3%E8%AF%BB%E4%B8%AD%E5%9B%BD%E7%BB%8F%E6%B5%8E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"林毅夫《解读中国经济》读书笔记","section":"非法类","content":"林毅夫《解读中国经济》读书笔记 #  粗浅读之，即便对于传统的经济学理论没有甚至初级的了解，从零开始，也通过林老师的介绍，收获颇多。简单归纳，以求在知识图谱中扎上这么一段清晰而博大的中国经济知识。\n我将从《解读中国经济》得到的知识分为三类。一是有关中国经济的过去、现在和未来；二是新结构经济学是什么；三是新结构经济学理论将是什么。\n中国经济的过去、现在和未来 #  中国经济的过去、现在和未来是极具代表性的发展中国家的过去、现在和可能的未来。\n过去，中国经济带着和其他发展中经济体的共同共性，寻求可以逐渐发展和现代化的方法。几乎全部的发展中国家一开始选择的是追赶和超过发达国家，一切资源都集中在资本集中型和技术集中型，由政府统一调配。此项政策施行之后，经济发展缓慢，虽然现代化进程有所前进，但是GDP却没有很大的增长。\n经济危机频发后，发达国家主张新自由主义，即鼓吹政府退出干涉，由市场自由调节。于是，又几乎所有的发展中国家直接摒弃之前的政府调配政策，这样的后果是经济危机加剧而发展更加缓慢。 反倒是中国，采用政府调配与市场竞争并行，既有有为政府又有有为市场，反倒是这个开始被大家公认为“两不像”的政策取得了最后的胜利。\n新结构经济学是什么 #  循着这条历史路径，林老师向我们揭开了新结构经济学的序幕。\n新结构经济学，即研究结构的经济学，采用亚当斯密的“原因、本质”的研究方法，探究构成结构的原因与本质，由此构建适合各个国家自己的经济理论。\n新结构经济学的出发点是要素禀赋，由要素禀赋到比较优势，由比较优势决定了产业，以上均围绕最低要素生产成本，并辅之以合适的硬的基础设施和软的制度安排。\n要素禀赋，要素只主要以生产要素为主的一个国家的要素，禀赋指决策者在做决策时考虑的全部东西。决定一个国家发展的因素有很多，但起决定性因素的是要素禀赋，要素禀赋可以简单理解成当一个国家发展经济时，其能够依靠的好与不好的物质因素。\n比较优势，典型的即发展中国家对比发达国家，其特点就是劳动力资源充足，而资本及技术资源劣后，因此，发展中国家的核心优势即是劳动密集型产业。同时，通过从发达国家进口技术与资本，发展中国家能够利用极少的风险和成本，获得产业升级等。而发达国家要进行技术与资本的革新，需要承担极高的成本风险。\n产业，建立于要素禀赋之下。在发展中国家可以分为两类，一类是劳动密集型产业，劳动力成本廉价，会引得市场争相投入，商人有足够的动力，只需要考虑与经济发展方向适合的引导；一类是技术、资本密集型产业，发展国家在该种产业中劣后，动力不足，一旦离开政府的补贴扶持，很容易倾覆，而这一类产业通常是与民生相关的基础产业。\n深入要素禀赋，即是要建立符合各国家自己产业结构的经济发展政策，将各国不同的结构要素考虑在内，而不同于发达国家略去此类因素的二维经济学，是适应各国家的三维经济学。\n新结构经济学将是什么 #  在此基础上，深入对重要结构要素的具体探究，并以中国现在的经济政策作为例子，进一步构建宏观新结构经济理论。\n“这是一个需要理论而且一定能够产生理论的时代，这是一个需要思想而且一定能够产生思想的时代。我们不能辜负了这个时代。”\n经济理论的发展中心往往是世界经济中心，因为经济理论的发展需要素材，而今，发达国家缺的是素材，因为它们的经济已经趋向稳定，大多只是脚注性的研究，而中国经济学家有最新的素材。这是时代赋予我们的使命。\n"},{"id":17,"href":"/docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":"Buttons #  Buttons are styled links that can lead to local page or external link.\nExample #  {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "},{"id":18,"href":"/docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":"Columns #  Columns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne...  \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt;  # Mid Content Lorem markdownum insigne...  \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt;  # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example #  Left Content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   "},{"id":19,"href":"/docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":"Details #  Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample #  {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title Markdown content #  Lorem markdownum insigne\u0026hellip;   "},{"id":20,"href":"/docs/shortcodes/expand/","title":"Expand","section":"Shortcodes","content":"Expand #  Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample #  Default #  {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Expand ↕  Markdown content #  Lorem markdownum insigne\u0026hellip;    With Custom Label #  {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Custom Label ...  Markdown content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.    "},{"id":21,"href":"/docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":"Hints #  Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example #  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  "},{"id":22,"href":"/docs/shortcodes/katex/","title":"Katex","section":"Shortcodes","content":"KaTeX #  KaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample #  {{\u0026lt; katex [display] [class=\u0026#34;text-center\u0026#34;] \u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt; /katex \u0026gt;}}     Display Mode Example #  Here is some inline example:  \\(\\pi(x)\\)  , rendered in the same line. And below is display example, having display: block  \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\]  Text continues here.\n"},{"id":23,"href":"/docs/shortcodes/mermaid/","title":"Mermaid","section":"Shortcodes","content":"Mermaid Chart #  MermaidJS is library for generating svg charts and diagrams from text.\nOverride Mermaid Initialization Config\nTo override the initialization config for Mermaid, create a mermaid.json file in your assets folder!\n Example #  {{\u0026lt; mermaid [class=\u0026#34;text-center\u0026#34;]\u0026gt;}} stateDiagram-v2  State1: The state with a note  note right of State1  Important information! You can write  notes.  end note  State1 --\u0026gt; State2  note left of State2 : This is the note to the left. {{\u0026lt; /mermaid \u0026gt;}}     "},{"id":24,"href":"/docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":"Section #  Section renders pages in section as definition list, using title and description.\nExample #  {{\u0026lt; section \u0026gt;}}   First Page  First page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.   Second Page  Second Page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.   "},{"id":25,"href":"/docs/shortcodes/section/first-page/","title":"First Page","section":"Section","content":"First page #  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":26,"href":"/docs/shortcodes/section/second-page/","title":"Second Page","section":"Section","content":"Second Page #  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":27,"href":"/docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":"Tabs #  Tabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example #  MacOS MacOS #  This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux Linux #  This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows Windows #  This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n "}]