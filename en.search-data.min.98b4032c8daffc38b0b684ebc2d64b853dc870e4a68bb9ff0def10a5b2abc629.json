[{"id":0,"href":"/docs/example/","title":"Example Site","section":"Docs","content":"Introduction #  Ferre hinnitibus erat accipitrem dixi Troiae tollens #  Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\n Pedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret  Est simul fameque tauri qua ad #  Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol #  Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo;  Trepident sitimque #  Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"},{"id":1,"href":"/docs/example/table-of-contents/with-toc/","title":"Linux 进程调度","section":"Table of Contents","content":"Linux 进程调度 #  前言 #  在计算机科学中，调度就是一种将任务（Work）分配给资源的方法。任务可能是虚拟的计算任务，例如线程、进程或者数据流，这些任务会被调度到硬件资源上执行，例如：处理器 CPU 等设备。调度器或调度算法的设计与实现最终都会归结到一个问题上，即如何对有限的资源进行分配以实现资源利用率的最大化并满足特定的需求。\n调度器是操作系统中的重要组件，操作系统中有进程调度器（Process Scheduler）、网络调度器（Network Scheduler）和 I/O 调度器（I/O Scheduler）等组件，本文介绍的是进程调度器。\n进程调度器负责给系统中的所有进程分配有限的 CPU 时间资源。只有通过合理的调度算法，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。\n进程调度算法总是追求达到以下目标：\n 公平：保证每个进程得到合理的 CPU 时间，避免进程的饥饿现象。 高效：尽量充分使用 CPU，使 CPU 保持忙碌状态。 快速的响应时间：使交互用户的响应时间应尽可能短。 周转时间：使批处理用户等待输出的时间尽可能短。 吞吐量：单位时间内处理的进程数量尽可能多。  但是很显然，这几个目标是相互冲突的，不可能同时达到。因此只能在这几个方面进行取舍，从而确定自己的调度算法。\n进程调度器将进程分为三类：\n  交互式进程(Interactive process)：这些进程经常与用户进行交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如命令行 shell、文本编辑程序。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。\n  批处理进程(Batch process)：这些进程一般在后台运行，不必与用户交互，需要占用大量的系统资源。但是能够忍受响应延迟。典型的批处理程序如编译程序、数据库搜索引擎等。\n  实时进程(Real-time process)：这些进程对调度延迟的要求最高，往往执行非常重要的操作，要求立即响应并执行。典型的实时程序比如视频播放软件、或飞机飞行控制系统，很明显这类程序不能容忍长时间的调度延迟。\n  根据进程的不同分类 Linux 采用不同的调度策略。\n对于实时进程，采用 FIFO 或者 Round Robin 的调度策略。\n对于普通进程，则需要区分交互式和批处理式的不同。传统 Linux 调度器提高交互式应用的优先级，使得它们能更快地被调度。而 CFS 和 RSDL 等新的调度器的核心思想是“完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。\n以下列出了 Linux 不同版本调度器的历史：\n 初始调度器 · v0.01 ~ v2.4  由几十行代码实现，功能非常简陋； 同时最多处理 64 个任务；   O(n) 调度器 · v2.4 ~ v2.6  调度时需要遍历全部任务； 当待执行的任务较多时，同一个任务两次执行的间隔很长，会有比较严重的饥饿问题；   O(1) 调度器 · v2.6.0 ~ v2.6.22  通过引入运行队列和优先级数组实现 O(1) 的时间复杂度; 使用本地运行队列替代全局运行队列增强在对称多处理器的扩展性； 通过负载均衡保证多个运行队列中任务的平衡；   完全公平调度器 · v2.6.23 ~ 至今  引入红黑树和运行时间保证调度的公平性； 引入调度类实现不同任务类型的不同调度策略；    本文会详细介绍从最初的调度器到今天复杂的完全公平调度器（Completely Fair Scheduler，CFS）的演变过程。\nLinux 初始的调度算法 #  Linux 最初的进程调度器仅由 sched.h 和 sched.c 两个文件构成。你可能很难想象 Linux 早期版本使用只有几十行的 schedule 函数负责了操作系统进程的调度：\nvoid schedule(void) {  int i,next,c;  struct task_struct ** p;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) {  ...  }  while (1) {  c = -1;  next = 0;  i = NR_TASKS;  p = \u0026amp;task[NR_TASKS];  while (--i) {  if (!*--p) continue;  if ((*p)-\u0026gt;state == TASK_RUNNING \u0026amp;\u0026amp; (*p)-\u0026gt;counter \u0026gt; c)  c = (*p)-\u0026gt;counter, next = i;  }  if (c) break;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p)  if (*p)  (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority;  }  switch_to(next); } 无论是进程还是线程，在 Linux 中都被看做是 task_struct 结构体，所有的调度进程都存储在上限仅为 64 的数组中，调度器能够处理的进程上限也只有 64 个。\n上述函数会先唤醒获得信号的可中断进程，然后从队列倒序查找计数器 counter 最大的可执行进程，counter 是进程能够占用的时间切片数量，该函数会根据时间切片的值执行不同的逻辑：\n 如果最大的 counter 时间切片大于 0，调用汇编语言的实现的 switch_to 切换进程； 如果最大的 counter 时间切片等于 0，意味着所有进程的可执行时间都为 0，那么所有进程都会获得新的时间切片；  Linux 操作系统的计时器会每隔 10ms 触发一次 do_timer 将当前正在运行进程的 counter 减一，当前进程的计数器归零时就会重新触发调度。\nO(n) 调度算法 #  数据结构：进程描述符 #  每个进程都有一个 task_struct 结构。该结构定义在 \u0026lt;include/linux/sched.h\u0026gt; 文件中，其中部分与进程调度相关的字段说明如下：\n  need_resched：调度标志，决定是否调用 schedule() 函数。\n  counter：进程处于可运行状态时所剩于的时钟节拍数。每次时钟中断到来时，update_process_times()对该值减 1。\n 创建新进程时，do_fork()以下列方式设置 current(父)和 p(子)进程的 counter 字段：current-\u0026gt;counter \u0026gt;\u0026gt;=1; p-\u0026gt;counter = current-\u0026gt;counter. 也就是说，父进程剩余的节拍数被分为两部分，一部分给父进程，一部分给子进程。这样做时为了防止通过 fork 子进程的方法无限制地使用 CPU 的时间。    rt_priority：实时进程的实时优先级。取值范围 1-99。\n  nice: 进程的静态优先级，它的值决定了 counter 的初值。nice 的取值范围是-20(优先级高)~19(优先级低)，缺省为 0。该值可通过 nice 系统调用改变。\n  policy： 本进程的调度策：\n SCHED_RR 和 SCHED_FIFO 用于实时进程。SCHED_RR 和 SCHED_FIFO 的调度策略在 rt_priority 不同的时候，都是谁的优先级高谁先执行，唯一的不同是相同优先级的处理： SCHED_RR 是时间片轮转的实时进程。当多个进程具有同一优先级时，采用时间片轮转轮流调度运行。适用于实时性要求较高但每次运行耗时较长的进程。 SCHED_FIFO 是先入先出的实时进程，先占有 CPU 的进程会持续执行，直到退出或者阻塞的时候才会让出 CPU。也只有这时候，其他同优先级的实时进程才有机会执行。适应于实时性要求比较强、而每次运行的耗时又比较短的进程。 SCHED_OTHER 用于普通的分时进程。  除了上面描述的三种调度策略，policy 成员也可以设定 SCHED_YIELD 的标记，它和调度策略无关，主要处理 sched_yield 系统调用的。\n  state: 表示进程当前运行状态：\n  TASK_RUNNING ：该状态表示这个进程可被调度执行而成为当前进程，是进程表达了希望被调度运行的意愿，内核会将该进程的 task_struct 结构加入可运行队列。\n  TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE ：这两个状态都表示进程处于睡眠状态。前者表示浅度睡眠，可被信号唤醒；后者表示深度睡眠。sleep_on 和 wake_up 用于深度睡眠；而 interruptible_sleep_on 和 interruptible_wake_up 则用于浅度睡眠。\n  TASK_ZOMBIE 表示已退出而暂时没有被父进程收回资源的\u0026quot;僵尸\u0026quot;进程。\n  TASK_STOPPED 主要用于调试目的。进程接收到一个 SIGSTOP 信号后就将运行状态改成 TASK_STOPPED 而进入挂起状态，然后在接收到一个 SIGCONT 信号时又恢复继续运行。\n    调度的时机 #  Linux 的调度程序是一个叫 schedule()的函数，由它来执行具体的调度算法。调用 schedule()的时机主要包括：\n直接调用 #    进程入睡时主动调用 schedule()：当现运行进程请求资源被阻塞时，会调用 sleep_on()或 interruptible_sleep_on()进入睡眠状态，这时会执行以下步骤：\n  把当前进程 current 插入到合适的等待队列中。\n  把当前进程 current 的状态修改为 TASK_INTERUPTIBLE 或 TASK_UNINTERUPTIBLE。\n  调用 schedule() 函数。\n  检查那个资源是否可用。如果不，转到第 2 步。\n  一旦那个资源成为可用的，把 current 从等待队列中删除。\n    进程终止时主动调用 schedule()：当现运行进程终止时，会调用 exit() 终止运行，这时会主动调用 schedule() 函数。\n  设备驱动程序执行长而重复的任务时，主动调用 schedule()：驱动程序在每次循环中，都会去检查调度标志 need_resched 的值，如果必要，就调用 schedule()主动放弃 CPU。\n  创建新进程：在 do_fork()中也会调用 schedule() 函数。\n  延迟调用 #  延迟调用是指当系统需要调度时，通过置现运行进程 need_resched 标志为 1。然后在从中断、异常、系统调用等从内核返回用户态时，对该标志进行检测，如果该标志为 1，则调用 schedule()。主要包括以下情况：\n  在中断处理过程中，发现 current 用完了时间片，置 need_resched 标志为 1。\n  一个进程被唤醒，且它的优先级比现运行进程更高，置 need_resched 标志为 1。\n  当父进程 fork 子进程时，其时间片会均分到父子进程。\n 如果只剩下一个 tick，这个 tick 会分配给子进程，而父进程的时间片则被清零，这时候等同于情况 1。 否则，父子进程的时间片都不为 0，这时等同于情况 2。    一个进程通过系统调用改变调度政策(sched_setscheduler)或表示礼让(sched_yield)时，会设置 need_resched 标志为 1。\n  如何计算优先级：godness() #  调度算法的核心是在可运行队列链表中的所有进程中确定优先级最高的进程。goodness() 就是用来计算进程优先级。它接受两个输入参数：prev(前一个运行进程)和 p(要评估的进程)，返回一个整数值 c，表示进程 p 的“值得运行的程度(goodness)”。\ngoodness()函数将实时进程和普通进程区分计算。流程如下：\n 如果该进程的 policy 被置 SCHED_YIELD 标志为，直接返回 -1。表示进程愿意“礼让”。 如果该进程是 SCHED_FIFO 或 SCHED_RR，直接返回：1000+ p-\u0026gt;rt_priority。可以看出，实时进程的优先级很高，且与 counter 和 nice 无关，至少为 1000，保证了实时进程会完全优先于普通进程的调度。 如果该进程是 SCHED_OTHER： 如果 p-\u0026gt;counter 为 0，直接返回 0。即该进程已用完时间片。 否则，返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice。 此外，在 2 的情况下，如果候选进程 p 是内核进程（无用户空间），或者 p 的用户空间与当前进程 prev 的用户空间相同，则返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice + 1。因为如果 p 正好在 prev 之后运行，它们将使用同一页表。  调度流程：schedule() #  可以将 schedule()函数大致分为以下三个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作  具体过程如下：\n初始化部分 #   current 的值保存在 prev 局部变量中, 将 prev-\u0026gt;need_resched 字段设为 0 判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。 prev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));  检查 prev 的状态，  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒:  prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。    确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。 检查候选进程 next：  如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。   检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。  进程切换之后的操作 #  执行__schedule_tail()，置 prev-\u0026gt;police 的 SCHED_YIELD 为 0。 函数返回。  如何重新分配时间片 #  在上一小节提到，当 c 为 0 时，说明可运行队列中没有实时进程，只有普通进程，且队列中所有普通进程的时间片都已用完，这时需要重新系统中所有进程的时间片（而不仅仅是可运行队列中的进程），计算方法为：\nfor_each_task(p)  p-\u0026gt;counter = (p-\u0026gt;counter \u0026gt;\u0026gt; 1) + NICE_TO_TICKS(p-\u0026gt;nice); 宏 NICE_TO_TICKS 的定义如下。以 HZ 为 200 为例，每秒中断 200 次，那么一个时钟滴答 tick 为 5ms，20 - nice 的取值为[1 ,40]，缺省为 20，将 20 右移 1 位即除以 2 为 10，10 个滴答即 50ms。当时钟频率 HZ 越高，每个滴答所代表的时间越短，NICE_TO_TICKS 分配的滴答数越多，但最大只是 20 – nice 的值左移 2 位即乘以 4，最大值为 160，仍小于实时进程的 1000。\n#if HZ \u0026lt; 200 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 2) #elif HZ \u0026lt; 400 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 1) #elif HZ \u0026lt; 800 #define TICK_SCALE(x) (x) #elif HZ \u0026lt; 1600 #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 1) #else #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 2) #endif #define NICE_TO_TICKS(nice) (TICK_SCALE(20-(nice))+1) 可以发现，经过重新计算后，那些不在可运行队列中的普通进程，会获得较高的时间配额，在将来的调度中会占一定的优势。但即使无数次更新方之后，counter 的值也不会超过两倍的 NICE_TO_TICKS，也不会超过实时进程的优先级。\nSMP 系统下的调度程序 #  Linux 为了支持对称多处理器(SMP)体系结构，必须对 Linux 的调度程序稍作修改。实际上，每个处理器运行它自己的 schedule()函数，但是，处理器间必须交换信息以提高系统性能。\n数据结构 #  schedule_data 结构体 #  如下所示，schedule_data 结构体用来很快的获得当前进程的描述符，每个 CPU 上都有一个该结构体。该结构体包含：\n 该 CPU 上现运行进程的描述符 task_struct。 现运行进程上台的时刻，即 schedule()是什么时候选 curr 作为运行进程。  struct schedule_data{  struct task_struct *curr;  unsigned long last_schedule; } struct schedule_data aligned_data[NR_CPUS]; task_struct 进程描述符 #  除了在上文提到的一些与进程调度相关的字段外，task_struct 还包含了几个与 SMP 相关的字段，包括：\n processor：表示该进程上一次运行在哪个 CPU 上。 avg_slice：表示该进程的平均时间片，即每次运行时间的期望值。  cacheflush_time 变量 #  cacheflush_time 变量表示对硬件高速缓存内容全部重写所需要花费的时间。这个值只是一个估值，大约不到 100 微秒。计算公式为：以 kHZ 为单位的 CPU 频率*以 KB 大小为单位的缓存容量/5000 在后面将看到，当现运行进程的 avg_slice – (time – last_schedule) \u0026lt; cacheflush_time，就不会执行进行的抢占。\nSMP 系统下调度流程：schedule() #  具体过程如下：\n  current 的值保存在 prev 局部变量中。prev-\u0026gt;processor 的值存放在 this_cpu 局部变量中。aligned_data[this_cpu]的值存放在 sched_data 局部变量中。将 prev-\u0026gt;need_resched 字段设为 0。\nprev = current; this_cpu = prev-\u0026gt;processor; sched_data = aligned_data[this_cpu];   判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。\nprev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));   检查 prev 的状态:\n   如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒: prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。  确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。在 goodness 函数中，检查进程的 processor 字段，并对最后在 this_cpu CPU 上执行的进程给与一定奖赏(PROC_CHANGE_PENALTY，通常为 15). 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。除此之外，做一些跟 CPU 相关的操作：   把 sched_data-\u0026gt;curr 置为 next。 next-\u0026gt;has_cpu 置为 1，next-\u0026gt;processor 置为 this_cpu。 在 t 局部变量中存放 current 时间标记寄存器的值，并执行： this_slice = t – sched_data-\u0026gt;last_schedule; sched_data-\u0026gt;last_schedule = t; prev-\u0026gt;avg_slice = (prev-\u0026gt;avg_slice + this_slice) / 2   检查候选进程 next：   如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。  检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。 进程切换之后的操作 当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 schedule()时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。如果 prev(即为 prev_new)还依然是可运行的，并且不是这个 CPU 的空任务，那么，对 prev 调用 reschedule_idle()函数。 把 prev 的 has_cpu 字段清 0。 函数返回。  SMP 系统下的 reschedule_idle() #  当进程 p 变为可运行时，执行 reschedule_idle()函数决定进程是否应该抢占某一 CPU 上的当前进程。具体过程如下：\n 如果 p 是实时进程，总会试图抢占，转到 3。 如果有一个 CPU 上的当前进程满足下列两个条件，则立即返回(不试图抢占)：  cacheflush_time 大于当前进程的平均时间片。防止高速缓存变得太“脏”。 为了存取某一临界内核数据结构，p 和当前进程都需要全局内核锁。   接下来执行 CPU 选择算法：  如果 p-\u0026gt;processor (即 p 最后运行的 CPU)是空闲的，选它。 遍历所有 CPU，对其上正在运行的任务 tsk，计算以下差值：goodness(tsk, p) - goodness(tsk, tsk), 如果这个差值为正，就选择差值最大的 CPU。   如果选择了某个 CPU，给选中的 CPU 的正在运行进程的 need_resched 字段置 1，并向这个 CPU 发处理器间中断：RESCHEDULE_VECTOR interprocessor interrupt。  O(1) 调度算法 #  O(n) 调度算法缺陷 #  Linux2.4 之前的版本，用较为简单的调度算法实现了进程调度。但是该算法存在以下问题：\n  算法复杂度问题。遍历运行队列的算法复杂度为 O(n)，意味着队列越长，选中一个进程所需要的时间就越长。此外，每次调度周期结束后，为每一个进程计算其时间片的过程太耗费时间。\n  多处理器问题。多个处理器上的进程放在一个就绪队列中，使得这个就绪队列成为临界资源，为了实现内核同步机制，需要对其上自旋锁，降低了系统效率。\n  CPU 空转问题。在 runqueue 队列中的全部进程时间片被耗尽之前，系统总会处于这样一个状态：最后的一组尚存时间片的进程分分别调度到各个 CPU 上去。我们以 4 个 CPU 为例，T0 ～ T3 分别运行在 CPU0~CPU3 上。随着系统的运行，CPU2 上的 T2 首先耗尽了其时间片，但是这时候，其实 CPU2 上也是无法进行调度的，因为遍历 runqueue 链表，找不到适合的进程调度运行，因此它只能是处于 idle 状态。也许随后 T0 和 T3 也耗尽其时间片，从而导致 CPU0 和 CPU3 也进入了 idle 状态。现在只剩下最后一个进程 T1 仍然在 CPU1 上运行，而其他系统中的处理器处于 idle 状态，白白的浪费资源。唯一能改变这个状态的是 T1 耗尽其时间片，从而启动一个重新计算时间片的过程，这时候，正常的调度就可以恢复了。随着系统中 CPU 数目的加大，资源浪费会越来越严重。\n  SMP 亲和力问题。在一个新的周期开后，runqueue 中的进程时间片都是满满的，在各个 CPU 上调度进程的时候，它可选择的比较多，再加上调度器倾向于调度上次运行在本 CPU 的进程，因此调度器有很大的机会把上次运行的进程调度到同一个处理器上。但是随着 runqueue 中的进程一个个的耗尽其时间片，cpu 可选择的余地在不断的压缩，从而导致进程执行在一个和它亲和性不大的处理器（例如上次该进程运行在 CPU0，但是这个将其调度到 CPU1 执行，但是实际上该进程和 CPU0 的亲和性更大些）。\n  实时进程调度性能问题。实时进程和普通进程挂在一个链表中，当调度实时进程的时候，我们需要遍历整个 runqueue 列表，扫描并计算所有进程的优先级，再从中选择出最终要调度的实时进程，在这过程中，一些时间片已经耗完的进程在不可能参与调度的情况下，依然会参与调度选择的过程。此外，整个 linux 内核不是抢占式内核，对于一些比较耗时的系统调用或者中断处理，必须返回用户空间才启动调度，大大降低了实时进程的调度性能。\n  交互式普通进程的调度延迟问题。O（n）并不区分交互式进程和批处理进程，它只是奖励经常睡眠的那些进程。但是有些批处理进程也属于 IO-bound 进程，例如数据库服务进程，它本身是一个后台进程，对调度延迟不敏感，但是由于它需要和磁盘打交道，因此也会经常阻塞在 disk IO 上。对这样的后台进程进行动态优先级的升高其实是没有意义的，会增大其他交互式进程的调度延迟。\n  虽然 O（n）调度器存在不少的问题，但是社区的人还是基本认可这套算法的，因 此在设计新的调度器的时候并不是完全推翻 O（n）调度器的设计，而是针对 O（n）调度器的问题进行改进。\n从以上分析中可以看出，单运行队列是影响调度性能的主要问题之一，因此改进运行队列就成为改进调度算法的入口点。\n基于此，O(1)调度器为每个 CPU 设置一个运行队列，并且为每个运行队列再设置两个队列：活动队列和时间片过期队列。每个队列中的元素以优先级再进行分类，相同优先级的进程为一个队列，最多可以有 140 个优先级。为了快速选中要运行的进程，设置以优先级为序的队列位图，位图的每一位对应一个队列，只要队列中有一个可运行进程，该位置 1，否则置 0。这样，无需遍历所有队列，而只要遍历位图，找到有可运行进程的队列，该队列的第一个进程就是被选中的进程。该算法的复杂度为 O(1). 如图所示：\n通过将单链表变成多个链表，可以解决上述大部分问题：\n 算法复杂度问题：O(1)调度器算法通过优先级位图，以及活动队列与过期队列指针交换，实现了 O(1)的复杂度，而不是遍历运行队列，并重新计算所有进程的时间片。 多处理器问题：由于每个 CPU 都有一个运行队列，因此 O(1)调度器就不需要全局运行队列的自旋锁，而只需要把这个自旋锁放入到每个 CPU 的运行队列数据结构中，通过把一个大锁细分成小锁，可以大大降低调度延迟，提升系统响应时间。。 CPU 空转问题：O(1)调度器每个 CPU 都有一个运行队列，当一个进程的时间片耗尽，在被移动到过期数组之前，会重新计算其时间片，而不是等到一个调度周期结束再重新计算进程时间片，因此解决了 CPU 空转问题。 SMP 亲和力问题：O(1)调度器设置了较为合理的负载均衡算法，只有在需要平衡任务队列大小时才在 CPU 之间移动进程。 实时进程与交互式调度性能问题：为了提高交互时进程和实时进程的响应时间，当前进程的时间片为 0 时，判断当前进程的类型，如果时交互式进程或实时进程，则重置其时间片并重新插入活动队列，否则插入过期队列，这样交互式进程和实时进程总能优先获得 CPU。然而当这些进程已经占用 CPU 时间超过一个固定值后，也会被移到过期队列中，避免其他进程产生饥饿现象。  数据结构 #  runqueue 数据结构 #  runqueue 可执行队列是调度程序中最基本的数据结构。定义于 kernel/sched.c 中。如上所述，每个 CPU 包含一个可执行队列；每个就绪进程都唯一地归属于某一个可执行队列。此外，可执行队列中还包含着每个 CPU 的调度信息。其包含的字段如下图所示：\n优先级数组 #  如上所述，每个运行队列有活动队列和过期队列两个优先级数组，每个数组是一个 prio_array 类型的结构体。优先级数组使得该调度算法复杂度为 O(1)。\n 计数器 nr_active 是一个计数器，保存可运行进程数目。 bitmap 是优先级位图数组。其中 BITMAP_SIZE 是位图数组的大小，类型为 unsigned long 长整型，长 32 位，每一位包含一个优先级，140 个优先级需要 5 个长整型数表示。bitmap 一开始所有的位都被置 0。当某个进程状态变为 TASK_RUNNING 时，对应的位被置 1。这样，查找系统中最高的优先级就变成了查找位图中被设置的第一个位。 queue 是优先级链表数组，一个链表对应一种优先级。每个链表包含了该 CPU 上相应优先级的全部可运行进程。其中 MAX_PRIO 定义了系统拥有的优先级个数，默认为 140。  进程描述符 #  与 linux 2.4 的进程描述符有些差异，其与调度相关的字段如下：\n进程的优先级 #  普通进程 #  静态优先级 #  普通进程的静态优先级保存在 static_prio 成员中，取值范围是 100（优先级最高）～ 139（优先级最低），分别对应 nice 值的-20 ～ 19。静态优先级本质上决定了进程的基本时间片，对应公式如下：\n由该公式得到一些普通进程优先级的典型值如下：\n动态优先级 #  在实际调度的时候使用的是动态优先级。普通进程的动态优先级保存在进程描述符的 prio 成员中。取值范围是 100（优先级最高）～ 139（优先级最低），和静态优先级一致。动态优先级根据以下公式得出：\n其中，bonus 取值范围 0~10，值小于 5 表示惩罚，大于 5 表示奖赏。bonus 的取值与进程的平均睡眠时间相关，如下表。需要说明的是，平均睡眠时间是进程在睡眠状态所消耗的平均纳秒数，但不是对过去时间的求平均值操作。例如，在 TASK_INTERRUPTIBLE 状态与在 TASK_UNINTERRUPTIBLE 状态所计算出的平均睡眠时间是不同的。而且，平均睡眠时间永远不会大于 1s.\n平均睡眠时间也被调度程序用来确定一个给定进程是交互式进程还是批处理进程。如果满足下列公式，则被看作是交互式进程：\n其中，静态优先级/4-28 被称为交互时的 δ。可以推出，高优先级的进程比低优先级的进程更容易成为交互式进程。例如，最高静态优先级(100)的进程，当他的 bonus 值超过 2，即睡眠时间超过 200ms 时，就被看作是交互式进程。\n实时进程 #  实时进程的实时优先级，存在进程描述符的 rt_priority 成员中，取值范围是 1（优先级最低）～ 99（优先级最高）。需要注意的是，当系统调用 nice()和 setpriority()用于基于时间片轮转的实时进程时，不改变实时进程的优先级，而会改变其基本时间片的长度。也就是说，基于时间片轮转的实时进程的基本时间片的长度与实时进程的优先级无关，而依赖于进程的静态优先级，它们的关系同普通进程下的公式一样。\n普通进程采用复杂的公式计算动态优先级，而实时进程不计算动态优先级，保证了给定优先级别的实时进程总能抢占优先级比它低的进程。\n调度程序所使用的函数 #  调度程序使用几个函数来完成调度工作，其中最重要的函数说明如下：\nscheduler_tick() #  每次时钟节拍到来时，scheduler_tick()被调用，执行以下步骤：\n 把转换为纳秒的 TSC 的当前值存到本地运行队列的 timestamp_last_tick 字段。这个时间戳是从 sched_clock()函数得到。 检查当前进程是不是本地 CPU 的 swapper 进程，如果是，则检查本地运行队列除了 swagger 进程外，是不是还有另外的可运行进程，如果是，就设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。之所以会出现这种情况，是因为如果内核支持超线程技术，那么只要一个逻辑 CPU 运行队列中的所有进程都比另一个逻辑 CPU 上已经在执行的进程优先级低得多，而两个逻辑 CPU 是对应同一个物理 CPU 的，因此，前一个逻辑 CPU 就可能空闲，即使它的运行队列中也有可运行的进程。执行完上述检查后，直接跳到第 7 步，因为不需要更新 swagger 进程的时间片。 检查 current-\u0026gt;array 是否指向本地运行队列的活动链表，如果不是，说明进程已经过期但还没有被替换，则设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。然后直接跳到第 7 步。 获得 this_rq()-\u0026gt;lock 自旋锁 根据进程不同类型执行不同操作：    如果当前进程是 FIFO 的实时进程，则什么也不做，跳到 6。\n  当前进程是基于时间片轮转的实时进程：递减当前进程时间片，如果时间片已经用完，则：\n 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice= 0。该字段是在 fork()系统调用服务例程中的 copy_process()中设置，并在进程的第一个时间片用完时清 0。 调用 set_tsk_need_resched()设置进程的 TIF_NEED_RESCHED 字段。 iv. 把当前进程移到当前的运行队列尾部。    当前进程是普通进程：递减当前进程时间片，如果时间片已经用完：\n 将当前进程从活动队列(this_rq()-\u0026gt;active)中移除。 调用 set_tsk_need_resched() 设置进程的 TIF_NEED_RESCHED 字段。 更新当前进程的动态优先级。current-\u0026gt;prio = effective_prio(current). 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice 清 0。 如果 this_rq()-\u0026gt;expired_timestamp 字段为 0（表示过期队列为空），把当前进程的时钟节拍 jiffies 赋值给 this_rq()-\u0026gt;expired_timestamp。 把当前进程插入活动队列或过期队列：  if (!TASK_INTERACTIVE(current) || EXPIRED_STARVING(this_rq()))  enqueue_task(current, this_rq()-\u0026gt;expired); else  enqueue_task(current, this_rq()-\u0026gt;active); 其中, TASK_INTERACTIVE 宏用于识别一个进程是不是交互式进程。EXPIRED_STARVING 宏负责检查过期队列中的进程是否处于饥饿状态：如果已经有相对较长时间没有发生数组切换了，那么再把当前的进程放置到活动数组，则会加重过期队列中进程的饥饿状态。\n否则，如果时间片没有用完，检查当前进程的剩余时间片是否太长：\nif (TASK_INTERACTIVE(p) \u0026amp;\u0026amp; !((task_timeslice(p) – p-\u0026gt;time_slice) %TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;time_slice \u0026gt;= TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;array == rq-\u0026gt;active)) {  list_del(\u0026amp;current-\u0026gt;run_list);  list_add_tail(\u0026amp;current -\u0026gt; run_list, this_rq()-\u0026gt;active-\u0026gt;queue+current-\u0026gt;prio);  set_tsk_need_resched(p); } 其中，宏 TIMESLICE_GRANULARITY 产生两个数的乘积给当前进程的 bonus，其中一个数为系统中 CPU 的数量，另一个为成比例的常量。基本上，具有高静态优先级的交互式进程，其时间片被分成大小为 TIMESLICE_GRANULARITY 的几个片段，以使这些进程不会独占 CPU。\n  释放 this_rq()-\u0026gt;lock 自旋锁。 调用 rebalance_tick()函数，保证不同 CPU 的运行队列包含数量基本相同的可运行进程。  从第 5 步中可以看出，对于 O(1)调度器，时间片的重新赋值是分散处理的，在各个进程耗尽其时间片之后立刻进行的。修正了 O(n)调度器一次性的遍历系统所有进程，重新为时间片赋值的过程。\n唤醒：try_to_wake_up() #  该函数通过把进程状态设置为 TASK_RUNNING，并调用 activate_task()函数将此进程放入对应的可运行队列中来唤醒睡眠或停止的进程。\n该函数接受的参数有：\n 被唤醒进程的描述符指针 p. 可以被唤醒的进程状态掩码(state)。 一个标志(syn)，用来禁止被唤醒的进程抢占本地 CPU 上正在运行的进程。  该函数执行以下操作：\n 禁本地中断，并获得最后执行该进程的 CPU 的运行队列的锁。 检查进程状态 p-\u0026gt;state == state。如果不是，直接跳到 9 终止函数。 如果 p-\u0026gt;arrray != NULL ,说明该进程已经属于某个运行队列，跳到 8. 确定目标 CPU：  如果有空闲的 CPU，就选空闲的 CPU。 如果先前执行进程的 CPU 的工作量远小于本地 CPU 的工作量，选前者。 如果进程最近被执行过，就选这个老的运行队列。 如果把进程迁移到本地 CPU 可以缓解 CPU 之间的不平衡，则选本地 CPU。   如果进程处于 TASK_UNINTERRUPTIBLE 状态，则递减目标运行队列的 nr_uninterruptible 字段，并把 p-\u0026gt;activated 字段置为-1。 调用 activate_task()函数，执行：  调用 sched_clock()获取以纳秒为单位的当前时间戳。如果目标 CPU 不是本地 CPU，就要补偿本地时钟中断的偏差：now=(shced_clock()–this_rq()-\u0026gt;timesamp_last_tick)+rq-\u0026gt;timestamp_last_tick 调用 recalc_task_prio()。 设置 p-\u0026gt;activated 字段的值。 使用 now 设置 p-\u0026gt;timestamp 字段。 把进程描述符插入活动队列，且 rq-\u0026gt;nr_running++。   如果目标 CPU 不是本地 CPU，或者没有设置 sync 标志，则，如果该进程优先级更高 p-\u0026gt;prio \u0026gt; rq-\u0026gt;curr-\u0026gt;prio，就调用 resched_task()抢占 rq-\u0026gt;curr。  单处理器系统，设置 rq-\u0026gt;curr 进程的 TIF_NEED_RESCHED 标志。 多处理器系统，如果 TIF_NEED_RESCHED 旧值为 0，且目标 CPU 没有轮询进程 TIF_NEED_RESCHED 标志的值，则发送处理器间中断 IPI，强制目标 CPU 重新调度。   把当前进程 p-\u0026gt;state 字段设为 TASK_RUNNING。 开 rq 运行队列的锁，打开本地中断。 如果成功唤醒返回 1，否则返回 0.  计算动态优先级：recalc_task_prio() #  recalc_task_prio() 函数更新进程的平均睡眠时间和动态优先级。\n该函数接受的参数有：\n 进程描述符指针 p。 当前时间戳 now。  该函数执行以下操作：\n 把 min(now – p-\u0026gt;timestamp, 109)的结果赋值给局部变量 sleep_time，表示进程消耗在睡眠状态的纳秒数。如果超过 1 秒，就设为 1 秒. 如果 sleep_time 不大于 0，直接跳到 8. 检查进程是不是内核线程、进程是否从 TASK_UNINTERRUPTIBLE 状态（即 p-\u0026gt;activated 为-1）被唤醒、进程连续睡眠的时间是否超过给定的睡眠时间期限。如果这三个条件都满足，把 p-\u0026gt;sleep_avg 字段设置位相当于 900 个时钟节拍的值（用最大平均睡眠时间减去一个标准进程的基本时间片长度获得的一个经验值）。然后跳到 8. 计算进程原来的平均睡眠时间的 bonus 值。如果 10-bonus\u0026gt;0,则把 sleep_time 乘以 10-bonus。所以原来的 p-\u0026gt;sleep_avg 越小，bonus 值越小，10-bonus 越大，sleep_time 越大，最终的 p-\u0026gt;sleep_avg 增加的就越快。 如果进程处于 TASK_UNINTERRUPTIBLE 状态而且不是内核线程：  检查平均睡眠时间 p-\u0026gt;sleep_avg 是否大于等于进程的睡眠时间极限。如果是，把 sleep_time 置为 0，直接跳到 6. 如果 sleep_time + p-\u0026gt;sleep_avg 大于等于睡眠时间极限，把 p-\u0026gt;sleep_avg 设为睡眠时间极限并把 sleep_time 置为 0 通过对进程平均睡眠时间的轻微限制，函数不会对睡眠时间很长的批处理进程给与过多的奖赏。   把 sleep_time 加到进程的平均睡眠时间 p-\u0026gt;sleep_avg 上。 检查 p-\u0026gt;sleep_avg 是否超过 1000 个时钟节拍，如果是，就置为 1000 个时钟节拍。 更新进程的动态优先级。p-\u0026gt;prio = effective_prio(p).  可以看到，在评估用户交互指数上，O(n)调度器仅仅考虑了睡眠进程的剩余时间片，而 O(1)调度器的“平均睡眠时间”算法考虑了更多的因素：在 cpu 上的执行时间、在 runqueue 中的等待时间、睡眠时间、睡眠时候的进程状态（是否可被信号打断），什么上下文唤醒（中断上下文唤醒还是在进程上下文中唤醒），因此 O(1)调度器更好的判断了进程是否属于交互式进程。\n调度流程： #  schedule() 与 O(n) 调度器类似，可以将 schedule() 函数大致分为以下四个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作 具体过程如下： 初始化部分 禁用内核抢占。current 的值保存在 prev 局部变量中，本地 CPU 的运行队列保存在 rq 局部变量中。 preempt_disable(); prev = current; rq = this_rq();  保证 prev 不占用大内核锁。通过进程切换会自动释放和重新获取大内核锁。 if (prev-\u0026gt;lock_dept \u0026gt;= 0)  up(\u0026amp;kernel_sem);  计算 prev 所用的 CPU 时间片长度： now = sched_clock(); run_time = now – prev-\u0026gt;timesamp; if (run_time \u0026gt; 1000000000)  run_time = 1000000000 run_time /= (CURRENT_BONUS(PREV) ? : 1) run_time 用来限制进程对 CPU 的使用，最多 1 秒。不过，当进程有较长睡眠时间时，CURRENT_BONUS()返回值越大，run_time 就会被降低。这是对较长平均睡眠时间的奖赏。 关本地中断，获得运行队列的自旋锁：spin_lock_irq(\u0026amp;rq-\u0026gt;lock) 检查 prev 是不是一个正在被终止的进程： if (prev-\u0026gt;flags \u0026amp; PF_DEAD)  prev-\u0026gt;state = EXIT_DEAD;  检查 prev 的状态，如果不是 TASK_RUNNING 可运行状态，而且没有在内核态被抢占：  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就让其变为可运行状态：prev-\u0026gt;state = TASK_RUNNING 以唤醒这个进程。 否则，调用 deactivate_task()函数从运行队列中删除 prev 进程,。同时，如果该进程状态是 TASK_UNINTERUPTIBLE，则 rq-\u0026gt;nr_uniterruptible++.  rq-\u0026gt;nr_running--; dequeue_task(p, p-\u0026gt;array); p-\u0026gt;array = NULL;  检查运行队列中剩于的可运行进程数。如果有可运行进程，但是当前内核支持超线程技术，且可运行进程比在相同物理 CPU 的某个逻辑 CPU 上运行的兄弟进程优先级低，p-\u0026gt;sleep_avg直接去执行 swapper 进程。 如果没有可运行进程，函数调用 idle_balance()，从其他 CPU 迁移一些可运行进程到本地队列中。如果本地队列还是没有可运行进程，就重新调度空闲 CPU 的可运行进程。如果还是没有，则直接去执行 swapper 进程。 到这里运行队列中一定有可运行进程。检查运行队列中是否至少有一个进程是活动的(rq-\u0026gt;active-\u0026gt;nr_active\u0026gt;0)。如果没有，交换活动队列和过期队列的指针。  确定优先级最高的进程 next #   在优先级数组中查找第一个非 0 的位图对应的链表的第一个进程描述符，并赋值给 next。\n  检查 next-\u0026gt;activate 字段，该字段编码值表示进程在被唤醒时的状态，如下表：\n如果 next 是一个普通进程，并且 activate 为 1 或 2，就把自从进程插入运行队列开始所经过的纳秒数加到进程的平均睡眠时间。但是 1 和 2 的情况还是有区别，在 2 的情况下，增加全部运行队列等待时间，在 1 的情况下，只增加等待时间的部分。这是因为交互式进程更可能被异步事件(如键盘)而不是同步事件唤醒。\nif (next-\u0026gt;prio \u0026gt;= 100 \u0026amp;\u0026amp; next-\u0026gt; activate \u0026gt; 0){  unsigned long long delta = now – next-\u0026gt;timestamp;  if ( next-\u0026gt; activate == 1)  delta = (delta * 38) / 128;  array = next-\u0026gt;array;  dequeue_task(next, array);  recalc_task_prio(next, next-\u0026gt;timestamp + delt- ;  enqueue_task(next, array); } next-\u0026gt; activate = 0;   完成进程切换 #  如果最终的候选进程就是当前进程，释放自旋锁，不做进程切换，直接结束。 否则执行进程切换： next-\u0026gt;timestamp = now; rq-\u0026gt;nr_switches ++; rq-\u0026gt;current = next; prev = context_switch(rq, prev, next) 其中 context_switch()函数建立 next 的地址空间。  如果 next 是内核进程，则借用 prev 的 active_mm。 if ( ! next_mm ){ next-\u0026gt;active_mm = prev-\u0026gt;active_mm; atomic_inc(\u0026amp;prev-\u0026gt;active_mm-\u0026gt;mm_count); enter_lazy_tlb( prev-\u0026gt;active_mm, next) }  如果 next 是普通进程，则执行 switch_mm 切换用户空间，把虚拟内存从上一个进程映射切换到新进程中。 if ( next_mm ){ switch_mm( prev-\u0026gt;active_mm, next-\u0026gt;mm, next); }    如果 prev 是内核进程或正在退出的进程： if ( ! prev_mm ){  rq-\u0026gt;prev_mm = prev-\u0026gt;active_mm;  prev-\u0026gt;active_mm = NULL; }  调用 switch_to()进行真正的进程切换，从上一个进程的处理器状态切换到新进程的处理器状态，包括保存、恢复栈信息和寄存器信息。 switch_to( prev, next, prev);   进程切换之后的操作 #   当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 p-\u0026gt;sleep_avg时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。进程切换后的第一部分指令是：\nbarrier(); finish_task_switch( prev); 其中 finish_task_switch(prev) 函数如下：\nmm = this_rq()-\u0026gt;prev_mm; this_rq()-\u0026gt;prev_mm = NULL; prev_task_flags = prev-\u0026gt;flags; spin_unlock_irq(\u0026amp; this_rq()-\u0026gt;lock); if (mm)  mmdrop(mm) if (prev_task_flags \u0026amp; PF_DEAD)  put_task_struct( prev); 其中 mmdrop()减少内存描述符的使用计数器。如果减到了 0，释放与页表相关的所有描述符和虚拟存储区。put_task_struct()释放进程描述符使用计数器，并撤销所有其余对该进程的引用。\n  p-\u0026gt;sleep_avg函数最后一部分代码如下。包括在需要的时候重新获得大内核锁，重新启用内核抢占，并检查是否一些其他的进程已经设置了当前进程的 TIF_NEED_RESCHED。如果是，则整个 p-\u0026gt;sleep_avg函数重新执行，否则函数结束。\nprev = current; if (prev-\u0026gt;lock_depth \u0026gt;= 0)  __reacquire_kernel_lock(); preempt_enable_no_resched(); if (test_bit(TIF_NEED_RESCHED, \u0026amp;current_thread_info() -\u0026gt; flags))  goto need_resched; return;   多处理器系统中运行队列的平衡 #  从 Linux2.6.7 版本开始，Linux 提出一种基于“调度域”概念的复杂的运行队列平衡算法，从而能够容易适应各种已有的多处理器体系结构。并提供了以下函数：\n  rebalance_tick()函数会在每一次时钟节拍到来时由 scheduler_tick()调用，负责周期性、在需要的时候调用 load_balance()函数。\n  load_balance()函数检查调度域是否处于严重的不平衡状态，如果是，将会尝试调用 move_task()函数把一些进程从一个运行队列迁移到另一个运行队列。\n  move_task()函数负责把进程从源运行队列迁移到本地运行队列。\n  其中比较重要的 load_balance()函数可简单描述为如下操作：\n1、 调用 find_busiest_queue()，找到最繁忙的可运行队列，即该队列中的进程数目最多。如果没有哪个可运行队列中进程的数目比当前队列中的数目多 25%或更多，就返回 NULL，并且 load_balance()函数也返回。否则返回最繁忙的可运行队列。\n2、 从最繁忙的运行队列中选择一个优先级数组以便抽取进程，最好是过期数组，因为那里面的进程已经相当较长一段时间没有运行了，很可能不在 CPU 的高速缓存中。如果过期数组为空，那就只能选活动数组。\n3、 找到含有进程并且优先级最高的链表。\n4、 分析找到的所有这些优先级相同的进程，选择一个不是正在执行，也不会因为 CPU 相关性而不可移动，并且不在高速缓存中的进程。如果有进程满足以上条件，调用 move_task()将其从最繁忙的队列迁移到当前队列。\n5、 只要可运行队列之间仍然不平衡，就重复上面两个步骤，最终达到平衡。此时，解除对当前运行队列的锁定，从 load_balance()返回。\n抢占 #  用户抢占 #  用户抢占是指在内核即将返回用户空间的时候，如果 need_resched 标志被设置，会导致 p-\u0026gt;sleep_avg被调用，此时就发生了用户抢占。与延迟调用小节描述的一样，用户抢占在从系统调用或中断处理程序返回用户空间时发生。\n内核抢占 #  在不支持内核抢占的内核中，内核代码可以一直执行，直到完成返回用户空间或者明显的阻塞为止。也就是说，调度程序没办法在一个内核任务正在执行的时候发起调度。在 2.6 版本的内核中，引入了内核抢占能力，只要重新调度是安全的，即，只要没有持有锁，那么正在执行的代码就是可重新导入的，内核就可以在任何时间抢占正在执行的任务。\n为了支持内核抢占，为每个进程的 thread_info 引入了 preempt_count 计数器。该计数器初始值为 0，每当使用锁的时候加 1，释放锁的时候减 1.当该值为 0 时，表示内核可以抢占。\n因此，从中断返回内核空间的时候，内核会检查 need_resched 和 preempt_count 的值。如果 need_resched 被设置，且 preempt_count 为 0，说明有一个更为重要的任务需要执行并且可以安全的抢占，此时，调度程序就会被调用。此外，如果当前进程持有的所有锁都被释放了，此时会去检查 need_resched 是否被设置，如果是就调用调度程序。\n如果内核中的进程被阻塞了，或它显示地调用 p-\u0026gt;sleep_avg，内核抢占就显式地发生，这种形式的内核抢占一直都是支持的，因为无需额外的逻辑来保证内核可以安全的被抢占。\n楼梯调度算法与 RSDL 调度算法 #  O(1)调度器区分交互式进程和批处理进程的算法与以前虽大有改进，但仍然在很多情况下会失效。有一些著名的程序(如 fiftyp.c, thud.c, chew.c, ring-test.c)总能让该调度器性能下降，导致交互式进程反应缓慢。\n为了解决这些问题，大量难以维护和阅读的复杂代码被加入 Linux2.6.0 的调度器模块，虽然很多性能问题因此得到了解决，可是另外一个严重问题始终困扰着许多内核开发者。那就是代码的复杂度问题。这些不足催生了 Con Kolivas 的楼梯调度算法 SD，为调度器设计提供了一个新的思路。之后的 RSDL 和 CFS 都基于 SD 的许多基本思想。\n楼梯调度算法 #  O(1)调度器算法的主要复杂性来自动态优先级的计算，调度器根据平均睡眠时间和一些很难理解的经验公式来修正进程的优先级以及区分交互式进程。这样的代码很难阅读和维护。\n楼梯调度算法(staircase scheduler)抛弃了动态优先级的概念，而采用了一种完全公平的思路。其思路虽然简单，但是实验证明它对应交互式进程的响应比 O(1)调度器更好，而且极大地简化了代码。\n和 O(1)调度器一样，楼梯算法也同样为每一个优先级维护一个进程队列，并将这些队列组织在 active 数组中。当选取下一个被调度进程时，SD 算法也同样从 active 数组中直接读取。 与 O(1)算法不同在于，当进程用完了自己的时间片后，并不是被移到 expire 数组中。而是被加入 active 数组的低一优先级列表中，即将其降低一个级别。不过请注意这里只是将该任务插入低一级优先级任务列表中，任务本身的优先级并没有改变。当时间片再次用完，任务被再次放入更低一级优先级任务队列中。就像一部楼梯，任务每次用完了自己的时间片之后就下一级楼梯。\n任务下到最低一级楼梯时，如果时间片再次用完，它会回到初始优先级的下一级任务队列中。比如某进程的优先级为 1，当它到达最后一级台阶 140 后，再次用完时间片时将回到优先级为 2 的任务队列中，即第二级台阶。不过此时分配给该任务的 time_slice 将变成原来的 2 倍。比如原来该任务的时间片 time_slice 为 10ms，则现在变成了 20ms。基本的原则是，当任务下到楼梯底部时，再次用完时间片就回到上次下楼梯的起点的下一级台阶。并给予该任务相同于其最初分配的时间片。总结如下：设任务本身优先级为 P，当它从第 N 级台阶开始下楼梯并到达底部后，将回到第 N+1 级台阶。并且赋予该任务 N+1 倍的时间片。\n以上描述的是普通进程的调度算法，实时进程还是采用原来的调度策略，即 FIFO 或者 Round Robin。\n楼梯算法能避免进程饥饿现象，高优先级的进程会最终和低优先级的进程竞争，使得低优先级进程最终获得执行机会。\n对于交互式应用，当进入睡眠状态时，与它同等优先级的其他进程将一步一步地走下楼梯，进入低优先级进程队列。当该交互式进程再次唤醒后，它还留在高处的楼梯台阶上，从而能更快地被调度器选中，加速了响应时间。\n从实现角度看，SD 基本上还是沿用了 O(1)的整体框架，只是删除了 O(1)调度器中动态修改优先级的复杂代码；还淘汰了 expire 数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。\nRSDL 调度算法 #  RSDL（The Rotating Staircase Deadline Schedule）也是由 Con Kolivas 开发的，它是对 SD 算法的改进。核心的思想还是“完全公平”。没有复杂的动态优先级调整策略。\nRSDL 重新引入了 expire 数组。它为每一个优先级都分配了一个 “组时间配额”， 我们将组时间配额标记为 Tg；同一优先级的每个进程都拥有同样的\u0026quot;优先级时间配额\u0026quot;，本文中用 Tp 表示，以便于后续描述。\n当进程用完了自身的 Tp 时，就下降到下一优先级进程组中。这个过程和 SD 相同，在 RSDL 中这个过程叫做 minor rotation。请注意 Tp 不等于进程的时间片，而是小于进程的时间片。下图表示了 minor rotation。进程从 priority1 的队列中一步一步下到 priority140 之后回到 priority2 的队列中，这个过程如下图左边所示，然后从 priority 2 开始再次一步一步下楼，到底后再次反弹到 priority3 队列中。\n在 SD 算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得 CPU。因此低优先级进程的等待时间无法确定。RSDL 中，当高优先级进程组用完了它们的 Tg(即组时间配额)时，无论该组中是否还有进程 Tp 尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是 RSDL 中 Deadline 代表的含义。 进程用完了自己的时间片 time_slice 时（下图中 T2），将放入 expire 数组中它初始的优先级队列中(priority 1)。\n当 active 数组为空，或者所有的进程都降低到最低优先级时就会触发 major rotation：。Major rotation 交换 active 数组和 expire 数组，所有进程都恢复到初始状态，再一次从新开始 minor rotation 的过程。\n和 SD 同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为 minor rotation 而降到了低优先级进程队列中。当它重新进入 RUNNING 状态时，就获得了相对较高的优先级，从而能被迅速响应。\nCFS 完全公平调度算法 #  CFS 是最终被内核采纳的调度器。它从 RSDL/SD 中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS 的算法和实现都相当简单，众多的测试表明其性能也非常优越。\n按照作者 Ingo Molnar 的说法：\u0026ldquo;CFS 百分之八十的工作可以用一句话概括：CFS 在真实的硬件上模拟了完全理想的多任务处理器\u0026rdquo;。在“完全理想的多任务处理器“下，每个进程都能同时获得 CPU 的执行时间。当系统中有两个进程时，CPU 的计算时间被分成两份，每个进程获得 50%。然而在实际的硬件上，当一个进程占用 CPU 时，其它进程就必须等待。这就产生了不公平。\n假设 runqueue 中有 n 个进程，当前进程运行了 10ms。在“完全理想的多任务处理器”中，10ms 应该平分给 n 个进程(不考虑各个进程的 nice 值)，因此当前进程应得的时间是(10/n)ms，但是它却运行了 10ms。所以 CFS 将惩罚当前进程，使其它进程能够在下次调度时尽可能取代当前进程。最终实现所有进程的公平调度。下面将介绍 CFS 实现的一些重要部分，以便深入地理解 CFS 的工作原理[5]。\nCFS 如何选取下一个要调度的进程 #  CFS 抛弃了 active/expire 数组，而使用红黑树选取下一个被调度进程。所有状态为 RUNABLE 的进程都被插入红黑树。在每个调度点，CFS 调度器都会选择红黑树的最左边的叶子节点作为下一个将获得 cpu 的进程。\ntick 中断 #  在 CFS 中，tick 中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记 need_resched 标志，中断返回时就会调用 scheduler()完成进程切换。否则当前进程继续占用 CPU。从这里可以看到 CFS 抛弃了传统的时间片概念。Tick 中断只需更新红黑树，以前的所有调度器都在 tick 中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。\n红黑树键值计算 #  理解 CFS 的关键就是了解红黑树键值的计算方法。该键值由三个因子计算而得：一是进程已经占用的 CPU 时间；二是当前进程的 nice 值；三是当前的 cpu 负载。\n进程已经占用的 CPU 时间对键值的影响最大，其实很大程度上我们在理解 CFS 时可以简单地认为键值就等于进程已占用的 CPU 时间。因此该值越大，键值越大，从而使得当前进程向红黑树的右侧移动。另外 CFS 规定，nice 值为 1 的进程比 nice 值为 0 的进程多获得 10%的 CPU 时间。在计算键值时也考虑到这个因素，因此 nice 值越大，键值也越大。\n在本文中，我们将为每个进程维护的变量称为进程级变量，为每个 CPU 维护的称作 CPU 级变量，为每个 runqueue 维护的称为 runqueue 级变量。\nCFS 为每个进程都维护两个重要变量：fair_clock 和 wait_runtime。进程插入红黑树的键值即为 fair_clock – wait_runtime。\n fair_clock 从其字面含义上讲就是一个进程应获得的 CPU 时间，即等于进程已占用的 CPU 时间除以当前 runqueue 中的进程总数； wait_runtime 是进程的等待时间。它们的差值代表了一个进程的公平程度。该值越大，代表当前进程相对于其它进程越不公平。  对于交互式任务，wait_runtime 长时间得不到更新，因此它能拥有更高的红黑树键值，更靠近红黑树的左边。从而得到快速响应。 红黑树是平衡树，调度器每次总最左边读出一个叶子节点，该读取操作的时间复杂度是 O(LgN)。\n调度器管理器 #  为了支持实时进程，CFS 提供了调度器模块管理器。各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块。2.6.23 中，CFS 实现了两个调度算法，CFS 算法模块和实时调度模块。对应实时进程，将使用实时调度模块。对应普通进程则使用 CFS 算法。Ingo Molnar 还邀请 Con Kolivas 可以将 RSDL/SD 写成一个调度算法模块。\nCFS 源代码分析 #  每次时钟中断会调用 scheduler_tick()函数。它首先更新 runqueue 级变量 clock；然后调用 CFS 的 tick 处理函数 task_tick_fair()。task_tick_fair 主要工作是调用 entity_tick()。函数 entiry_tick 源代码如下：\nstatic void entity_tick(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  struct sched_entity _next;  dequeue_entity(cfs_rq, curr, 0);  enqueue_entity(cfs_rq, curr, 0);  next = **pick_next_entity(cfs_rq);  if (next == curr)  return;  __check_preempt_curr_fair(cfs_rq, next, curr,  sched_granularity(cfs_rq)); } 首先调用 dequeue_entity()函数将当前进程从红黑树中删除，再调用 enqueue_entity()重新插入。这两个动作就调整了当前进程在红黑树中的位置。_pick_next_entity()返回红黑树中最左边的节点，如果不再是当前进程，就调用_check_preempt_curr_fair。该函数设置调度标志，当中断返回时就会调用 p-\u0026gt;sleep_avg进行调度。 函数 enqueue_entity()的源码如下:\nenqueue_entity(struct cfs_rq _cfs_rq, struct sched_entity _se, int wakeup) {  update_curr(cfs_rq);  if (wakeup)  enqueue_sleeper(cfs_rq, se);  update_stats_enqueue(cfs_rq, se);  __enqueue_entity(cfs_rq, se); } 它的第一个工作是更新调度信息。然后将进程插入红黑树中。其中 update_curr()函数是核心。完成调度信息的更新:\nstatic void update_curr(struct cfs_rq _cfs_rq) { struct sched_entity _curr = cfs_rq_curr(cfs_rq); unsigned long delta_exec; if (unlikely(!curr)) return; delta_exec = (unsigned long)(rq_of(cfs_rq)-\u0026gt;clock - curr-\u0026gt;exec_start); curr-\u0026gt;delta_exec += delta_exec; if (unlikely(curr-\u0026gt;delta_exec \u0026gt; sysctl_sched_stat_granularity)) { __update_curr(cfs_rq, curr); curr-\u0026gt;delta_exec = 0; } curr-\u0026gt;exec_start = rq_of(cfs_rq)-\u0026gt;clock; } 该函数首先统计当前进程所获得的 CPU 时间，rq_of(cfs_rq)-\u0026gt;clock 值在 tick 中断中被更新，curr-\u0026gt;exec_start 就是当前进程开始获得 CPU 时的时间戳。两值相减就是当前进程所获得的 CPU 时间。将该变量存入 curr-\u0026gt;delta_exec 中。然后调用__update_curr():\n__update_curr(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  unsigned long delta, delta_exec, delta_fair, delta_mine;  struct load_weight _lw = \u0026amp;cfs_rq-load;  unsigned long load = lw-\u0026gt;weight;  delta_exec = curr-\u0026gt;delta_exec;  schedstat_set(curr-\u0026gt;exec_max, max((u64)delta_exec, curr-\u0026gt;exec_max));  curr-\u0026gt;sum_exec_runtime += delta_exec;  cfs_rq-\u0026gt;exec_clock += delta_exec;  if (unlikely(!load)) return;  delta_fair = calc_delta_fair(delta_exec, lw);  delta_mine = calc_delta_mine(delta_exec, curr-\u0026gt;load.weight, lw);  if (cfs_rq-\u0026gt;sleeper_bonus \u0026gt; sysctl_sched_min_granularity) {  delta = min((u64)delta_mine, cfs_rq-\u0026gt;sleeper_bonus);  delta = min(delta, (unsigned long)((long)sysctl_sched_runtime_limit - curr-\u0026gt;wait_runtime));  cfs_rq-\u0026gt;sleeper_bonus -= delta;  delta_mine -= delta;  }  cfs_rq-\u0026gt;fair_clock += delta_fair;  add_wait_runtime(cfs_rq, curr, delta_mine - delta_exec); } __update_curr()的主要工作就是更新前面提到的 fair_clock 和 wait_runtime。这两个值的差值就是后面进程插入红黑树的键值。变量 Delta_exec 保存了前面获得的当前进程所占用的 CPU 时间。函数 calc_delta_fair()根据 cpu 负载（保存在 lw 变量中），对 delta_exec 进行修正，然后将结果保存到 delta_fair 变量中，随后将 fair_clock 增加 delta_fair。函数 calc_delta_mine()根据 nice 值（保存在 curr-\u0026gt;load.weight 中）和 cpu 负载修正 delta_exec，将结果保存在 delta_mine 中。根据源代码中的注释，delta_mine 就表示当前进程应该获得的 CPU 时间。\n随后将 delta_fair 加给 fair_clock 而将 delta_mine-delta_exec 加给 wait_runtime。函数 add_wait_runtime 中两次将 wait_runtime 减去 delta_mine-delta_exec。由于 calc_delt_xx()函数对 delta_exec 仅做了较小的修改，为了讨论方便，我们可以忽略它们对 delta_exec 的修改。最终的结果可以近似看成 fair_clock 增加了一倍的 delta_exec，而 wait_runtime 减小了两倍的 delta_exec。因此键值 fair_clock-wait_runtime 最终增加了一倍的 delta_exec 值。键值增加，使得当前进程再次插入红黑树中就向右移动了。\nCFS 小结 #  以上的讨论看出 CFS 对以前的调度器进行了很大改动。用红黑树代替优先级数组；用完全公平的策略代替动态优先级策略；引入了模块管理器；它修改了原来 Linux2.6.0 调度器模块 70%的代码。结构更简单灵活，算法适应性更高。相比于 RSDL，虽然都基于完全公平的原理，但是它们的实现完全不同。相比之下，CFS 更加清晰简单，有更好的扩展性。\nCFS 还有一个重要特点，即调度粒度小。CFS 之前的调度器中，除了进程调用了某些阻塞函数而主动参与调度之外，每个进程都只有在用完了时间片或者属于自己的时间配额之后才被抢占。而 CFS 则在每次 tick 都进行检查，如果当前进程不再处于红黑树的左边，就被抢占。在高负载的服务器上，通过调整调度粒度能够获得更好的调度性能。\n在最新版本的 CFS 实现中，内核使用虚拟运行时间 vruntime 替代了等待时间，但是基本的调度原理和排序方式没有太多变化。\n参考资料 #  [1] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核[M]. 中国电力出版社, 2001.\n[2] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核(第三版)[M]. 中国电力出版社, 2007.\n[3] 陈莉君, 康华. Linux 操作系统原理与应用[M]. 清华大学出版社, 2006.\n[4] RobertLove, 洛夫, 陈莉君, et al. Linux 内核设计与实现[M]. 机械工业出版社, 2006.\n[5] Linux 调度器发展简述 https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/\n[6] O(n)、O(1)和 CFS 调度器 http://www.wowotech.net/process_management/scheduler-history.html\n[7] 调度系统设计精要 https://draveness.me/system-design-scheduler/\n[8] 进程调度之 6：进程的调度与切换 https://my.oschina.net/u/3857782/blog/1857556\n"},{"id":2,"href":"/docs/algorithm/tree/","title":"二叉树","section":"算法","content":"二叉树 #  1、解题思路 #    遍历：通过遍历一遍树可以完成任务，则用 traverse 函数配合外部变量实现。 =》回溯\n  递归分解：通过子问题/子树的答案得到问题的解，则用 traverse 函数递归，利用返回值。=》 动态规划 =》后序\n  2、关注点 #  单独抽出一个节点，它需要做什么？在前/中/后序什么时候做？\n3、融会贯通 #  3.1、遍历函数 traverse() 的理解 #  迭代/递归遍历数组、链表、树没什么区别！\n数组 #  /* 迭代遍历数组 */ void traverse(int[] arr) {  for (int i = 0; i \u0026lt; arr.length; i++) {   } }  /* 递归遍历数组 */ void traverse(int[] arr, int i) {  if (i == arr.length) {  return;  }  // 前序位置  traverse(arr, i + 1);  // 后序位置 }   链表 #  /* 迭代遍历单链表 */ void traverse(ListNode head) {  for (ListNode p = head; p != null; p = p.next) {   } }  /* 递归遍历单链表 */ void traverse(ListNode head) {  if (head == null) {  return;  }  // 前序位置  traverse(head.next);  // 后序位置 }    3.2、快速排序 -\u0026gt; 前序遍历 #  构造分界点 -\u0026gt; 递归左右  Expand ↕  vector\u0026lt;int\u0026gt; sortArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  quickSort(nums, 0, nums.size()-1);  return nums;  }   void quickSort (vector\u0026lt;int\u0026gt; \u0026amp;nums, int low, int high) {  if (low \u0026lt; high) {  int index = partition(nums,low,high);  quickSort(nums,low,index-1);  quickSort(nums,index+1,high);  }  }   int partition (vector\u0026lt;int\u0026gt; \u0026amp;nums, int low, int high) {  int mid = low + ((high-low) \u0026gt;\u0026gt; 1);  if (nums[low] \u0026gt; nums[high]) swap(nums,low,high);  if (nums[mid] \u0026gt; nums[high]) swap(nums,mid,high);  if (nums[mid] \u0026gt; nums[low]) swap(nums,mid,low);   int pivot = nums[low];  int start = low;   while (low \u0026lt; high) {  while (low \u0026lt; high \u0026amp;\u0026amp; nums[high] \u0026gt;= pivot) high--;  while (low \u0026lt; high \u0026amp;\u0026amp; nums[low] \u0026lt;= pivot) low++;  if (low \u0026gt;= high) break;  swap(nums, low, high);  }  //基准值归位  swap(nums,start,low);  return low;  }     3.3、归并排序 -\u0026gt; 后序遍历 #  先排左右 -\u0026gt; 合并  Expand ↕  // 定义：排序 nums[lo..hi] void sort(int[] nums, int lo, int hi) {  int mid = (lo + hi) / 2;  // 排序 nums[lo..mid]  sort(nums, lo, mid);  // 排序 nums[mid+1..hi]  sort(nums, mid + 1, hi);   /****** 后序位置 ******/  // 合并 nums[lo..mid] 和 nums[mid+1..hi]  merge(nums, lo, mid, hi);  /*********************/ }     "},{"id":3,"href":"/docs/cs/linux/1/","title":"从开机 main 函数执行","section":"Linux","content":"Linux 从开机到加电执行 main 函数之前的过程 #  1.1 启动 BIOS，准备中断向量表和中断服务程序 #   加电时，内存 RAM 是空的 BIOS 负责把操作系统内核程序加载到内存中  具体过程：\n 靠硬件完成，将 CPU 的硬件逻辑设计为加电瞬间 CS:IP 指向 0xFFFF0, 即 BIOS 程序入口地址。 BIOS 在内存中建立中断向量表和中断服务程序。利用中断，加载内核程序。 产生 int 0x19 中断，找到并加载启动扇区，从而 bootsecct 程序被拷贝到内存。 BIOS 负责找到并加载第一扇区，与具体的Linux内核无关，即两头约定 + 定位识别。    "},{"id":4,"href":"/docs/law/dept/","title":"何为债","section":"法类","content":"何为债 #  债，以及其他的法律概念，从事实到概念形成，规定明确要件和法律效果，核心是法律的构建。因而，学习制度的思考路径，至少应当事实与法律并重。\n观察债的典型事实，其并非有共同构成要件，而是有同样的法律效果，即一方得以向另一方要求给付。此为债的基础原则。\n而债，实乃最基础的公式，其具有基础的要件，但加入具体的事实因素，则构成复杂的具体法律关系。而习得公式只是第一步，不同于数学公式的引用变形，每一个法律规则的使用，都是对于具体个体事实的讨论，都有十分重要的意义。\n因而，析得债实乃第一步，还应明确为何种债，并且需要进入到实际的具体概念和规则的讨论。\n“一方得以向对另一方要求给付”性质 #  该性质为债的基本原则，强调双方。如有突破的，需要有法律的明确规定。\n相对性 #  “债权为对于特定人之权利，债权人只能向债务人请求给付，而不能向债务人以外之人请求给付”。\n非支配性，没有绝对性和排他性。数个债权不论其发生先后，均以同等地位并存。（1）平等性：甲将房屋先后出卖给乙、丙、丁时买卖契约均属有效，三人均可请求甲交付该屋。（2）相对性：设甲将屋所有权移转于丁，乙、丙的债权随发生在前，仍不能向丁主张任何权利，仅得依债务不履行规定向甲请求损害赔偿。（3）非排他：债务人破产时，债权不论其发生先后，均依比例参加分配。\n第三人侵害债权 #  该理论寓有一项法律政策上的价值判断，即适当维护第三人的活动自由。\n例如，A驾车不慎，撞伤将在B歌厅作个人秀的歌星C。（1）A侵害了C的人身权，对其负是损害赔偿责任；（2）a.A的行为导致C无法演出，构成B的损失。b.C对于B的演出义务，产生于B与C之间的合同约定，该约定不可以用来规制A，B不可主张A侵害了自己能够使C来演出的权利。c.B可以依A故意以悖于善良风俗之方法，加损害于自己，来主张损害赔偿。\n即，债权的规制范围仅限于债权双方，第三人即使造成债权实际损害的结果，由于其并不受债权的约束，因此不可以主张第三人侵害债权。\n特殊：债权物权化 #  债权的物权化，即产生对抗一般人的法律效果，来源于法律的具体规定。\n 租赁权的物权化：租赁在先，即使出租人将租赁物所有权转移给第三人，无论第三人是否知道或知道应当知道该租赁合同的存在，承租人的租赁权依旧可以对抗第三人存在（“买卖不破租赁”）。 预告登记：预告登记的内容为债权，债权成立而登记后，任何处分该标的物的行为违背该预告登记的债权的，物权的变动无效。 基于约定产生的涉他关系  债的实现 #  实现的范围（债权角度） 。 债的内容即请求为给付，其目的是得到给付，如果交货付款同时完成，那么债权的存在没有那么大的意义。问题是，随着交易生活的不断变迁，债并非能够即时充分兑现。因此，债与债的实现一分为二。债的存在是为了保障债的实现，而债能够实现是债存在的基础。\n以当事人自治为原则，法律不直接参与债与债的实现。 债的内容是课债务人以给付义务，并赋予债权人以请求给付的权利。法律并不主动参与到这个过程中去，因为债是相对人之间的事，债权人可以主动选择是否实现请求以得到给付的权利。法律对债权人决定行使债权的给予权威、力量和制度，使其利益得到实现。\n此外，必要时法律予以强制性并于特殊情形下允许债权人自力实现其债权。\n一般权能 #   请求力：债的基本要义就是债权人能够诉请债务人履行义务。 执行力：诉请债务人履行后，债务人不履行的，法院得依债务的内容对债务人强制履行。具体有金钱请求权、物之交付请求权、行为及不行为请求权、假扣押假处分执行等。 私力实现：于特殊情况下，可以正当防卫紧急避险自助行为。除此之外，由于未涉及“实力”，五海域法律秩序及社会平和，允许抵抵销。 处分：由于法律赋予债权强的可实现力，因而债权富有价值，债权人可以对其进行处分，包括转让、免除、质押。 保持力：债务人给付后，债权人得以保有该给付，不致构成不当得利。债权具有保持给付之法律上的原因，该给付包括自动与法律强制下的给付。  特殊情形 #   请求力不完全：婚约，婚姻强调意志自由，履行以后不可强制；罹于消灭时效的债权请求力减损，不可诉请执行。 强制力排除：夫妻间的同居义务；与人身相关的义务：eg绘像，可以损害赔偿但不可直接强制； 处分排除：破产人因破产之宣告，对于其财产，丧失管理及处分权；约定债权不可让与的。  自然债务 #  婚姻居间报酬：成功才具有保有力；赌债：仅具有保有力。\n债务与责任 #  负担的范围（债务的角度）\n一般负担 #  责任即强制实现此项义务的手段，亦即履行此项义务的担保。即债务人的一般负担是为给付以自己的全部（或是特定）财产担保债务的实现。\n债务与责任问题是从债务人的角度来看债的实现，即债权人有权请求债务人使债实现，债务人如何积极配合债的实现，如何进行给付，给付不成怎么办。\n从这个角度上看，债务就是为给付“原始义务”，责任就是给付不能而生的“第二性义务”。责任是辅助于债务的存在，如同债权的其他权能辅助于请求权存在。债务本身就是负担，这个负担不仅仅包括为给付，还包括责任的负担。\n 无限责任：以自己的全部财产供债权人得依法强制执行 有限责任：以特定财产为限度，对于其他财产不得再为强制执行。  债权保全与担保制度 #  此即为特殊的负担，担保的财产涉及第三人或特定物。\n= 债的保全：责任财产的减少有两种情况，一种是债务人怠于行使自己的债权，一种是债务人积极赠与等不当使自己的财产减少的行为。 - 代位权：债务人怠于行使自己的到期债务，导致债权人不能实现债权，债权人可以直接找第三人要求其履行债务。 - 撤销权：债务人为有害债权的行为，倒是债权无法实现，债权人可以诉请法院撤销其不当行为，以恢复债务人之财产。\n 保证与担保  保证：保证人得以债权人约定，于主债务人不履行债务时，得由其代负履行责任。 担保：即以特定物担保债务的履行，包括抵押权、质押、动产抵押权、保留所有权及信托占有。   顺序总结：一般债权、优先受偿的债权（法律的规定）、有担保的债权、税收债权  债权的交易 #  包括债权让与与权利质权。\n债的义务群 #  债的微观内容，实际应为。\n 现行“民法”系以主给付义务为规律对象，基于诚信原则，由近而远，见渐次发生从积分义务，以及其他附随义务，辅助实现给付利益及维护他方当事人的人身及财产上利益，因此组成的义务体系。 在处理债之问题时，必须考虑：相对人负有何种义务，得否请求履行，得否主张同时履行抗辩，违反义务时的法律效果，得否请求损害赔偿或解除契约等。 债之关系上义务群的发展，赖乎判例学说，名称犹未统一，界限亦难完全确定，尤其从给付义务与附随义务，二者的区别从与主给付义务的远近来判断，存在模糊，二者的区别在于得否主张履行抗辩与得否解除契约，存在极大分野。  给付义务 #   主给付义务  决定债的性质的基本义务，固有、必备。 就双务合同而言，主给付义务构成对待给付义务，于他方当事人未为对待给付前，得拒绝自己之给付。 因可归责于债务人之事由，致给付不能、给付迟延或不完全给付时，债权人得请求赔偿损害或解除契约。   从给付义务  基于法律明文规定；基于当事人约定；基于诚实信用原则及补充的契约解释。 从给付义务与主给付义务关系密切，是使主给付义务得以满足而生的义务，固其得以请求履行，单独提起诉讼。 是否能够发生同时抗辩，应视具体的从给付义务是否为契约目的之达成是否必要而定。 其能够请求损害赔偿，但是否能够解除契约，依具体的从给付义务与契约目的之达成是否必要而定。    原给付义务与次给付义务 #  次给付义务是在原给付义务履行过程中，因特定事由演变而生的义务。次给付义务系根基于原来债之关系，其内容虽有所改变或扩张，但同一性仍维持不变。\n 因原给付义务给付不能、给付迟延或不完全给付而生成的赔偿损害义务，该义务既有替代给付义务的，亦有与原给付义务并存的。 契约解除时所生恢复原状之义务。  附随义务 #   促进实现主给付义务，使债权人的给付利益获得最大可能的满足，eg妥善包装花瓶；维护他方当事人人身或财产上的利益（保护功能），侵权行为法的社会安全义务来源。 性质：非给付义务，不发生同时履行抗辩，不得解除契约。德国法以是否能够提起单独诉讼作为区分附随义务与从给付义务的标准。 附随义务的违反与不完全履行给付：  不完全给付的法律后果是债权人得依关于给付迟延或者给付不能之规定行使其权利，因不完全给付而生前项义务之损害者，债权人并得请求赔偿。 法律没有设定附随义务得一般规定，附随义务的违反与不完全给付介于侵权责任与契约责任之间。  依照不完全给付的规定，不完全给付如为加害给付，除发生原来债务不履行之损害歪，更发生超过履行利益之损害，出卖人交付病鸡致买受人之鸡群亦感染而死亡。固可依侵权行为之规定请求损害赔偿，但被害人应就加害人之过失行为负举证责任，保护尚嫌不周，因此明定除了依侵权外，也可依不完全给付之理论请求损害赔偿。 依侵权行为法，因故意或过失侵害不法侵害他人权利者，负损害赔偿责任，其保护客体不及于纯财产上损害。同样思路，将附随义务的违法设定为符合不完全给付的规定，补充“侵权行为法”。     先合同义务  当事人为缔结契约而接触、准备或磋商时，发生的说明、告知、保密、保护扽跟其他义务。 具体规定（待补）   后合同义务  契约关系消灭后，当事人尚负有某种作为或不作为义务，以维护给付效果，或协助相对人处理契约终了的善后义务。 债务人违反后契约义务时，于违反一般契约义务同，依债务不履行负其责任。    不真正义务 #   相对人通常不得请求履行，而其违反并不发生损害赔偿责任，仅使负担此项义务者遭受权利减损或丧失的不利益而已。 不真正义务依诚实信用原则而生，为了最大程度上防止经济上的不效益。  标的物毁损灭失或其他情形不能返还：因可归责于解除权人自己的事由，解除权消灭。 损害扩大：被害人在法律上虽未富有不损害自己权益的义务，但既因自己之疏懈造成损害之发生或扩大，与有责任，依公平原则，自应依其程度忍受减免赔偿金额的不利益。    债法的体系 #   债法的适用逻辑：于处理相关问题时，应先检查债各是否设有规定，无特别规定时才可适用债总的一般规定。eg以不能之给付为契约标的，其契约始为无效；债权或其他权利之出卖人，应担保其权利确系存在。对于债权等权利的出卖契约规定了特别规定，这是因为立法者认为权利欠缺外部可见的形体，买受人必须信赖出卖人，故应受较为周全的保护。   甲于3月3日出售房屋给乙，约定3月10日交付。 乙于3月4日出售其对甲之债权与丙。 其后发现该屋于3月1日灭失。  甲乙买卖房屋的契约：为不能给付之契约标的，契约始为无效。房屋已经灭失，故甲乙的买卖合同无效。 乙丙之间的买卖契约：权利出卖人负有担保权利存在的义务，故乙丙的买卖合同有效。     民法的适用逻辑：以请求权基础为出发点，综合整部民法相关规定而为适用。并同样是特别优于一般。 实例探究：   甲欲丢弃旧笔A，误取新笔B丢弃。 乙先占之。 甲于次日发现其事，即向乙请求返还B笔。 乙表示已将该笔与丙的C书互易，并已同时履行。  甲基于错误的认识处分其B笔，该处分行为无效，不产生物权变动效力。 不是无主物，乙无法实现先占事实取得物权。 丙为善意第三人，并且满足善意取得要件。     故：甲得以向乙为返还原物请求权，侵权的损害赔偿请求权。甲得向丙请求返还原物请求权。  "},{"id":5,"href":"/docs/other/%E4%B8%80%E7%AF%87%E8%AF%BB%E7%BD%A2%E5%A4%B4%E9%A3%9E%E9%9B%AA%E9%87%8D%E8%AF%BB%E9%A9%AC%E5%85%8B%E6%80%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"《一篇读罢头飞雪，重读马克思》读书笔记","section":"非法类","content":"《一篇读罢头飞雪，重读马克思》读书笔记 #  人间喜剧 #  “召唤亡灵的行动” #  《路易波拿巴的雾月十八日》讲述的两个问题：\n 法国政治体制的变迁：议会民主 -\u0026gt; 宪政制度（大工业资产阶级） -\u0026gt; 国家官僚制度（法国小农） -\u0026gt; 流氓无产者政治（金融资本家） 政治制度变迁背后的阶级关系和阶级斗争。   国家官僚制：小农不能为自己做主，就幻想着“青天大老爷”骑在自己头上为自己做主。小农的生活方式是自给自足，没有发展出自己的经济交换方式，因此也没有组织这种经济交换方式的政治制度形式，即“不是一个阶级”。 欧洲七次反法战争的实质：拿破仑（翻身农民军队）欲摧毁金融家集团对于欧洲的统治。 法兰西第二帝国：金融帝国、基于法国小农的小块土地抵押发行国债刺激经济。而后经济危机，发动战争。战败，内债 + 战争赔款。 巴黎公社诞生，无产阶级专政的历史条件：各阶级轮番登台，最后的阶级：劳动者阶级在连统治阶级自己也不愿统治下去时方才登上历史舞台。 市民社会里的个人为何不能联合起来？互相之间不了解，因为大家讲不同的语言。 如何联合联系起来？借来的语言：前人和死人的语言、名字、口号、服装和旗帜， 两个目的：  表达自己现实的诉求（人支配和创造自己的语言）。内容战胜辞藻、实质战胜形式、活人战胜死人 掩盖自己现实的诉求（用语言支配人）。    “流氓无产者”与国债 #   流氓无产者：金融骗子，扮演者社会信用代理人的角色。 资产阶级（金融资本家）如何利用金融手段进行统治：收债、放债，用法国的钱再来收买法国。 具体地：用钞票、彩票、股票收买社会的各个阶级，收买军队（打手），这些收买人心的钞票又全部转化为国债，使得法国所有国民成为负债者。 不断进行改革（自身每次都能在投机的改革中获利），甚至用政变稳定金融秩序。 1848年：第二次工业革命、同时金融阶级代替工业阶级成为社会的统治者。  小块农地的金融化 #   工厂原型：监狱，监狱原型：济贫所。 资本主义的刑罚：用劳动和饥饿惩罚穷人。 资本主义的劳动交换：用劳动交换货币，货币由资本家掌握，即资本统治劳动。 空想的社会主义：排斥大生产、资本和金融，交换劳动法则：劳动者直接交换他们的劳动和劳动产品，不需要雇主，需要合作社。 共产主义 = 联合起来的劳动 + 联合起来的生产：肯定大生产、协作、科技、金融把生产资料组织为资本的功能，土地和资本不应被极少数资本家垄断，而应被联合起来的劳动所用。 农民离不开货币，经济的金融化离不开小农和小块土地，如果略过大规模的产业经济和实体经济的发展，只能把小块土地变成金融产品，必然破产 \u0026ndash; 路易-拿破仑·波拿巴的教训。 路易-拿破仑·波拿巴式发展道路模型的本质：金融家的冒险精神 + 小农幻想症。  “现代社会靠无产阶级过活” #   美国的“中产阶级”：   20世纪80年代，美国经济金融化、去工业化、去产业化，大量产业劳动者阶级转化为中产阶级，靠的是房产和股票的升值。 保守，唯一担心自己的财产不要减少，反对一切社会改革与政治运动。彼此不信任，无法形成政治力量，因此需要一个金融大资产阶级来代表他们。 金融危机，重新沦为无产阶级。   资本主义社会不是从罗马社会发展出来的，是从罗马“边缘的边缘”罗得岛上“跳起来的”。\n  资本主义的形式：\n   资本主义不与小生产相联系，而与工业化的大生产和产业革命（即组织起来的劳动）相联系 ———— 这是革命之处。 劳动者、企业主互相预付的信用制度构成上层建筑， 根本弊端：少数人垄断，对劳动进行剥削。   没有无产阶级的斗争，资产阶级就一定会被流氓无产者镇压，现代产业经济就会在金融海啸中灰飞烟灭，现代社会就会走向野蛮。\n  现代产业的形成建立在无产阶级的“信用”的基础上，他们自发地把劳动转化为资本和信用，但却把它们交给资本家去发财，他们还只是“被动的联合”。\n  不能想着跨越肮脏、拥挤、充满阶级斗争和骚动的产业经济阶段，向着衣冠楚楚的服务业和金融业迈进，甚至退回到小生产的田园牧歌。\n  共产主义：消灭现存状况的现实的运动。\n  “从来就没有救世主，也不靠神仙皇帝，要创造人类的幸福，全靠我们自己”。\n  {{ hint info}} 国际悲歌歌一曲，狂飙为我从天落 {{ /hint }}\n"},{"id":6,"href":"/docs/cs/linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/","title":"Linux 进程调度","section":"计算机","content":"Linux 进程调度 #  前言 #  在计算机科学中，调度就是一种将任务（Work）分配给资源的方法。任务可能是虚拟的计算任务，例如线程、进程或者数据流，这些任务会被调度到硬件资源上执行，例如：处理器 CPU 等设备。调度器或调度算法的设计与实现最终都会归结到一个问题上，即如何对有限的资源进行分配以实现资源利用率的最大化并满足特定的需求。\n调度器是操作系统中的重要组件，操作系统中有进程调度器（Process Scheduler）、网络调度器（Network Scheduler）和 I/O 调度器（I/O Scheduler）等组件，本文介绍的是进程调度器。\n进程调度器负责给系统中的所有进程分配有限的 CPU 时间资源。只有通过合理的调度算法，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。\n进程调度算法总是追求达到以下目标：\n 公平：保证每个进程得到合理的 CPU 时间，避免进程的饥饿现象。 高效：尽量充分使用 CPU，使 CPU 保持忙碌状态。 快速的响应时间：使交互用户的响应时间应尽可能短。 周转时间：使批处理用户等待输出的时间尽可能短。 吞吐量：单位时间内处理的进程数量尽可能多。  但是很显然，这几个目标是相互冲突的，不可能同时达到。因此只能在这几个方面进行取舍，从而确定自己的调度算法。\n进程调度器将进程分为三类：\n  交互式进程(Interactive process)：这些进程经常与用户进行交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如命令行 shell、文本编辑程序。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。\n  批处理进程(Batch process)：这些进程一般在后台运行，不必与用户交互，需要占用大量的系统资源。但是能够忍受响应延迟。典型的批处理程序如编译程序、数据库搜索引擎等。\n  实时进程(Real-time process)：这些进程对调度延迟的要求最高，往往执行非常重要的操作，要求立即响应并执行。典型的实时程序比如视频播放软件、或飞机飞行控制系统，很明显这类程序不能容忍长时间的调度延迟。\n  根据进程的不同分类 Linux 采用不同的调度策略。\n对于实时进程，采用 FIFO 或者 Round Robin 的调度策略。\n对于普通进程，则需要区分交互式和批处理式的不同。传统 Linux 调度器提高交互式应用的优先级，使得它们能更快地被调度。而 CFS 和 RSDL 等新的调度器的核心思想是“完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。\n以下列出了 Linux 不同版本调度器的历史：\n 初始调度器 · v0.01 ~ v2.4  由几十行代码实现，功能非常简陋； 同时最多处理 64 个任务；   O(n) 调度器 · v2.4 ~ v2.6  调度时需要遍历全部任务； 当待执行的任务较多时，同一个任务两次执行的间隔很长，会有比较严重的饥饿问题；   O(1) 调度器 · v2.6.0 ~ v2.6.22  通过引入运行队列和优先级数组实现 O(1) 的时间复杂度; 使用本地运行队列替代全局运行队列增强在对称多处理器的扩展性； 通过负载均衡保证多个运行队列中任务的平衡；   完全公平调度器 · v2.6.23 ~ 至今  引入红黑树和运行时间保证调度的公平性； 引入调度类实现不同任务类型的不同调度策略；    本文会详细介绍从最初的调度器到今天复杂的完全公平调度器（Completely Fair Scheduler，CFS）的演变过程。\nLinux 初始的调度算法 #  Linux 最初的进程调度器仅由 sched.h 和 sched.c 两个文件构成。你可能很难想象 Linux 早期版本使用只有几十行的 schedule 函数负责了操作系统进程的调度：\nvoid schedule(void) {  int i,next,c;  struct task_struct ** p;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p) {  ...  }  while (1) {  c = -1;  next = 0;  i = NR_TASKS;  p = \u0026amp;task[NR_TASKS];  while (--i) {  if (!*--p) continue;  if ((*p)-\u0026gt;state == TASK_RUNNING \u0026amp;\u0026amp; (*p)-\u0026gt;counter \u0026gt; c)  c = (*p)-\u0026gt;counter, next = i;  }  if (c) break;  for(p = \u0026amp;LAST_TASK ; p \u0026gt; \u0026amp;FIRST_TASK ; --p)  if (*p)  (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter \u0026gt;\u0026gt; 1) + (*p)-\u0026gt;priority;  }  switch_to(next); } 无论是进程还是线程，在 Linux 中都被看做是 task_struct 结构体，所有的调度进程都存储在上限仅为 64 的数组中，调度器能够处理的进程上限也只有 64 个。\n上述函数会先唤醒获得信号的可中断进程，然后从队列倒序查找计数器 counter 最大的可执行进程，counter 是进程能够占用的时间切片数量，该函数会根据时间切片的值执行不同的逻辑：\n 如果最大的 counter 时间切片大于 0，调用汇编语言的实现的 switch_to 切换进程； 如果最大的 counter 时间切片等于 0，意味着所有进程的可执行时间都为 0，那么所有进程都会获得新的时间切片；  Linux 操作系统的计时器会每隔 10ms 触发一次 do_timer 将当前正在运行进程的 counter 减一，当前进程的计数器归零时就会重新触发调度。\nO(n) 调度算法 #  数据结构：进程描述符 #  每个进程都有一个 task_struct 结构。该结构定义在 \u0026lt;include/linux/sched.h\u0026gt; 文件中，其中部分与进程调度相关的字段说明如下：\n  need_resched：调度标志，决定是否调用 schedule() 函数。\n  counter：进程处于可运行状态时所剩于的时钟节拍数。每次时钟中断到来时，update_process_times()对该值减 1。\n 创建新进程时，do_fork()以下列方式设置 current(父)和 p(子)进程的 counter 字段：current-\u0026gt;counter \u0026gt;\u0026gt;=1; p-\u0026gt;counter = current-\u0026gt;counter. 也就是说，父进程剩余的节拍数被分为两部分，一部分给父进程，一部分给子进程。这样做时为了防止通过 fork 子进程的方法无限制地使用 CPU 的时间。    rt_priority：实时进程的实时优先级。取值范围 1-99。\n  nice: 进程的静态优先级，它的值决定了 counter 的初值。nice 的取值范围是-20(优先级高)~19(优先级低)，缺省为 0。该值可通过 nice 系统调用改变。\n  policy： 本进程的调度策：\n SCHED_RR 和 SCHED_FIFO 用于实时进程。SCHED_RR 和 SCHED_FIFO 的调度策略在 rt_priority 不同的时候，都是谁的优先级高谁先执行，唯一的不同是相同优先级的处理： SCHED_RR 是时间片轮转的实时进程。当多个进程具有同一优先级时，采用时间片轮转轮流调度运行。适用于实时性要求较高但每次运行耗时较长的进程。 SCHED_FIFO 是先入先出的实时进程，先占有 CPU 的进程会持续执行，直到退出或者阻塞的时候才会让出 CPU。也只有这时候，其他同优先级的实时进程才有机会执行。适应于实时性要求比较强、而每次运行的耗时又比较短的进程。 SCHED_OTHER 用于普通的分时进程。  除了上面描述的三种调度策略，policy 成员也可以设定 SCHED_YIELD 的标记，它和调度策略无关，主要处理 sched_yield 系统调用的。\n  state: 表示进程当前运行状态：\n  TASK_RUNNING ：该状态表示这个进程可被调度执行而成为当前进程，是进程表达了希望被调度运行的意愿，内核会将该进程的 task_struct 结构加入可运行队列。\n  TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE ：这两个状态都表示进程处于睡眠状态。前者表示浅度睡眠，可被信号唤醒；后者表示深度睡眠。sleep_on 和 wake_up 用于深度睡眠；而 interruptible_sleep_on 和 interruptible_wake_up 则用于浅度睡眠。\n  TASK_ZOMBIE 表示已退出而暂时没有被父进程收回资源的\u0026quot;僵尸\u0026quot;进程。\n  TASK_STOPPED 主要用于调试目的。进程接收到一个 SIGSTOP 信号后就将运行状态改成 TASK_STOPPED 而进入挂起状态，然后在接收到一个 SIGCONT 信号时又恢复继续运行。\n    调度的时机 #  Linux 的调度程序是一个叫 schedule()的函数，由它来执行具体的调度算法。调用 schedule()的时机主要包括：\n直接调用 #    进程入睡时主动调用 schedule()：当现运行进程请求资源被阻塞时，会调用 sleep_on()或 interruptible_sleep_on()进入睡眠状态，这时会执行以下步骤：\n  把当前进程 current 插入到合适的等待队列中。\n  把当前进程 current 的状态修改为 TASK_INTERUPTIBLE 或 TASK_UNINTERUPTIBLE。\n  调用 schedule() 函数。\n  检查那个资源是否可用。如果不，转到第 2 步。\n  一旦那个资源成为可用的，把 current 从等待队列中删除。\n    进程终止时主动调用 schedule()：当现运行进程终止时，会调用 exit() 终止运行，这时会主动调用 schedule() 函数。\n  设备驱动程序执行长而重复的任务时，主动调用 schedule()：驱动程序在每次循环中，都会去检查调度标志 need_resched 的值，如果必要，就调用 schedule()主动放弃 CPU。\n  创建新进程：在 do_fork()中也会调用 schedule() 函数。\n  延迟调用 #  延迟调用是指当系统需要调度时，通过置现运行进程 need_resched 标志为 1。然后在从中断、异常、系统调用等从内核返回用户态时，对该标志进行检测，如果该标志为 1，则调用 schedule()。主要包括以下情况：\n  在中断处理过程中，发现 current 用完了时间片，置 need_resched 标志为 1。\n  一个进程被唤醒，且它的优先级比现运行进程更高，置 need_resched 标志为 1。\n  当父进程 fork 子进程时，其时间片会均分到父子进程。\n 如果只剩下一个 tick，这个 tick 会分配给子进程，而父进程的时间片则被清零，这时候等同于情况 1。 否则，父子进程的时间片都不为 0，这时等同于情况 2。    一个进程通过系统调用改变调度政策(sched_setscheduler)或表示礼让(sched_yield)时，会设置 need_resched 标志为 1。\n  如何计算优先级：godness() #  调度算法的核心是在可运行队列链表中的所有进程中确定优先级最高的进程。goodness() 就是用来计算进程优先级。它接受两个输入参数：prev(前一个运行进程)和 p(要评估的进程)，返回一个整数值 c，表示进程 p 的“值得运行的程度(goodness)”。\ngoodness()函数将实时进程和普通进程区分计算。流程如下：\n 如果该进程的 policy 被置 SCHED_YIELD 标志为，直接返回 -1。表示进程愿意“礼让”。 如果该进程是 SCHED_FIFO 或 SCHED_RR，直接返回：1000+ p-\u0026gt;rt_priority。可以看出，实时进程的优先级很高，且与 counter 和 nice 无关，至少为 1000，保证了实时进程会完全优先于普通进程的调度。 如果该进程是 SCHED_OTHER： 如果 p-\u0026gt;counter 为 0，直接返回 0。即该进程已用完时间片。 否则，返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice。 此外，在 2 的情况下，如果候选进程 p 是内核进程（无用户空间），或者 p 的用户空间与当前进程 prev 的用户空间相同，则返回 p-\u0026gt;counter + 20 - p-\u0026gt;nice + 1。因为如果 p 正好在 prev 之后运行，它们将使用同一页表。  调度流程：schedule() #  可以将 schedule()函数大致分为以下三个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作  具体过程如下：\n初始化部分 #   current 的值保存在 prev 局部变量中, 将 prev-\u0026gt;need_resched 字段设为 0 判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。 prev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));  检查 prev 的状态，  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒:  prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。    确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。 检查候选进程 next：  如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。   检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。  进程切换之后的操作 #  执行__schedule_tail()，置 prev-\u0026gt;police 的 SCHED_YIELD 为 0。 函数返回。  如何重新分配时间片 #  在上一小节提到，当 c 为 0 时，说明可运行队列中没有实时进程，只有普通进程，且队列中所有普通进程的时间片都已用完，这时需要重新系统中所有进程的时间片（而不仅仅是可运行队列中的进程），计算方法为：\nfor_each_task(p)  p-\u0026gt;counter = (p-\u0026gt;counter \u0026gt;\u0026gt; 1) + NICE_TO_TICKS(p-\u0026gt;nice); 宏 NICE_TO_TICKS 的定义如下。以 HZ 为 200 为例，每秒中断 200 次，那么一个时钟滴答 tick 为 5ms，20 - nice 的取值为[1 ,40]，缺省为 20，将 20 右移 1 位即除以 2 为 10，10 个滴答即 50ms。当时钟频率 HZ 越高，每个滴答所代表的时间越短，NICE_TO_TICKS 分配的滴答数越多，但最大只是 20 – nice 的值左移 2 位即乘以 4，最大值为 160，仍小于实时进程的 1000。\n#if HZ \u0026lt; 200 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 2) #elif HZ \u0026lt; 400 #define TICK_SCALE(x) ((x) \u0026gt;\u0026gt; 1) #elif HZ \u0026lt; 800 #define TICK_SCALE(x) (x) #elif HZ \u0026lt; 1600 #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 1) #else #define TICK_SCALE(x) ((x) \u0026lt;\u0026lt; 2) #endif #define NICE_TO_TICKS(nice) (TICK_SCALE(20-(nice))+1) 可以发现，经过重新计算后，那些不在可运行队列中的普通进程，会获得较高的时间配额，在将来的调度中会占一定的优势。但即使无数次更新方之后，counter 的值也不会超过两倍的 NICE_TO_TICKS，也不会超过实时进程的优先级。\nSMP 系统下的调度程序 #  Linux 为了支持对称多处理器(SMP)体系结构，必须对 Linux 的调度程序稍作修改。实际上，每个处理器运行它自己的 schedule()函数，但是，处理器间必须交换信息以提高系统性能。\n数据结构 #  schedule_data 结构体 #  如下所示，schedule_data 结构体用来很快的获得当前进程的描述符，每个 CPU 上都有一个该结构体。该结构体包含：\n 该 CPU 上现运行进程的描述符 task_struct。 现运行进程上台的时刻，即 schedule()是什么时候选 curr 作为运行进程。  struct schedule_data{  struct task_struct *curr;  unsigned long last_schedule; } struct schedule_data aligned_data[NR_CPUS]; task_struct 进程描述符 #  除了在上文提到的一些与进程调度相关的字段外，task_struct 还包含了几个与 SMP 相关的字段，包括：\n processor：表示该进程上一次运行在哪个 CPU 上。 avg_slice：表示该进程的平均时间片，即每次运行时间的期望值。  cacheflush_time 变量 #  cacheflush_time 变量表示对硬件高速缓存内容全部重写所需要花费的时间。这个值只是一个估值，大约不到 100 微秒。计算公式为：以 kHZ 为单位的 CPU 频率*以 KB 大小为单位的缓存容量/5000 在后面将看到，当现运行进程的 avg_slice – (time – last_schedule) \u0026lt; cacheflush_time，就不会执行进行的抢占。\nSMP 系统下调度流程：schedule() #  具体过程如下：\n  current 的值保存在 prev 局部变量中。prev-\u0026gt;processor 的值存放在 this_cpu 局部变量中。aligned_data[this_cpu]的值存放在 sched_data 局部变量中。将 prev-\u0026gt;need_resched 字段设为 0。\nprev = current; this_cpu = prev-\u0026gt;processor; sched_data = aligned_data[this_cpu];   判断 prev 是不是用完了时间片的 SCHED_RR 进程。如果是，给 prev 分配一个新的时间片，并把它放到运行队列链表的队尾。\nprev-\u0026gt;counter = NICE_TO_TICKS(prev-\u0026gt;nice));   检查 prev 的状态:\n   如果是 TASK_INTERUPTIBLE 且有未处理的信号，就唤醒: prev-\u0026gt;state = TASK_RUNNING; 如果是 TASK_RUNNING，则接着转到 7。 否则，将该进程从运行队列中删除。因此 prev 进程此时要么在因等待外部资源而入睡，又或者在 exit()系统调用中，已经将状态改为 TASK_ZOMBIE。  确定优先级最高的进程 next #  接下来确定优先级最高的进程。首先初始化候选进程 next 为 idle 进程，优先级 c 为-1000。 如果 prev 的状态是 TASK_RUNNING，则设置 next 设为 prev，c 设为 prev 的 goodness 值。 遍历可运行队列，搜索优先级最高的就绪进程。在搜索的时候，调用 goodness 计算进程 p 的运行资格 weight。比较大小，更新 next 和 c。在 goodness 函数中，检查进程的 processor 字段，并对最后在 this_cpu CPU 上执行的进程给与一定奖赏(PROC_CHANGE_PENALTY，通常为 15). 循环结束之后，检查 c 是否为 0。c 为 0 说明运行队列中的所有进程都用完了时间片,这时给所有进程重新分配新时间片。都赋值完之后，回到 4，重新挑选候选进程。 如果最终的候选进程就是当前进程，直接返回。  完成进程切换 #  否则执行进程切换。首先将 kstat.context_swtch++,统计上下文切换的次数。除此之外，做一些跟 CPU 相关的操作：   把 sched_data-\u0026gt;curr 置为 next。 next-\u0026gt;has_cpu 置为 1，next-\u0026gt;processor 置为 this_cpu。 在 t 局部变量中存放 current 时间标记寄存器的值，并执行： this_slice = t – sched_data-\u0026gt;last_schedule; sched_data-\u0026gt;last_schedule = t; prev-\u0026gt;avg_slice = (prev-\u0026gt;avg_slice + this_slice) / 2   检查候选进程 next：   如果候选进程 next 是内核进程，则借用 prev 的 active_mm(指针赋值，active_mm 结构共享引用计数加 1)。 如果候选进程 next 是用户空间进程，则执行 switch_mm 切换用户空间（将 mm_struct 结构中 pgd 成员所指向的页目录表的物理地址设置进 CR3）。  检查 prev 进程，如果是内核进程，归还借用的 active_mm(指针赋为 NULL，active_mm 结构共享引用计数减 1)。 执行 switch_to()进行真正的进程切换，即堆栈及寄存器状态切换。 进程切换之后的操作 当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 schedule()时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。如果 prev(即为 prev_new)还依然是可运行的，并且不是这个 CPU 的空任务，那么，对 prev 调用 reschedule_idle()函数。 把 prev 的 has_cpu 字段清 0。 函数返回。  SMP 系统下的 reschedule_idle() #  当进程 p 变为可运行时，执行 reschedule_idle()函数决定进程是否应该抢占某一 CPU 上的当前进程。具体过程如下：\n 如果 p 是实时进程，总会试图抢占，转到 3。 如果有一个 CPU 上的当前进程满足下列两个条件，则立即返回(不试图抢占)：  cacheflush_time 大于当前进程的平均时间片。防止高速缓存变得太“脏”。 为了存取某一临界内核数据结构，p 和当前进程都需要全局内核锁。   接下来执行 CPU 选择算法：  如果 p-\u0026gt;processor (即 p 最后运行的 CPU)是空闲的，选它。 遍历所有 CPU，对其上正在运行的任务 tsk，计算以下差值：goodness(tsk, p) - goodness(tsk, tsk), 如果这个差值为正，就选择差值最大的 CPU。   如果选择了某个 CPU，给选中的 CPU 的正在运行进程的 need_resched 字段置 1，并向这个 CPU 发处理器间中断：RESCHEDULE_VECTOR interprocessor interrupt。  O(1) 调度算法 #  O(n) 调度算法缺陷 #  Linux2.4 之前的版本，用较为简单的调度算法实现了进程调度。但是该算法存在以下问题：\n  算法复杂度问题。遍历运行队列的算法复杂度为 O(n)，意味着队列越长，选中一个进程所需要的时间就越长。此外，每次调度周期结束后，为每一个进程计算其时间片的过程太耗费时间。\n  多处理器问题。多个处理器上的进程放在一个就绪队列中，使得这个就绪队列成为临界资源，为了实现内核同步机制，需要对其上自旋锁，降低了系统效率。\n  CPU 空转问题。在 runqueue 队列中的全部进程时间片被耗尽之前，系统总会处于这样一个状态：最后的一组尚存时间片的进程分分别调度到各个 CPU 上去。我们以 4 个 CPU 为例，T0 ～ T3 分别运行在 CPU0~CPU3 上。随着系统的运行，CPU2 上的 T2 首先耗尽了其时间片，但是这时候，其实 CPU2 上也是无法进行调度的，因为遍历 runqueue 链表，找不到适合的进程调度运行，因此它只能是处于 idle 状态。也许随后 T0 和 T3 也耗尽其时间片，从而导致 CPU0 和 CPU3 也进入了 idle 状态。现在只剩下最后一个进程 T1 仍然在 CPU1 上运行，而其他系统中的处理器处于 idle 状态，白白的浪费资源。唯一能改变这个状态的是 T1 耗尽其时间片，从而启动一个重新计算时间片的过程，这时候，正常的调度就可以恢复了。随着系统中 CPU 数目的加大，资源浪费会越来越严重。\n  SMP 亲和力问题。在一个新的周期开后，runqueue 中的进程时间片都是满满的，在各个 CPU 上调度进程的时候，它可选择的比较多，再加上调度器倾向于调度上次运行在本 CPU 的进程，因此调度器有很大的机会把上次运行的进程调度到同一个处理器上。但是随着 runqueue 中的进程一个个的耗尽其时间片，cpu 可选择的余地在不断的压缩，从而导致进程执行在一个和它亲和性不大的处理器（例如上次该进程运行在 CPU0，但是这个将其调度到 CPU1 执行，但是实际上该进程和 CPU0 的亲和性更大些）。\n  实时进程调度性能问题。实时进程和普通进程挂在一个链表中，当调度实时进程的时候，我们需要遍历整个 runqueue 列表，扫描并计算所有进程的优先级，再从中选择出最终要调度的实时进程，在这过程中，一些时间片已经耗完的进程在不可能参与调度的情况下，依然会参与调度选择的过程。此外，整个 linux 内核不是抢占式内核，对于一些比较耗时的系统调用或者中断处理，必须返回用户空间才启动调度，大大降低了实时进程的调度性能。\n  交互式普通进程的调度延迟问题。O（n）并不区分交互式进程和批处理进程，它只是奖励经常睡眠的那些进程。但是有些批处理进程也属于 IO-bound 进程，例如数据库服务进程，它本身是一个后台进程，对调度延迟不敏感，但是由于它需要和磁盘打交道，因此也会经常阻塞在 disk IO 上。对这样的后台进程进行动态优先级的升高其实是没有意义的，会增大其他交互式进程的调度延迟。\n  虽然 O（n）调度器存在不少的问题，但是社区的人还是基本认可这套算法的，因 此在设计新的调度器的时候并不是完全推翻 O（n）调度器的设计，而是针对 O（n）调度器的问题进行改进。\n从以上分析中可以看出，单运行队列是影响调度性能的主要问题之一，因此改进运行队列就成为改进调度算法的入口点。\n基于此，O(1)调度器为每个 CPU 设置一个运行队列，并且为每个运行队列再设置两个队列：活动队列和时间片过期队列。每个队列中的元素以优先级再进行分类，相同优先级的进程为一个队列，最多可以有 140 个优先级。为了快速选中要运行的进程，设置以优先级为序的队列位图，位图的每一位对应一个队列，只要队列中有一个可运行进程，该位置 1，否则置 0。这样，无需遍历所有队列，而只要遍历位图，找到有可运行进程的队列，该队列的第一个进程就是被选中的进程。该算法的复杂度为 O(1). 如图所示：\n通过将单链表变成多个链表，可以解决上述大部分问题：\n 算法复杂度问题：O(1)调度器算法通过优先级位图，以及活动队列与过期队列指针交换，实现了 O(1)的复杂度，而不是遍历运行队列，并重新计算所有进程的时间片。 多处理器问题：由于每个 CPU 都有一个运行队列，因此 O(1)调度器就不需要全局运行队列的自旋锁，而只需要把这个自旋锁放入到每个 CPU 的运行队列数据结构中，通过把一个大锁细分成小锁，可以大大降低调度延迟，提升系统响应时间。。 CPU 空转问题：O(1)调度器每个 CPU 都有一个运行队列，当一个进程的时间片耗尽，在被移动到过期数组之前，会重新计算其时间片，而不是等到一个调度周期结束再重新计算进程时间片，因此解决了 CPU 空转问题。 SMP 亲和力问题：O(1)调度器设置了较为合理的负载均衡算法，只有在需要平衡任务队列大小时才在 CPU 之间移动进程。 实时进程与交互式调度性能问题：为了提高交互时进程和实时进程的响应时间，当前进程的时间片为 0 时，判断当前进程的类型，如果时交互式进程或实时进程，则重置其时间片并重新插入活动队列，否则插入过期队列，这样交互式进程和实时进程总能优先获得 CPU。然而当这些进程已经占用 CPU 时间超过一个固定值后，也会被移到过期队列中，避免其他进程产生饥饿现象。  数据结构 #  runqueue 数据结构 #  runqueue 可执行队列是调度程序中最基本的数据结构。定义于 kernel/sched.c 中。如上所述，每个 CPU 包含一个可执行队列；每个就绪进程都唯一地归属于某一个可执行队列。此外，可执行队列中还包含着每个 CPU 的调度信息。其包含的字段如下图所示：\n优先级数组 #  如上所述，每个运行队列有活动队列和过期队列两个优先级数组，每个数组是一个 prio_array 类型的结构体。优先级数组使得该调度算法复杂度为 O(1)。\n 计数器 nr_active 是一个计数器，保存可运行进程数目。 bitmap 是优先级位图数组。其中 BITMAP_SIZE 是位图数组的大小，类型为 unsigned long 长整型，长 32 位，每一位包含一个优先级，140 个优先级需要 5 个长整型数表示。bitmap 一开始所有的位都被置 0。当某个进程状态变为 TASK_RUNNING 时，对应的位被置 1。这样，查找系统中最高的优先级就变成了查找位图中被设置的第一个位。 queue 是优先级链表数组，一个链表对应一种优先级。每个链表包含了该 CPU 上相应优先级的全部可运行进程。其中 MAX_PRIO 定义了系统拥有的优先级个数，默认为 140。  进程描述符 #  与 linux 2.4 的进程描述符有些差异，其与调度相关的字段如下：\n进程的优先级 #  普通进程 #  静态优先级 #  普通进程的静态优先级保存在 static_prio 成员中，取值范围是 100（优先级最高）～ 139（优先级最低），分别对应 nice 值的-20 ～ 19。静态优先级本质上决定了进程的基本时间片，对应公式如下：\n由该公式得到一些普通进程优先级的典型值如下：\n动态优先级 #  在实际调度的时候使用的是动态优先级。普通进程的动态优先级保存在进程描述符的 prio 成员中。取值范围是 100（优先级最高）～ 139（优先级最低），和静态优先级一致。动态优先级根据以下公式得出：\n其中，bonus 取值范围 0~10，值小于 5 表示惩罚，大于 5 表示奖赏。bonus 的取值与进程的平均睡眠时间相关，如下表。需要说明的是，平均睡眠时间是进程在睡眠状态所消耗的平均纳秒数，但不是对过去时间的求平均值操作。例如，在 TASK_INTERRUPTIBLE 状态与在 TASK_UNINTERRUPTIBLE 状态所计算出的平均睡眠时间是不同的。而且，平均睡眠时间永远不会大于 1s.\n平均睡眠时间也被调度程序用来确定一个给定进程是交互式进程还是批处理进程。如果满足下列公式，则被看作是交互式进程：\n其中，静态优先级/4-28 被称为交互时的 δ。可以推出，高优先级的进程比低优先级的进程更容易成为交互式进程。例如，最高静态优先级(100)的进程，当他的 bonus 值超过 2，即睡眠时间超过 200ms 时，就被看作是交互式进程。\n实时进程 #  实时进程的实时优先级，存在进程描述符的 rt_priority 成员中，取值范围是 1（优先级最低）～ 99（优先级最高）。需要注意的是，当系统调用 nice()和 setpriority()用于基于时间片轮转的实时进程时，不改变实时进程的优先级，而会改变其基本时间片的长度。也就是说，基于时间片轮转的实时进程的基本时间片的长度与实时进程的优先级无关，而依赖于进程的静态优先级，它们的关系同普通进程下的公式一样。\n普通进程采用复杂的公式计算动态优先级，而实时进程不计算动态优先级，保证了给定优先级别的实时进程总能抢占优先级比它低的进程。\n调度程序所使用的函数 #  调度程序使用几个函数来完成调度工作，其中最重要的函数说明如下：\nscheduler_tick() #  每次时钟节拍到来时，scheduler_tick()被调用，执行以下步骤：\n 把转换为纳秒的 TSC 的当前值存到本地运行队列的 timestamp_last_tick 字段。这个时间戳是从 sched_clock()函数得到。 检查当前进程是不是本地 CPU 的 swapper 进程，如果是，则检查本地运行队列除了 swagger 进程外，是不是还有另外的可运行进程，如果是，就设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。之所以会出现这种情况，是因为如果内核支持超线程技术，那么只要一个逻辑 CPU 运行队列中的所有进程都比另一个逻辑 CPU 上已经在执行的进程优先级低得多，而两个逻辑 CPU 是对应同一个物理 CPU 的，因此，前一个逻辑 CPU 就可能空闲，即使它的运行队列中也有可运行的进程。执行完上述检查后，直接跳到第 7 步，因为不需要更新 swagger 进程的时间片。 检查 current-\u0026gt;array 是否指向本地运行队列的活动链表，如果不是，说明进程已经过期但还没有被替换，则设置当前进程的 TIF_NEED_RESCHED 字段，以强迫进行重新调度。然后直接跳到第 7 步。 获得 this_rq()-\u0026gt;lock 自旋锁 根据进程不同类型执行不同操作：    如果当前进程是 FIFO 的实时进程，则什么也不做，跳到 6。\n  当前进程是基于时间片轮转的实时进程：递减当前进程时间片，如果时间片已经用完，则：\n 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice= 0。该字段是在 fork()系统调用服务例程中的 copy_process()中设置，并在进程的第一个时间片用完时清 0。 调用 set_tsk_need_resched()设置进程的 TIF_NEED_RESCHED 字段。 iv. 把当前进程移到当前的运行队列尾部。    当前进程是普通进程：递减当前进程时间片，如果时间片已经用完：\n 将当前进程从活动队列(this_rq()-\u0026gt;active)中移除。 调用 set_tsk_need_resched() 设置进程的 TIF_NEED_RESCHED 字段。 更新当前进程的动态优先级。current-\u0026gt;prio = effective_prio(current). 重填进程的时间片：current-\u0026gt;time_slice = task_timeslice() current-\u0026gt;first_time_slice 清 0。 如果 this_rq()-\u0026gt;expired_timestamp 字段为 0（表示过期队列为空），把当前进程的时钟节拍 jiffies 赋值给 this_rq()-\u0026gt;expired_timestamp。 把当前进程插入活动队列或过期队列：  if (!TASK_INTERACTIVE(current) || EXPIRED_STARVING(this_rq()))  enqueue_task(current, this_rq()-\u0026gt;expired); else  enqueue_task(current, this_rq()-\u0026gt;active); 其中, TASK_INTERACTIVE 宏用于识别一个进程是不是交互式进程。EXPIRED_STARVING 宏负责检查过期队列中的进程是否处于饥饿状态：如果已经有相对较长时间没有发生数组切换了，那么再把当前的进程放置到活动数组，则会加重过期队列中进程的饥饿状态。\n否则，如果时间片没有用完，检查当前进程的剩余时间片是否太长：\nif (TASK_INTERACTIVE(p) \u0026amp;\u0026amp; !((task_timeslice(p) – p-\u0026gt;time_slice) %TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;time_slice \u0026gt;= TIMESLICE_GRANULARITY(p)) \u0026amp;\u0026amp; (p-\u0026gt;array == rq-\u0026gt;active)) {  list_del(\u0026amp;current-\u0026gt;run_list);  list_add_tail(\u0026amp;current -\u0026gt; run_list, this_rq()-\u0026gt;active-\u0026gt;queue+current-\u0026gt;prio);  set_tsk_need_resched(p); } 其中，宏 TIMESLICE_GRANULARITY 产生两个数的乘积给当前进程的 bonus，其中一个数为系统中 CPU 的数量，另一个为成比例的常量。基本上，具有高静态优先级的交互式进程，其时间片被分成大小为 TIMESLICE_GRANULARITY 的几个片段，以使这些进程不会独占 CPU。\n  释放 this_rq()-\u0026gt;lock 自旋锁。 调用 rebalance_tick()函数，保证不同 CPU 的运行队列包含数量基本相同的可运行进程。  从第 5 步中可以看出，对于 O(1)调度器，时间片的重新赋值是分散处理的，在各个进程耗尽其时间片之后立刻进行的。修正了 O(n)调度器一次性的遍历系统所有进程，重新为时间片赋值的过程。\n唤醒：try_to_wake_up() #  该函数通过把进程状态设置为 TASK_RUNNING，并调用 activate_task()函数将此进程放入对应的可运行队列中来唤醒睡眠或停止的进程。\n该函数接受的参数有：\n 被唤醒进程的描述符指针 p. 可以被唤醒的进程状态掩码(state)。 一个标志(syn)，用来禁止被唤醒的进程抢占本地 CPU 上正在运行的进程。  该函数执行以下操作：\n 禁本地中断，并获得最后执行该进程的 CPU 的运行队列的锁。 检查进程状态 p-\u0026gt;state == state。如果不是，直接跳到 9 终止函数。 如果 p-\u0026gt;arrray != NULL ,说明该进程已经属于某个运行队列，跳到 8. 确定目标 CPU：  如果有空闲的 CPU，就选空闲的 CPU。 如果先前执行进程的 CPU 的工作量远小于本地 CPU 的工作量，选前者。 如果进程最近被执行过，就选这个老的运行队列。 如果把进程迁移到本地 CPU 可以缓解 CPU 之间的不平衡，则选本地 CPU。   如果进程处于 TASK_UNINTERRUPTIBLE 状态，则递减目标运行队列的 nr_uninterruptible 字段，并把 p-\u0026gt;activated 字段置为-1。 调用 activate_task()函数，执行：  调用 sched_clock()获取以纳秒为单位的当前时间戳。如果目标 CPU 不是本地 CPU，就要补偿本地时钟中断的偏差：now=(shced_clock()–this_rq()-\u0026gt;timesamp_last_tick)+rq-\u0026gt;timestamp_last_tick 调用 recalc_task_prio()。 设置 p-\u0026gt;activated 字段的值。 使用 now 设置 p-\u0026gt;timestamp 字段。 把进程描述符插入活动队列，且 rq-\u0026gt;nr_running++。   如果目标 CPU 不是本地 CPU，或者没有设置 sync 标志，则，如果该进程优先级更高 p-\u0026gt;prio \u0026gt; rq-\u0026gt;curr-\u0026gt;prio，就调用 resched_task()抢占 rq-\u0026gt;curr。  单处理器系统，设置 rq-\u0026gt;curr 进程的 TIF_NEED_RESCHED 标志。 多处理器系统，如果 TIF_NEED_RESCHED 旧值为 0，且目标 CPU 没有轮询进程 TIF_NEED_RESCHED 标志的值，则发送处理器间中断 IPI，强制目标 CPU 重新调度。   把当前进程 p-\u0026gt;state 字段设为 TASK_RUNNING。 开 rq 运行队列的锁，打开本地中断。 如果成功唤醒返回 1，否则返回 0.  计算动态优先级：recalc_task_prio() #  recalc_task_prio() 函数更新进程的平均睡眠时间和动态优先级。\n该函数接受的参数有：\n 进程描述符指针 p。 当前时间戳 now。  该函数执行以下操作：\n 把 min(now – p-\u0026gt;timestamp, 109)的结果赋值给局部变量 sleep_time，表示进程消耗在睡眠状态的纳秒数。如果超过 1 秒，就设为 1 秒. 如果 sleep_time 不大于 0，直接跳到 8. 检查进程是不是内核线程、进程是否从 TASK_UNINTERRUPTIBLE 状态（即 p-\u0026gt;activated 为-1）被唤醒、进程连续睡眠的时间是否超过给定的睡眠时间期限。如果这三个条件都满足，把 p-\u0026gt;sleep_avg 字段设置位相当于 900 个时钟节拍的值（用最大平均睡眠时间减去一个标准进程的基本时间片长度获得的一个经验值）。然后跳到 8. 计算进程原来的平均睡眠时间的 bonus 值。如果 10-bonus\u0026gt;0,则把 sleep_time 乘以 10-bonus。所以原来的 p-\u0026gt;sleep_avg 越小，bonus 值越小，10-bonus 越大，sleep_time 越大，最终的 p-\u0026gt;sleep_avg 增加的就越快。 如果进程处于 TASK_UNINTERRUPTIBLE 状态而且不是内核线程：  检查平均睡眠时间 p-\u0026gt;sleep_avg 是否大于等于进程的睡眠时间极限。如果是，把 sleep_time 置为 0，直接跳到 6. 如果 sleep_time + p-\u0026gt;sleep_avg 大于等于睡眠时间极限，把 p-\u0026gt;sleep_avg 设为睡眠时间极限并把 sleep_time 置为 0 通过对进程平均睡眠时间的轻微限制，函数不会对睡眠时间很长的批处理进程给与过多的奖赏。   把 sleep_time 加到进程的平均睡眠时间 p-\u0026gt;sleep_avg 上。 检查 p-\u0026gt;sleep_avg 是否超过 1000 个时钟节拍，如果是，就置为 1000 个时钟节拍。 更新进程的动态优先级。p-\u0026gt;prio = effective_prio(p).  可以看到，在评估用户交互指数上，O(n)调度器仅仅考虑了睡眠进程的剩余时间片，而 O(1)调度器的“平均睡眠时间”算法考虑了更多的因素：在 cpu 上的执行时间、在 runqueue 中的等待时间、睡眠时间、睡眠时候的进程状态（是否可被信号打断），什么上下文唤醒（中断上下文唤醒还是在进程上下文中唤醒），因此 O(1)调度器更好的判断了进程是否属于交互式进程。\n调度流程： #  schedule() 与 O(n) 调度器类似，可以将 schedule() 函数大致分为以下四个部分：\n 初始化部分。 确定优先级最高的进程 next。 完成进程切换。 进程切换之后的操作 具体过程如下： 初始化部分 禁用内核抢占。current 的值保存在 prev 局部变量中，本地 CPU 的运行队列保存在 rq 局部变量中。 preempt_disable(); prev = current; rq = this_rq();  保证 prev 不占用大内核锁。通过进程切换会自动释放和重新获取大内核锁。 if (prev-\u0026gt;lock_dept \u0026gt;= 0)  up(\u0026amp;kernel_sem);  计算 prev 所用的 CPU 时间片长度： now = sched_clock(); run_time = now – prev-\u0026gt;timesamp; if (run_time \u0026gt; 1000000000)  run_time = 1000000000 run_time /= (CURRENT_BONUS(PREV) ? : 1) run_time 用来限制进程对 CPU 的使用，最多 1 秒。不过，当进程有较长睡眠时间时，CURRENT_BONUS()返回值越大，run_time 就会被降低。这是对较长平均睡眠时间的奖赏。 关本地中断，获得运行队列的自旋锁：spin_lock_irq(\u0026amp;rq-\u0026gt;lock) 检查 prev 是不是一个正在被终止的进程： if (prev-\u0026gt;flags \u0026amp; PF_DEAD)  prev-\u0026gt;state = EXIT_DEAD;  检查 prev 的状态，如果不是 TASK_RUNNING 可运行状态，而且没有在内核态被抢占：  如果是 TASK_INTERUPTIBLE 且有未处理的信号，就让其变为可运行状态：prev-\u0026gt;state = TASK_RUNNING 以唤醒这个进程。 否则，调用 deactivate_task()函数从运行队列中删除 prev 进程,。同时，如果该进程状态是 TASK_UNINTERUPTIBLE，则 rq-\u0026gt;nr_uniterruptible++.  rq-\u0026gt;nr_running--; dequeue_task(p, p-\u0026gt;array); p-\u0026gt;array = NULL;  检查运行队列中剩于的可运行进程数。如果有可运行进程，但是当前内核支持超线程技术，且可运行进程比在相同物理 CPU 的某个逻辑 CPU 上运行的兄弟进程优先级低，p-\u0026gt;sleep_avg直接去执行 swapper 进程。 如果没有可运行进程，函数调用 idle_balance()，从其他 CPU 迁移一些可运行进程到本地队列中。如果本地队列还是没有可运行进程，就重新调度空闲 CPU 的可运行进程。如果还是没有，则直接去执行 swapper 进程。 到这里运行队列中一定有可运行进程。检查运行队列中是否至少有一个进程是活动的(rq-\u0026gt;active-\u0026gt;nr_active\u0026gt;0)。如果没有，交换活动队列和过期队列的指针。  确定优先级最高的进程 next #   在优先级数组中查找第一个非 0 的位图对应的链表的第一个进程描述符，并赋值给 next。\n  检查 next-\u0026gt;activate 字段，该字段编码值表示进程在被唤醒时的状态，如下表：\n如果 next 是一个普通进程，并且 activate 为 1 或 2，就把自从进程插入运行队列开始所经过的纳秒数加到进程的平均睡眠时间。但是 1 和 2 的情况还是有区别，在 2 的情况下，增加全部运行队列等待时间，在 1 的情况下，只增加等待时间的部分。这是因为交互式进程更可能被异步事件(如键盘)而不是同步事件唤醒。\nif (next-\u0026gt;prio \u0026gt;= 100 \u0026amp;\u0026amp; next-\u0026gt; activate \u0026gt; 0){  unsigned long long delta = now – next-\u0026gt;timestamp;  if ( next-\u0026gt; activate == 1)  delta = (delta * 38) / 128;  array = next-\u0026gt;array;  dequeue_task(next, array);  recalc_task_prio(next, next-\u0026gt;timestamp + delt- ;  enqueue_task(next, array); } next-\u0026gt; activate = 0;   完成进程切换 #  如果最终的候选进程就是当前进程，释放自旋锁，不做进程切换，直接结束。 否则执行进程切换： next-\u0026gt;timestamp = now; rq-\u0026gt;nr_switches ++; rq-\u0026gt;current = next; prev = context_switch(rq, prev, next) 其中 context_switch()函数建立 next 的地址空间。  如果 next 是内核进程，则借用 prev 的 active_mm。 if ( ! next_mm ){ next-\u0026gt;active_mm = prev-\u0026gt;active_mm; atomic_inc(\u0026amp;prev-\u0026gt;active_mm-\u0026gt;mm_count); enter_lazy_tlb( prev-\u0026gt;active_mm, next) }  如果 next 是普通进程，则执行 switch_mm 切换用户空间，把虚拟内存从上一个进程映射切换到新进程中。 if ( next_mm ){ switch_mm( prev-\u0026gt;active_mm, next-\u0026gt;mm, next); }    如果 prev 是内核进程或正在退出的进程： if ( ! prev_mm ){  rq-\u0026gt;prev_mm = prev-\u0026gt;active_mm;  prev-\u0026gt;active_mm = NULL; }  调用 switch_to()进行真正的进程切换，从上一个进程的处理器状态切换到新进程的处理器状态，包括保存、恢复栈信息和寄存器信息。 switch_to( prev, next, prev);   进程切换之后的操作 #   当内核返回到这时，说明之前的进程又被调度程序选中，然而，这时的 prev 局部变量并不指向我们开始描述 p-\u0026gt;sleep_avg时所要替换出去的原来那个进程(我们假设记为 prev_old)，而是指向 prev_old 被调度时所要替换出去的那个进程(假设记为 prev_new)。进程切换后的第一部分指令是：\nbarrier(); finish_task_switch( prev); 其中 finish_task_switch(prev) 函数如下：\nmm = this_rq()-\u0026gt;prev_mm; this_rq()-\u0026gt;prev_mm = NULL; prev_task_flags = prev-\u0026gt;flags; spin_unlock_irq(\u0026amp; this_rq()-\u0026gt;lock); if (mm)  mmdrop(mm) if (prev_task_flags \u0026amp; PF_DEAD)  put_task_struct( prev); 其中 mmdrop()减少内存描述符的使用计数器。如果减到了 0，释放与页表相关的所有描述符和虚拟存储区。put_task_struct()释放进程描述符使用计数器，并撤销所有其余对该进程的引用。\n  p-\u0026gt;sleep_avg函数最后一部分代码如下。包括在需要的时候重新获得大内核锁，重新启用内核抢占，并检查是否一些其他的进程已经设置了当前进程的 TIF_NEED_RESCHED。如果是，则整个 p-\u0026gt;sleep_avg函数重新执行，否则函数结束。\nprev = current; if (prev-\u0026gt;lock_depth \u0026gt;= 0)  __reacquire_kernel_lock(); preempt_enable_no_resched(); if (test_bit(TIF_NEED_RESCHED, \u0026amp;current_thread_info() -\u0026gt; flags))  goto need_resched; return;   多处理器系统中运行队列的平衡 #  从 Linux2.6.7 版本开始，Linux 提出一种基于“调度域”概念的复杂的运行队列平衡算法，从而能够容易适应各种已有的多处理器体系结构。并提供了以下函数：\n  rebalance_tick()函数会在每一次时钟节拍到来时由 scheduler_tick()调用，负责周期性、在需要的时候调用 load_balance()函数。\n  load_balance()函数检查调度域是否处于严重的不平衡状态，如果是，将会尝试调用 move_task()函数把一些进程从一个运行队列迁移到另一个运行队列。\n  move_task()函数负责把进程从源运行队列迁移到本地运行队列。\n  其中比较重要的 load_balance()函数可简单描述为如下操作：\n1、 调用 find_busiest_queue()，找到最繁忙的可运行队列，即该队列中的进程数目最多。如果没有哪个可运行队列中进程的数目比当前队列中的数目多 25%或更多，就返回 NULL，并且 load_balance()函数也返回。否则返回最繁忙的可运行队列。\n2、 从最繁忙的运行队列中选择一个优先级数组以便抽取进程，最好是过期数组，因为那里面的进程已经相当较长一段时间没有运行了，很可能不在 CPU 的高速缓存中。如果过期数组为空，那就只能选活动数组。\n3、 找到含有进程并且优先级最高的链表。\n4、 分析找到的所有这些优先级相同的进程，选择一个不是正在执行，也不会因为 CPU 相关性而不可移动，并且不在高速缓存中的进程。如果有进程满足以上条件，调用 move_task()将其从最繁忙的队列迁移到当前队列。\n5、 只要可运行队列之间仍然不平衡，就重复上面两个步骤，最终达到平衡。此时，解除对当前运行队列的锁定，从 load_balance()返回。\n抢占 #  用户抢占 #  用户抢占是指在内核即将返回用户空间的时候，如果 need_resched 标志被设置，会导致 p-\u0026gt;sleep_avg被调用，此时就发生了用户抢占。与延迟调用小节描述的一样，用户抢占在从系统调用或中断处理程序返回用户空间时发生。\n内核抢占 #  在不支持内核抢占的内核中，内核代码可以一直执行，直到完成返回用户空间或者明显的阻塞为止。也就是说，调度程序没办法在一个内核任务正在执行的时候发起调度。在 2.6 版本的内核中，引入了内核抢占能力，只要重新调度是安全的，即，只要没有持有锁，那么正在执行的代码就是可重新导入的，内核就可以在任何时间抢占正在执行的任务。\n为了支持内核抢占，为每个进程的 thread_info 引入了 preempt_count 计数器。该计数器初始值为 0，每当使用锁的时候加 1，释放锁的时候减 1.当该值为 0 时，表示内核可以抢占。\n因此，从中断返回内核空间的时候，内核会检查 need_resched 和 preempt_count 的值。如果 need_resched 被设置，且 preempt_count 为 0，说明有一个更为重要的任务需要执行并且可以安全的抢占，此时，调度程序就会被调用。此外，如果当前进程持有的所有锁都被释放了，此时会去检查 need_resched 是否被设置，如果是就调用调度程序。\n如果内核中的进程被阻塞了，或它显示地调用 p-\u0026gt;sleep_avg，内核抢占就显式地发生，这种形式的内核抢占一直都是支持的，因为无需额外的逻辑来保证内核可以安全的被抢占。\n楼梯调度算法与 RSDL 调度算法 #  O(1)调度器区分交互式进程和批处理进程的算法与以前虽大有改进，但仍然在很多情况下会失效。有一些著名的程序(如 fiftyp.c, thud.c, chew.c, ring-test.c)总能让该调度器性能下降，导致交互式进程反应缓慢。\n为了解决这些问题，大量难以维护和阅读的复杂代码被加入 Linux2.6.0 的调度器模块，虽然很多性能问题因此得到了解决，可是另外一个严重问题始终困扰着许多内核开发者。那就是代码的复杂度问题。这些不足催生了 Con Kolivas 的楼梯调度算法 SD，为调度器设计提供了一个新的思路。之后的 RSDL 和 CFS 都基于 SD 的许多基本思想。\n楼梯调度算法 #  O(1)调度器算法的主要复杂性来自动态优先级的计算，调度器根据平均睡眠时间和一些很难理解的经验公式来修正进程的优先级以及区分交互式进程。这样的代码很难阅读和维护。\n楼梯调度算法(staircase scheduler)抛弃了动态优先级的概念，而采用了一种完全公平的思路。其思路虽然简单，但是实验证明它对应交互式进程的响应比 O(1)调度器更好，而且极大地简化了代码。\n和 O(1)调度器一样，楼梯算法也同样为每一个优先级维护一个进程队列，并将这些队列组织在 active 数组中。当选取下一个被调度进程时，SD 算法也同样从 active 数组中直接读取。 与 O(1)算法不同在于，当进程用完了自己的时间片后，并不是被移到 expire 数组中。而是被加入 active 数组的低一优先级列表中，即将其降低一个级别。不过请注意这里只是将该任务插入低一级优先级任务列表中，任务本身的优先级并没有改变。当时间片再次用完，任务被再次放入更低一级优先级任务队列中。就像一部楼梯，任务每次用完了自己的时间片之后就下一级楼梯。\n任务下到最低一级楼梯时，如果时间片再次用完，它会回到初始优先级的下一级任务队列中。比如某进程的优先级为 1，当它到达最后一级台阶 140 后，再次用完时间片时将回到优先级为 2 的任务队列中，即第二级台阶。不过此时分配给该任务的 time_slice 将变成原来的 2 倍。比如原来该任务的时间片 time_slice 为 10ms，则现在变成了 20ms。基本的原则是，当任务下到楼梯底部时，再次用完时间片就回到上次下楼梯的起点的下一级台阶。并给予该任务相同于其最初分配的时间片。总结如下：设任务本身优先级为 P，当它从第 N 级台阶开始下楼梯并到达底部后，将回到第 N+1 级台阶。并且赋予该任务 N+1 倍的时间片。\n以上描述的是普通进程的调度算法，实时进程还是采用原来的调度策略，即 FIFO 或者 Round Robin。\n楼梯算法能避免进程饥饿现象，高优先级的进程会最终和低优先级的进程竞争，使得低优先级进程最终获得执行机会。\n对于交互式应用，当进入睡眠状态时，与它同等优先级的其他进程将一步一步地走下楼梯，进入低优先级进程队列。当该交互式进程再次唤醒后，它还留在高处的楼梯台阶上，从而能更快地被调度器选中，加速了响应时间。\n从实现角度看，SD 基本上还是沿用了 O(1)的整体框架，只是删除了 O(1)调度器中动态修改优先级的复杂代码；还淘汰了 expire 数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。\nRSDL 调度算法 #  RSDL（The Rotating Staircase Deadline Schedule）也是由 Con Kolivas 开发的，它是对 SD 算法的改进。核心的思想还是“完全公平”。没有复杂的动态优先级调整策略。\nRSDL 重新引入了 expire 数组。它为每一个优先级都分配了一个 “组时间配额”， 我们将组时间配额标记为 Tg；同一优先级的每个进程都拥有同样的\u0026quot;优先级时间配额\u0026quot;，本文中用 Tp 表示，以便于后续描述。\n当进程用完了自身的 Tp 时，就下降到下一优先级进程组中。这个过程和 SD 相同，在 RSDL 中这个过程叫做 minor rotation。请注意 Tp 不等于进程的时间片，而是小于进程的时间片。下图表示了 minor rotation。进程从 priority1 的队列中一步一步下到 priority140 之后回到 priority2 的队列中，这个过程如下图左边所示，然后从 priority 2 开始再次一步一步下楼，到底后再次反弹到 priority3 队列中。\n在 SD 算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得 CPU。因此低优先级进程的等待时间无法确定。RSDL 中，当高优先级进程组用完了它们的 Tg(即组时间配额)时，无论该组中是否还有进程 Tp 尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是 RSDL 中 Deadline 代表的含义。 进程用完了自己的时间片 time_slice 时（下图中 T2），将放入 expire 数组中它初始的优先级队列中(priority 1)。\n当 active 数组为空，或者所有的进程都降低到最低优先级时就会触发 major rotation：。Major rotation 交换 active 数组和 expire 数组，所有进程都恢复到初始状态，再一次从新开始 minor rotation 的过程。\n和 SD 同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为 minor rotation 而降到了低优先级进程队列中。当它重新进入 RUNNING 状态时，就获得了相对较高的优先级，从而能被迅速响应。\nCFS 完全公平调度算法 #  CFS 是最终被内核采纳的调度器。它从 RSDL/SD 中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS 的算法和实现都相当简单，众多的测试表明其性能也非常优越。\n按照作者 Ingo Molnar 的说法：\u0026ldquo;CFS 百分之八十的工作可以用一句话概括：CFS 在真实的硬件上模拟了完全理想的多任务处理器\u0026rdquo;。在“完全理想的多任务处理器“下，每个进程都能同时获得 CPU 的执行时间。当系统中有两个进程时，CPU 的计算时间被分成两份，每个进程获得 50%。然而在实际的硬件上，当一个进程占用 CPU 时，其它进程就必须等待。这就产生了不公平。\n假设 runqueue 中有 n 个进程，当前进程运行了 10ms。在“完全理想的多任务处理器”中，10ms 应该平分给 n 个进程(不考虑各个进程的 nice 值)，因此当前进程应得的时间是(10/n)ms，但是它却运行了 10ms。所以 CFS 将惩罚当前进程，使其它进程能够在下次调度时尽可能取代当前进程。最终实现所有进程的公平调度。下面将介绍 CFS 实现的一些重要部分，以便深入地理解 CFS 的工作原理[5]。\nCFS 如何选取下一个要调度的进程 #  CFS 抛弃了 active/expire 数组，而使用红黑树选取下一个被调度进程。所有状态为 RUNABLE 的进程都被插入红黑树。在每个调度点，CFS 调度器都会选择红黑树的最左边的叶子节点作为下一个将获得 cpu 的进程。\ntick 中断 #  在 CFS 中，tick 中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记 need_resched 标志，中断返回时就会调用 scheduler()完成进程切换。否则当前进程继续占用 CPU。从这里可以看到 CFS 抛弃了传统的时间片概念。Tick 中断只需更新红黑树，以前的所有调度器都在 tick 中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。\n红黑树键值计算 #  理解 CFS 的关键就是了解红黑树键值的计算方法。该键值由三个因子计算而得：一是进程已经占用的 CPU 时间；二是当前进程的 nice 值；三是当前的 cpu 负载。\n进程已经占用的 CPU 时间对键值的影响最大，其实很大程度上我们在理解 CFS 时可以简单地认为键值就等于进程已占用的 CPU 时间。因此该值越大，键值越大，从而使得当前进程向红黑树的右侧移动。另外 CFS 规定，nice 值为 1 的进程比 nice 值为 0 的进程多获得 10%的 CPU 时间。在计算键值时也考虑到这个因素，因此 nice 值越大，键值也越大。\n在本文中，我们将为每个进程维护的变量称为进程级变量，为每个 CPU 维护的称作 CPU 级变量，为每个 runqueue 维护的称为 runqueue 级变量。\nCFS 为每个进程都维护两个重要变量：fair_clock 和 wait_runtime。进程插入红黑树的键值即为 fair_clock – wait_runtime。\n fair_clock 从其字面含义上讲就是一个进程应获得的 CPU 时间，即等于进程已占用的 CPU 时间除以当前 runqueue 中的进程总数； wait_runtime 是进程的等待时间。它们的差值代表了一个进程的公平程度。该值越大，代表当前进程相对于其它进程越不公平。  对于交互式任务，wait_runtime 长时间得不到更新，因此它能拥有更高的红黑树键值，更靠近红黑树的左边。从而得到快速响应。 红黑树是平衡树，调度器每次总最左边读出一个叶子节点，该读取操作的时间复杂度是 O(LgN)。\n调度器管理器 #  为了支持实时进程，CFS 提供了调度器模块管理器。各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块。2.6.23 中，CFS 实现了两个调度算法，CFS 算法模块和实时调度模块。对应实时进程，将使用实时调度模块。对应普通进程则使用 CFS 算法。Ingo Molnar 还邀请 Con Kolivas 可以将 RSDL/SD 写成一个调度算法模块。\nCFS 源代码分析 #  每次时钟中断会调用 scheduler_tick()函数。它首先更新 runqueue 级变量 clock；然后调用 CFS 的 tick 处理函数 task_tick_fair()。task_tick_fair 主要工作是调用 entity_tick()。函数 entiry_tick 源代码如下：\nstatic void entity_tick(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  struct sched_entity _next;  dequeue_entity(cfs_rq, curr, 0);  enqueue_entity(cfs_rq, curr, 0);  next = **pick_next_entity(cfs_rq);  if (next == curr)  return;  __check_preempt_curr_fair(cfs_rq, next, curr,  sched_granularity(cfs_rq)); } 首先调用 dequeue_entity()函数将当前进程从红黑树中删除，再调用 enqueue_entity()重新插入。这两个动作就调整了当前进程在红黑树中的位置。_pick_next_entity()返回红黑树中最左边的节点，如果不再是当前进程，就调用_check_preempt_curr_fair。该函数设置调度标志，当中断返回时就会调用 p-\u0026gt;sleep_avg进行调度。 函数 enqueue_entity()的源码如下:\nenqueue_entity(struct cfs_rq _cfs_rq, struct sched_entity _se, int wakeup) {  update_curr(cfs_rq);  if (wakeup)  enqueue_sleeper(cfs_rq, se);  update_stats_enqueue(cfs_rq, se);  __enqueue_entity(cfs_rq, se); } 它的第一个工作是更新调度信息。然后将进程插入红黑树中。其中 update_curr()函数是核心。完成调度信息的更新:\nstatic void update_curr(struct cfs_rq _cfs_rq) { struct sched_entity _curr = cfs_rq_curr(cfs_rq); unsigned long delta_exec; if (unlikely(!curr)) return; delta_exec = (unsigned long)(rq_of(cfs_rq)-\u0026gt;clock - curr-\u0026gt;exec_start); curr-\u0026gt;delta_exec += delta_exec; if (unlikely(curr-\u0026gt;delta_exec \u0026gt; sysctl_sched_stat_granularity)) { __update_curr(cfs_rq, curr); curr-\u0026gt;delta_exec = 0; } curr-\u0026gt;exec_start = rq_of(cfs_rq)-\u0026gt;clock; } 该函数首先统计当前进程所获得的 CPU 时间，rq_of(cfs_rq)-\u0026gt;clock 值在 tick 中断中被更新，curr-\u0026gt;exec_start 就是当前进程开始获得 CPU 时的时间戳。两值相减就是当前进程所获得的 CPU 时间。将该变量存入 curr-\u0026gt;delta_exec 中。然后调用__update_curr():\n__update_curr(struct cfs_rq _cfs_rq, struct sched_entity _curr) {  unsigned long delta, delta_exec, delta_fair, delta_mine;  struct load_weight _lw = \u0026amp;cfs_rq-load;  unsigned long load = lw-\u0026gt;weight;  delta_exec = curr-\u0026gt;delta_exec;  schedstat_set(curr-\u0026gt;exec_max, max((u64)delta_exec, curr-\u0026gt;exec_max));  curr-\u0026gt;sum_exec_runtime += delta_exec;  cfs_rq-\u0026gt;exec_clock += delta_exec;  if (unlikely(!load)) return;  delta_fair = calc_delta_fair(delta_exec, lw);  delta_mine = calc_delta_mine(delta_exec, curr-\u0026gt;load.weight, lw);  if (cfs_rq-\u0026gt;sleeper_bonus \u0026gt; sysctl_sched_min_granularity) {  delta = min((u64)delta_mine, cfs_rq-\u0026gt;sleeper_bonus);  delta = min(delta, (unsigned long)((long)sysctl_sched_runtime_limit - curr-\u0026gt;wait_runtime));  cfs_rq-\u0026gt;sleeper_bonus -= delta;  delta_mine -= delta;  }  cfs_rq-\u0026gt;fair_clock += delta_fair;  add_wait_runtime(cfs_rq, curr, delta_mine - delta_exec); } __update_curr()的主要工作就是更新前面提到的 fair_clock 和 wait_runtime。这两个值的差值就是后面进程插入红黑树的键值。变量 Delta_exec 保存了前面获得的当前进程所占用的 CPU 时间。函数 calc_delta_fair()根据 cpu 负载（保存在 lw 变量中），对 delta_exec 进行修正，然后将结果保存到 delta_fair 变量中，随后将 fair_clock 增加 delta_fair。函数 calc_delta_mine()根据 nice 值（保存在 curr-\u0026gt;load.weight 中）和 cpu 负载修正 delta_exec，将结果保存在 delta_mine 中。根据源代码中的注释，delta_mine 就表示当前进程应该获得的 CPU 时间。\n随后将 delta_fair 加给 fair_clock 而将 delta_mine-delta_exec 加给 wait_runtime。函数 add_wait_runtime 中两次将 wait_runtime 减去 delta_mine-delta_exec。由于 calc_delt_xx()函数对 delta_exec 仅做了较小的修改，为了讨论方便，我们可以忽略它们对 delta_exec 的修改。最终的结果可以近似看成 fair_clock 增加了一倍的 delta_exec，而 wait_runtime 减小了两倍的 delta_exec。因此键值 fair_clock-wait_runtime 最终增加了一倍的 delta_exec 值。键值增加，使得当前进程再次插入红黑树中就向右移动了。\nCFS 小结 #  以上的讨论看出 CFS 对以前的调度器进行了很大改动。用红黑树代替优先级数组；用完全公平的策略代替动态优先级策略；引入了模块管理器；它修改了原来 Linux2.6.0 调度器模块 70%的代码。结构更简单灵活，算法适应性更高。相比于 RSDL，虽然都基于完全公平的原理，但是它们的实现完全不同。相比之下，CFS 更加清晰简单，有更好的扩展性。\nCFS 还有一个重要特点，即调度粒度小。CFS 之前的调度器中，除了进程调用了某些阻塞函数而主动参与调度之外，每个进程都只有在用完了时间片或者属于自己的时间配额之后才被抢占。而 CFS 则在每次 tick 都进行检查，如果当前进程不再处于红黑树的左边，就被抢占。在高负载的服务器上，通过调整调度粒度能够获得更好的调度性能。\n在最新版本的 CFS 实现中，内核使用虚拟运行时间 vruntime 替代了等待时间，但是基本的调度原理和排序方式没有太多变化。\n参考资料 #  [1] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核[M]. 中国电力出版社, 2001.\n[2] DanielP.Bovet, MarcoCesati, Bovet,等. 深入理解 LINUX 内核(第三版)[M]. 中国电力出版社, 2007.\n[3] 陈莉君, 康华. Linux 操作系统原理与应用[M]. 清华大学出版社, 2006.\n[4] RobertLove, 洛夫, 陈莉君, et al. Linux 内核设计与实现[M]. 机械工业出版社, 2006.\n[5] Linux 调度器发展简述 https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/\n[6] O(n)、O(1)和 CFS 调度器 http://www.wowotech.net/process_management/scheduler-history.html\n[7] 调度系统设计精要 https://draveness.me/system-design-scheduler/\n[8] 进程调度之 6：进程的调度与切换 https://my.oschina.net/u/3857782/blog/1857556\n"},{"id":7,"href":"/docs/cs/the-clean-coder/","title":"The Clean Coder","section":"计算机","content":"《The Clean Coder》 阅读记录 #  术道结合，这本书不教术，更多的传道，且不仅仅适用于职业，还适用于处理其他事物。尽管是只可意会的道，依然可以通过娓娓道来的叙述与提炼，使读者联系自身经历，揣摩体悟，纳为己用。\n0、关于职业素养 #  如何体现职业素养？\n从自身出发，回答一个问题：在过去的工作中，遇到过哪些印象深刻的困难，最后是怎么解决的？ 问题不在于问题的难度，而在于反思的程度：怎么分析问题、查阅什么资料、采取解决问题的方式步骤、采取什么措施避免和改进。\n从外部出发，是否对外展示了专业精神获得外部人员的信任？是否需要对你进行微观管理才能令人放心？\n总结起来，职业素养 = 能力（技术） + 素质（价值观、原则、态度）+ 持续的积累和养成。\n关于价值观，可阅读前言部分 “挑战者”号航天飞机工程师的故事。  1、专业主义 #  “哦！笑吧，科延，老伙计。这是上帝，或者也可以说时命运或自然，跟我们开的一个玩笑。不过，不管这家伙是谁或是什么，他真幽默！哈哈！” —— 霍华德，《碧血金沙》    清楚你到底要的是什么？真的是成为专业人士吗？不仅仅是荣誉与骄傲，更多的是责任与义务。\n  担当责任，不仅如何保全自己，还有客户及他人。\n  不行损害之事：让 QA 找不出任何问题 + TDD 100% 覆盖率的要求 + 随时重构 + 自动化 QA  0、就像医生一样，虽然 Bug 无法避免，但是需要为出现的 Bug 负责。 1、练习道歉，道歉时必要的。 2、不能铭记过去的人，注定要重蹈覆辙。有责任让失误率无限接近零。     专业人士的职业生涯：\n 了解你的领域，如设计模式。过去来之不易的理念，大部分依然像过去一样富有价值。 坚持学习，与时俱进：想想你会去找已经不看医学期刊的医生看病、会聘请不了解最新税法和判例的税务律师吗？ 需要投入时间和精力去追求和练习（想想音乐家的表演和练习）。因为热爱，额外的20小时能让你免于枯竭匮乏。 合作与辅导是必要的。 了解业务领域：不可以不求甚解，能辨别与质疑。 与雇主 / 客户保持一致：站在雇主的角度思考，而开发人员之间互相认同是容易的，应当避免狭隘之见。 谦逊。  编程是及其自负的行为，专业人士知道此，因此不会故作谦逊：他们熟知自己的工作，并引以为荣；他们对自己的能力充满自信，并因此用于承担有把握的风险。专业人士不是胆小鬼。 然而，专业人士也知道自己会摔跟头，自己的风险评估也有出错的时候，自己也有力不从心的时候。这时候，如果他们照照镜子，会看到那个自负的傻瓜正对着自己笑。 因此，在发现自己成为笑柄时，专业人士会第一个发笑。他从不会嘲讽别人，自作自受时他会接受别人的嘲讽。反之，他则会一笑了之。他不会因别人犯错就对之横加贬损，因为他知道，自己就是下一个犯错的人。 专业人士都清楚自己的自负，也知道上天会注意到这种自负，并加以惩戒。如若果真遭遇挫折，最好的办法就是按照霍华德说的————一笑了之吧！       2、说不 #  “能就是能，不能就是不能。不要说‘试试看’。” ———— 尤达  奴隶没有权利说“不”。劳工或许也对说“不”有所顾虑。但是专业人士应该懂得说“不”。只有敢于说“不”，才能真正做成一些事情。  2.1 对抗角色 #  13、团队与项目 #   有凝聚力的团队：团队组建、克服差异（一起搞定一切）、多个项目中整体移动 给足时间，成为引擎，军团  14、辅导、学徒期与职业素养 #   导师很重要，可以更好、更加顺利地跨过一些坎。 可以有多种形式的辅导。 软件学徒期是必要的，类比医学生（人命关天） 职业素养：能力（技术）和素质（价值观、原则、态度），以及持续的积累和养成。 非理性决策，非感情用事，只要能被人观察到，便具有传染性：成为表率，向人展示即可。  15、工具 #   使用工具，不再是思考下一步要键入什么字符或代码，而是思考接下来要对代码进行什么样的变换。  "},{"id":8,"href":"/docs/example/table-of-contents/without-toc/","title":"Without ToC","section":"Table of Contents","content":"At me ipso nepotibus nunc celebratior genus #  Tanto oblite #  Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius #  Quibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\n Remansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit  Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae #  Credulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\n Baculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra  Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"},{"id":9,"href":"/docs/algorithm/tree/1/","title":"二叉树 - 子树分解题","section":"二叉树","content":"二叉树 - 子树分解题 #  基础 #   https://leetcode-cn.com/problems/diameter-of-binary-tree/ https://leetcode-cn.com/problems/invert-binary-tree/submissions/ https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/  构造题 #   https://leetcode-cn.com/problems/maximum-binary-tree/  "},{"id":10,"href":"/docs/algorithm/tree/3/","title":"二叉树 - 构造题","section":"二叉树","content":"二叉树 - 构造题 #   https://leetcode-cn.com/problems/maximum-binary-tree/ https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/  "},{"id":11,"href":"/docs/algorithm/tree/2/","title":"二叉树 - 遍历题","section":"二叉树","content":"二叉树 - 遍历题 #   https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/  "},{"id":12,"href":"/docs/law/shang-ru-gong-si-fa/","title":"商入公司法","section":"法类","content":"“商入公司法” #  商法调整的是商事关系，商事几乎包括各种以营利为的商品交换以及与此相关的其他活动。\n一般而言，商事关系具有以下特征：一是主体的平等性；二是只发生在以营利为目的而进行的商事活动过程，这是商事关系区分于其他法律关系尤其是普通民事关系的最重要的特点。营利至少包括获取利益、常业性。\n商法按内容来分包括商事组织法与商事行为法。\n 商组织作为从事商活动的主体，关系到方方面面，法律自然要设定规范，规制其准入与存续。商组织法包括商事主体的设立、组织、管理、变更、解散、破产、清算而发生的内外关系。对外关系主要由债等民法调整，因而主要是对内关系。 商行为存在着商活动的特性，有别于一般的民事行为，因而也被特殊规定。商行为法包括票据法、证券法、保险法和海商法等商法部门。  公司法是最主要的商组织法。\n公司本质 #  公司的法律性质即为最底层的法律原则。\n公司概念 #  在大陆法系国家，公司仅指具有法人资格的营利性社团，从实质来看，它至少具有三个要素构成，即独立的人格、个人结合的社团、以营利为目的；在形式上它还要满足依法设立，即依据商事法律规定的条件和程序而设立公司。\n人格性 #  指公司具有独立的人格，这种独立的人格使其能够区别于其成员而独立存在。\n人格是权利义务的归属点，拥有人格意味着公司具有权利能力和行为能力，能够享有权利，承担义务。能够独立从事经营活动，实施法律行为，并能够依法承担民事责任。\n公司人格的外征表现：名称（区分）、独立财产（承担责任，公司的财产丧失可能导致人格也消灭）、自己的组织机构（意志形成、行为执行）。\n公司需要依法登记才能取得独立人格地位。因此在一定意义上可以说完全是法律的产物，是法律上的一种拟制。（1）采用二元主体的民事架构，最主要的目的在于方便公司从事各种经营活动；（2）拟制并不意味着有实体，因而公司人格具有可否认性。\n社团性 #  即以社员的结合作为其成立基础，我国《公司法》采用的是企业法人，民法典表达为“营利主义”。现代公司法显示承认一人公司的存在已成为时代的潮流，我国现行公司法也已经突破了公司的社团性，规定了一人有限责任公司。\n营利性 #  以营利为目的指组织公司成员各自以其出资经营某项事业并将公司所获得的利益分配给它的社员作为最终目的。\n公司企业存在的目的在于追求利润最大化，表现为（1）股利的分配；（2）剩余财产的分配。\n现代公司法要求公司在考虑利润最大化目标时，也要兼顾“利益相关者（stakeholder/other constituencies）”的利益，即承担一定的社会责任。\n公司特征 #  制度的价值、作用，主要内容，法律立场。\n即公司这种企业区别于其他商事组织，而使其成功的原因特征：集中管理、所有人的有限责任、的股权自由转让和公司的永久存在。\n集中管理 #  所有权和经营权的分离，将公司交给更具备专业技术经验的经营者。但集中管理在封闭公司是不明显的。\n 投资者有限责任的产生：既然股东不能直接参与企业管理，又怎么能够像合伙人承担无限责任呢 所有者权益的自由转让：如果股东对公司经营不满意，他可以通过股权转让退出公司。 公司的独立主体地位：只要投资人愿意，公司可以无限期地存在。  有限责任 #  按认缴的出资额或认购的股份份额承担责任。核心是在公司和其股东划出一条明显的界限。“简单来讲，对于投资者而言其可以多项投资，更敢更省事；对于实际经营管理者而言，只有公司经营良好才不至于使股权被收购自己被替换。”\n 降低监控代理人的成本，投资人可以多样化投资来分散风险，也可以多样化和消极监督 降低监控其他股东的成本，合伙制情形下合伙人还要监督其他合伙人的财产状况 股份自由转让会刺激管理层进行更为有效的管理 有限责任存在股份交易的公开市场，价格能够极大的企业价值的附加信息，减少投资人花费大量资源去考察附加信息 投资者可以多样化投资，这也大大降低了企业筹资成本 促进投资者投资风险事业的投资而不至于遭受毁灭性损失  股权自由转让 #  公众公司存在为其股份转让的公开市场。\n 股东可以自由退出而公司资本不致减少 促使公司管理水平的提高 公开市场能够最大限度地反映财产的价值  公司的永久存在 #  实际含义是公司不会像合伙企业那样因为成员的退出而导致解散，合伙的存在依附于合伙协议。公司”永续存在“，但其控制权却可能发生了无数次的易手。\n公司法律性质探讨 #  基于法理和体系的视角中，进一步挖掘的公司的本质特征。\n法人说 #  公司是法人，具有独立的主体地位。公司完全是法律的产物，公司的设立和运作均需要依照法律的规定进行。公司法具有明显的强制性特征。\n法人理论受到了相当的批评，其认为法人说片面强调形式主义，公司是一种虚拟的实体，而非真实意义上的人，公司之所以是”法人“，只不过是因为法律进行了这样的，而公司之所以讲公司拟人化，主要是为了方便人们从事商事经营活动。\n批评者进一步分析，人们常将有限责任、法人身份以及永久存在视为公司的显著特征，这其实是一种误导性陈述。\n 有限责任只是意味着投资者所承担的企业风险不会超过其初始成本，这是投资的特征而非公司的特征。 法人身份和永久存在仅仅意味着公司在解散之前持续存在，并且有一个名称以便于交易和应付诉讼，否则公司在进行某一项交易时，公司都需要次次明确公司所有投资者的名单及份额。  公司法人虚拟性的一个反正是在特定而有限的情况下，如果这种虚拟实体实施了欺诈行为或明显违反法律政策或是实施了其他有害行为，法律可以适用“揭开公司面纱”原则否认其人格。\n契约关系说 #  公司完全是由当事人一系列协议构成，当事人有权对诸如公司治理等问题进行自主安排。\n契约关系理论认为企业是雇员、管理者、股东等资源结合起来自行安排各种交易，他们共同收到一种复杂的契约关系链条的约束。\n企业并不是某种人格化的东西，而是在组成企业的各种要素之间确定了一系列合约安排，即一系列合同束。除了当事人约定的合同之外，有一些合同体现着法院和立法者的意志，这类合同的作用在于，它有如人们在遇到类似问题而真正订立合同时必然会采用这样的条款一样。\n其中体现了经济学家与法学家极为不同的差异，即对于隐形合同的认可与否，法学家认为合同在于传统的要约承诺，公众公司从来没有阅读过公司章程，最多只能说他们接受这份章程，而不可能认定是预定的。\n契约论实际上是应然而非实然，即这样的合同内容符合追利人的期待，是节省成本的一种安排，自由订立也会选择该规范。\n契约关系论反对公司法人理论，认为“公司的法人性恰恰掩盖了交易的本质”，因为每一根人只拥有自己投入的一部分，任何人无权对公司享有全部所有权。公司中的中心人物是管理者。\n相反地，其认为公司只不过是一种契约关系，政府不能对私人商业活动干预，政府不应该通过制定法形式讲强制性规范加于公司或当事人。而政府的特许令状不过是对于公司这种契约的承认而已，并诉讼方便，交易便利。\n契约论最重要的优点在于转变公司法的规范态度，给公司更多的活性，能够更加充分的发挥公司的优势，自由管理主体优势。\n"},{"id":13,"href":"/docs/other/%E8%92%8B%E5%BB%B7%E9%BB%BB%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"蒋廷黻《中国近代史》读书笔记","section":"非法类","content":"《蒋廷黻《中国近代史》读书笔记 #  一、剿夷与抚夷 #  4、民族丧失二十年的光阴 #   鸦片战争失败的根本理由：军器和军队是中古的军队、政府是中古的政府、人民、士大夫阶级是中古的人民。因此虽拼命抵抗，终归失败，是自然的、逃不脱 的。 鸦片战争的军事失败还不是民族致命伤，失败以后还不明了失败的理由，力图改革，才是民族的致命伤。 为何？  中国人的守旧性太重。 我国文化是士大夫阶级的生命线。一实行新政，文化摇动，就是饭碗的摇动。 士大夫阶级最缺乏独立的、大无畏的精神。    "},{"id":14,"href":"/docs/law/%E5%9B%BD%E9%99%85%E6%8A%95%E8%B5%84%E4%BB%B2%E8%A3%81%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E6%94%B9%E9%9D%A9/","title":"国际投资仲裁的发展与改革","section":"法类","content":"国际投资仲裁的发展与改革——为什么仲裁结果总是不统一，除了增加透明度与设立上诉机制我们还能做什么 #  国际投资仲裁概况 #  20世纪60年代后期，国际社会开始尝试将国际仲裁作为解决主权国家与外国私人投资者之间投资争议的方式，缔结了《华盛顿公约》，建立了解决投资争议国际中心ICSID，ICSID允许加入国拒绝将某项具体争议提交ICSID仲裁，也有权将某些种类的争议排除在可仲裁的范围之外。因而更为可接受，但20世纪90年代子厚，这种节制的机制开始逐渐失去戒指，美式BIT和一些区域性贸易协定的投资章节规定投资者可以直接提请国际仲裁，导致国家主权的行政权、司法权、立法权受到挑战。\n实体问题 #   适格投资、适格投资者的范围过于广泛：华盛顿公约允许将缔约国国民控制的非缔约国公司视为公约意义上的合格投资者 模糊的实体法规范：没有统一的解释，使主权国家对专辑的行为符合shi\u0026rsquo;fou条约要求缺乏预见性，也为仲裁庭随意解释这些条款增加的条约义务了chuang\u0026rsquo;zao条件。eg公平公正没有准确的标准可循。 措施的概念过于宽泛，只要投资者认为东道国采取的措施违反了在投资条约下的义务就可以提起国际仲裁，而措施已经不仅包括行政管理措施，还包括东道国的司法行为和立法行为。egloewen诉美国案认定法院在案件审理过程中存在严重的审判不公和行为不当的情形。  程序问题 #   东道国无需具体同意，而是”概括的同意“，在事前的同意时，东道国同意将争议提交国际仲裁裁决时，根本无法与之ujin\u0026rsquo;h会否与投资者发生纠纷以及因何原因发生纠纷。 现代投资条约中的程序性涉及缺乏对仲裁员自由裁量权和仲裁程序的适当监督和对不一致裁决的适当协调和纠正，出现投资者倾向的仲裁员。 执行不被认可。 现代投资条约为投资者提供了诸多挑选救济场所的机会，可以通过多个BIT重复申请。  国际投资仲裁的发展与改革现况 #  仲裁特征：一裁终局和自由选择仲裁员。\n概况：美欧对国际投资仲裁机制进行改革的不同模式 #  针对国际投资仲裁机制的缺陷，美国与欧盟在传统双边协定模式的基础上，分别以北美自由贸易协定模式与常设仲裁模式加以改革。**两种模式在仲裁员由谁指定、上诉机制的设置以及仲裁庭的常设性和多边性等存在制度分歧。**美欧的制度不仅反映了两者对国际投资仲裁机制改革应采取投资者主导型还是东道国主导型路径的不同认知，还反映了两者对国际投资仲裁制度主导权的争夺。（1） 关于国家投资仲裁的改革，主要集中在是否建立一个常设的投资仲裁法庭和规定上诉机制的问题上。联合国贸易和发展委员会议提出了详细的国际投资协定的改革建议，包括设立一个常设的攻击投资仲裁法庭以及上诉机制。（7）\n投资争议解决机制是近四十年来国际投资协定中的常见条款，投资者诉国家解决争端解决机制（ISDS，investor-State Dispute Settlement）赋予投资者国际仲裁方式起诉东道国的权利。 （2）\nUNCTAD world investment report 可以看到现在的国际投资仲裁数量\n有人认为，国际投资仲裁制度或许正遭遇一场“正当性危机”（legitimacy crisis，即国际投资仲裁由于在解决国际投资争端方面不胜任而引发的信任危机。主要在于1投资条约中没有清楚、确定地规定投资者权利标注暖，致使当事人、仲裁庭在适用投资条约时缺乏预见性，尤其时不同仲裁庭就类似案件的决定常常不一致2国际投资条约在程序上对投资者利益的保护甚于对东道国利益的保护，有损东道国主权（3） 事实表明，传统给国际商事仲裁引以为自豪的一些优势，如非公开地处理争端、仲裁庭的成立相对简便易行、仲裁裁决一裁终局且具有强制执行力、仲裁员拥有充分的自由裁量权等，反而被证明具有种种缺陷，因为这涉及判断一个主权行为是否在国际法上属于合法行为。（程序实体） 2013年6月，联合国贸易与发展大会（UNCTAD）曾发布一份报告，对目前国际投资仲裁制度受到广泛诟病的几个方面进行了总结，并未如何改革提出了”路线图“，根据该报告，目前国际投资仲裁机制的弊端主要包括：程序的正当性和透明度不够（我们一般讲的正当性不够指的是更加倾向于投资者的利益，背景是最开始签订的时候发展中国家就让渡了相应的权利以求投资，一开始就是不平等的；指的是对公众知情权东道国公权力行使的侵犯：是相对于一般的商事仲裁而言的）；仲裁裁决缺乏一致性以及错误的裁决无法纠正（同类案不同判，同类规定不同解释。国际投资仲裁中，任何仲裁庭的裁决都不会对其他仲裁庭有任何约束力，仲裁庭都有权就自己案件中争议的问题重新进行审判）；仲裁员由当事人指定，使仲裁员的独立性和中立性都受到质疑；使仲裁程序的时间和经济成本过高。（5）裁决的矫正机制缺失：是哟个法律不正确并不是ICSID公约的裁决撤销理由。不一致可以从伊克卡乐公司案与基里克案关于投资者是否需要用尽当地救济才能够提起国际投资仲裁二者做出了截然不同的解释，并且仲裁员中的桑兹教授均为仲裁员。（8） 评价制度和评价改革就能够从与目前国际投资仲裁的弊端具有什么样的相关关系来进行逐条分析。\nICSID的成立是改善发展中国家投资环境所作出的一项重要的多边努力。现在，ICSID不在苦于案源不足，而是逐步意识到在效率、声誉等方面面临着挑战，呼吁投资者积极利用ICSID调节机制或自行解决争端。有学者认为ICSID裁决缺乏一致性；更有学者批判国际投资仲裁的程序缺陷，如仲裁员存在偏见、程序不公开、耗时费钱等。（4）\n众所周知，ICSID的产生很大程度上是二战后南北矛盾的产物，其发展也是南北矛盾演进的一个缩影。换言之，发达国家虽然认为发展中家落后的法制状况难以为外国投资者提供有效保护，但也意识到传统外交保护可能被认为是干涉内政，因而谋求创设某种国际争端解决机制。与此同时，为吸收外资并避免发达国家以保护海外投资为名干涉内政，暗中国家fa\u0026rsquo;z对于创设国际争端解决机制也具有显示的利益，因而同意适当让渡对涉外投资争端的管辖权。（4） 1肇始于于20世纪下半夜的国际投资法律制度源于解决资本输出国的外国投资者在资本输入国受到不公正待遇而制定额双边投资协定，早期主要目的在于避免后殖民化时期外国投资者受到东道国不断改革的法律和这个测制度所产生的负面影响。二战后面对的是东道国对于其财产的征收通常没有给予补偿，而这种行为明显侵犯其财产权和其他权力。2随着经济民族主义的衰退，发展中国家开始采取各种方法吸引外资，在很大程度上不公正对待外国投资的现象少了，这一时期的投资争端数量减少了而且集中东道国对外国投资的歧视或违反公平公正待遇等问题上3随着21实现可持续发展的目标提出以及国家对外国投资带来负面印象，投资者根据相关投资以xi的尸体保护标准提起赔偿诉求的案件不断增加，而仲裁庭做出䣌不利于东道国的巨额赔偿裁决给的东道国经济发展带来沉重的负担，包括发达国家也开对国际投资仲裁有了怀疑态度。（8）\n国际投资法正在经历一个巨大的变化，相较于过去只重视投资者利益的做法，人们越来越意识到投资仲裁中的公法属性，(9)\n卡尔沃主义：在西方探险家发现每周新大陆后，拉美国家开始遭受西方列强以外交保护为名干涉内政的痛苦经历，国家主权受到严重侵犯，在此背景下，19世纪阿根廷国际法学家卡洛斯·卡尔沃提出了著名的”卡尔沃主义“，其根本总之在于拒绝干涉内政，维护国家主权。卡尔沃主义的基本原则有两项：一是主权国家基于主权平等原则不受任何形式的干涉；而是外国人物权享受东道国没有对国民规定的权利或特权，外国人只能寻求当地救济，不干涉及外国人与本国人之间的绝对平等是卡尔沃主义的本质所在。（4）\n美国与欧盟模式 #   传统双边投资协定模式（传统BIT模式）：脱胎于商事仲裁，授予投资者对东道国政府违反国际投资协定的行为提起仲裁的权利，允许其自由选择国际投资争端解决中心ICSID或联合国国际贸易法委员会UNCITRAL提供的仲裁规则或双方约定的其他仲裁规则开展仲裁，双方投资协定对仲裁员制定、仲裁程序透明度和参与性、上诉机制、轻佻仲裁请求（frivolous claim）、竞合或平行程序等不做限定或补充。这种模式在20世纪90年代之前发达国家和发展中国家签订的投资双边协定中比较常见。 2.环境变化： 20世纪90年代之后，国际投资环境发生变化，新兴国家崛起，南南合作、北北合作增加，资本流动不再限于南北国家之间的依附性流动。争议对象多为发达国家的公共健康及环境政策，而不再是传统上东道国政府对投资财产的直接征收措施。投资争议类型的改变，催生国际投资仲裁机制功能的改变，资本输出国所提供的条约文本不仅需要具备海外投资利益保护的“攻击性”功能，还需具备防范境外投资者滥诉以及制约本国政府形式提供环境、公共卫生等公共产品只能的“防御性”功能，并由此改善国际投资法环境。 （2）对当前ISDS机制最常见的批评是认为它威胁到主权国家通过立法实现合法公共政策目的的能力。仲裁裁决没有充分保护政府的管制权，仲裁庭解释权过大，损害了政府的权利。 美国：率先对攻击投资仲裁机制做出调整，94年《北美自由贸易协定》第11章国际投资仲裁条款对传统BIT模式做出修订，形成北美自由贸易协定模式（NAFTA模式）NAFTA模式仍允许争端方选择ICSID和UNCITRAL等投资仲裁规则，但在协定中对后者做出补充或限制。例如：该协定增加了仲裁程序的透明度，允许非争议第三方及“法庭之友”提交意见书。浙西都是对传统BIT模式的调整。又如，在争端方未能制定仲裁员或首席仲裁员的情形下，该协定将ICSID仲裁规则下世界银行行长对仲裁员的制定权转移至《北美自由贸易协定》秘书处，从而强化了争端放对仲裁员的控制，对传统BIT模式形成限制。 NAFTA对于仲裁机制的改革并不彻底，虽然提高了国际投资仲裁程序的透明度与参与性，但未从根本上解决仲裁庭的问责性不足和裁决不一致问题。美国在《美国与中美州五国和多米尼加自由贸易协定》及《美国与新加坡自由贸易协定》中提出设置上诉机制的构想，以强化仲裁机制的问责性。2016年签署的《跨太平洋伙伴关系协定TPP》中有关仲裁程序的透明度、第三方参与、上诉机制的条款亦延续了美式投资协定对NAFTA模式进行改革的传统。（11）目前，除美国以外，NAFTA模式还为加拿大、日本、韩国等国对外签订的国际投资协定所采纳。中国在2014年签署的《中加投资促进及保护协定》和2015年签署的《忠告自由贸易协定》中也采纳了此模式。 欧盟：欧盟第国际投资仲裁机制的改革要晚于美国，但改革力度更大。其背景在于1999年金融危机后，比利时、希腊、塞浦路斯等欧盟成员国因调整财政政策而纷纷陷入投资争端12，使得欧洲议会不得不正视国际投资仲裁机制对欧盟公共政策的挑战，要求欧盟委员会制定具体政策，避免成员国公共政策成为投资者起诉对象。（出于国家自愿，所以体现了国家的主观目的特征）在与美国进行的2013年《跨大西洋贸易与投资伙伴协定TTIP》谈判中，欧洲市民高呼废除国际投资仲裁机制，而欧洲议会及欧盟委员虽然最终决定保留国际投资仲裁机制，但对其予以答复改革，例如严格限定仲裁员资质和任期、固定仲裁原名册、设立上诉机制等（14）。草案不仅允许仲裁庭接受法庭之友意见（amicus curiae），也允许与案件结果有直接现实利益的第三方接入到程序中（right to intervene）,有助于加强程序公正；草案要求接受第三方资助的当事方披露资助方的信息，以及要求缴纳担保费，看可以限制投资者轻率起诉；草案提出建立上诉法庭，其主要理由是解决投资仲裁裁决的一致性问题；上诉法庭由6位法官组成，欧盟、美国和第三国各占2席，任期6年，可连任一次。  2015年5月欧盟贸易委员提交的一份报告提出设立常设仲裁庭的构想15，设立常设仲裁庭、以东道国为主导的常设仲裁庭模式最终出现在2016年欧盟与加拿大和越南分别达成的《欧加全面经济与贸易协定》和《欧越自由贸易协定》中。常设仲裁庭与NAFTA模式一致的地方在于，投资者依然可以适用ICSID与UNCITRAL等仲裁程序规则，国际投资协定对仲裁程序的透明度、第三方参与等问题作出较补充。但常设仲裁模式目前仍处于摸索阶段，仅在上述自由贸易协定中出现，尚不具有普遍性。\n2015年末，欧盟公布了与美国进行《环大西洋贸易和投资伙伴协定》谈判的投资章节的建议草案，之后欧加贸易协定、欧越贸易协定，都包括改革后的国际投资争端积极而机制，即设立常设的投资仲裁法庭制度，包括普通法庭共和上诉法庭。 欧盟包括三点：1消除国际商事仲裁制度运用于解决投资者-国家投资争端的弊端；与投资仲裁对东道国国内造成的影响不匹配；增强裁决一致性的建议层出不穷，而建立上诉机制一致被认为是最好的方法，如建立类似世界贸易组织上诉机构的上级法律组织来指导、监督临时成立的仲裁庭的工作。但要实现这一点，困难十足，在欠缺所谓“初步裁决”只丢的昂下qing\u0026rsquo;k，需要对当前主流制度性规定做出修改需要有关成员国就此问题达成政治和李，eg华盛顿公约裁决不得被任何上诉神擦汗，要修改需要得到全体成员国协商一致。设置解释委员会：仲裁员拥有的自由裁量权和解释条约的权因此设立解释力过大，甚至可能做出为违反缔约国意图，因而设立一个由各投资者组成的解释委员会，使成员国对涉及其自身的条款有更大的解释权。但是这样的杰斯还行只能适用于生效之后的诉请，而不具有任何溯及力，因而可能造成“亡羊补牢”的效果。增加透明度：目前只有在仲裁双方共同同意时才能将仲裁文件公开，因此很多投资者诉东道国的案件根本没有或者只有极少数文件被公布出来，欧盟不仅投资建立了对公众开放注册登录及查阅的数据库，主要从公开仲裁程序的重要文件，许可法庭之友的书面陈述及听证会分开等方面提高程序的透明度，2增强对东道国维护公共利益措施的考量，尽可能在保护投资者私人利益和为u东道国公共利益之间取得平衡3尽力防止投资者对投资仲裁程序的滥用。（9）\n增加透明度 #  （3）在国际商事仲裁制度中，仲裁机构往往不公开仲裁程序和仲裁文书，但仲裁制度应该有更强的透明度，具体说来，国际投资仲裁制度应当允许公开仲裁裁决及案件相关材料，应当第三人允许作为法庭之友或仲裁第三人加入仲裁程序：1BIT许多规则相对模糊，国际投资仲裁听在适用该规定时就徐做出解释，如仲裁庭有机会参考先前类似判决、听取第三方的意见，则仲裁庭将能够更全面地思考问题，以减少仲裁裁决前后不一致的情况。2国家投资争端往往涉及国家主权和公共利益，增强仲裁程序的透明度也将使公众能够关注、监督仲裁进程，这也将促使仲裁员更加谨慎地做出审判，一球投资者和东道国公共利益的平衡。 （6）”秘密进行的会议，未知的仲裁员，做出的不公开的裁决“这一小撮人对投资者与外国政府之间的争端做出的仲裁裁决，使一个国家的法律被废止，司法体系受到之一，环境法规遭到挑战。这也是《纽约时报》对于国际投资仲裁秘密性所引发的主要问题。除此之外，投资者与东道国的争端解决结果还会对公共资金和纳税人的税负产生重大影响，因为东道国一旦败诉即将面临高额赔偿。 从价值取向来看，投资者与东道国之间的关系仍然是司法人与公法人之间的不平等的关系，而政府活动需要遵守透明度和公共接入的基本要求。\n透明度改革的实现路径 #  国际投资条约 #  NAFTA直接以自由贸易委员会做出的解释性声明形式予以明确，条约局限于缔约方与另一缔约国投资者之间的争端。\n仲裁机构的仲裁规则 #  ICSID采取在其仲裁规则中讲透明度内容的条款进行规定或修改的方式 UNCITRAL《透明度规则》的适用涉及两种情况，对于《透明度规则》第1条范围内的条约，即2014年4月1日及以后订立的条约，以及之前订但仲裁双方同意适用的，或条约缔约方或涉及多边的tiao\u0026rsquo;yue投资人母国和被申请过同意适用（透明度规则）的条约。 关于《透明度规则》适用于现行投资条约，贸易法委员会则采用公约的方式实现，依据此方案，一国一旦加入此公约，《透明度规则》的适用范围将很广。\n条约与仲裁机构的规则相冲突 #  通常以条约为准。UNCITRA直接规定透明度规则与条约冲突以条约为准，ICSID仲裁规则第20条第2款规定”仲裁庭在仲裁程序中，应适用双方当事人有关程序问题的任何协议，但公约或行政和财务条例另有规定的除外。“\n透明度的具体内容（6） #   启动程序的公告 确保公众知晓东道国的争端已经启动，主体为被答辩方或仲裁庭.除此之外，联合国已于2014年4月1日在维也纳设立了透明度登记处。 仲裁程序中的文件公开 使公众获取相关仲裁信息和进展情况，也是涉及到主体范围时间，在具体文件的供不上，UNCITRAL有了一定创新，分为应当公布，经任何人请求应当公布以及仲裁庭行使自由裁量权公布三类，并应当主义保密信息的要求。 听证会的公开 用于保障公众对公共利益问题的参与权，分歧在于当事方是否审理的公开拥有否决权。 法庭之友 最终裁决结果 最终裁决结果以仲裁庭为宜。 透明度的例外 即对于保密信息的保护，从文本内容看，目前已进行的一些条约或仲裁规则对于透明度的的内容规定标准并不统一。ICSID的规定较为简略，相比之下USbit做了较为全面的规定，不仅详细列举了需要保护的信息，并对具体的保护程序做了安排，UNCITRAL工作组在起草相关条文内容的时候存在较大分歧主要集中在保密信息的认定是否可以依据被申请过的法律，后认为支持这一观点。  评价 #  积极意义在于对于之前的倾向投资者的直通车程序能够保证公众对公共事务的知情权和参与权，使公共利益问题得以通过可续恶的而方式决定，有利于仲裁员在投资者与东道国之间权利与利益的平衡。但面临着法律和技术层面的若干难题：（1）如何确保法庭之友的介入控制咋合理程度而不对争议双方造成不必要的损害；（2）透明度程序如何保证中参与gon以及文件公开的程序在合理时间内进行，不至于减损仲裁的效率优势；（3）如何确保文件公开的程序以合理的成本尽心，不至于增加争议双反过的负担等等。\n设立上诉机制 #  （2）2004年ICSID曾发布报告讨论建立上诉机制，尽管很多人认为有必要建立上诉机制，但是ICSID成员国认为还是为时过早，如果未来需要建立上诉机制，最好的办法还是通过ICSID，以提高不同之间条约结果的一致性。双边投资所建立的上诉机制更有可能投资法的碎片化，上诉机制对于提升裁判结果一致性的作用很可能会被夸大。尽管上诉机制可以增强裁决的一致性，但是增加案件的审理案件的审理时间，使得案件更加昂贵，这将加重中小投资者和发展中国家的负担。 （4）到2005年年中，可能有20个iaguo在BIT中考虑针对投资仲裁设立上诉机制，众多国家对国际投资仲裁机制的忧虑已经对ICSID产生了影响，促使ICSID开始考虑在ICSID体制内设立上诉机制问题。 （7）1.必要性（现况）已经从学者谈论阶段转为条文改革实践阶段；现况是不少仲裁案件的发生系基于相同或相似的条约条款、类似的商业背景和政府管理措施，但不同仲裁庭就相同或相似的条约义务做出的经常不同甚至完全相反。其问题还是在于仲裁庭过分地倾向投资者，引起东道国对于裁决的公正性的质疑。目前ICSID设立了裁决废除委员会，但没有设立被撤销后的措施；NAFTA为指fan争端解决机构对协定的解释出现偏差或错误授权协定下的权利机构公平贸易委员会对协定做引导性解释，对于这种解释争端解决机构必须服从，问题是1这种一致性意见很难获得2ICSID质疑其是否具有这种变相修改贸易协定的权力；3没有对仲裁庭不遵守解释性生命的行为如何补救。\n法庭之友 #  (6)Friend of the Court,源于拉丁文Amicus Curiae Brief,即对案件实质问题有重大利害关系的非诉讼当事方主动申请或应法庭要求向法庭提交书面意见的人。目前法庭之友的参与参在两种模式：一类是ICSID模式，详细列举仲裁庭在接受法庭之友文件时应靠考虑要素；另一类则是美国的简单规定模式，赋予仲裁庭比较大的裁量权，值得注意的是，UNCITRAL在法庭之友的规定上比较特殊，考虑到了非争端缔约方的参与可能会引发外交保护等政治风险，因此，将它与其他第三人区分开来，分别予以规制。（？）\n在法庭之友的规定上，美式BIT范本没有做太多限制，赋予仲裁庭较大的自由裁量权，其实是希望民间力量的接入保护其作为东道国的公共利益，美国非政府组织参加公共事务，表达诉求的机制已经较为成熟，而且美国国内的法庭之友制度也相对完善，一旦美国政府成为被告，法庭之友会踊跃参与，为美国谋求公共利益，这样的条文会促进保护美国作为东道国的利益而又不会将其投资者至于被动的位置。非争端当事方的参与者多为非政府组织，这些组织多来源于发达国家，难免与各投资者有千丝万缕的联系，从而可能共同向发展中国家发难（引用）\n欧加自贸协定和欧新自贸协定规定do仲裁庭“可以”在特定情形下接受第三方的法庭之友的意见，而《协定》投资章节草案第3节第23条则在接受法庭之友意见的同时，允许任何能够证明其与案件结果有直接现实利益的自然人或法人作为第三方接入程序dao当中，得到所有争议双方接收的程序性文件，在规定时间内提交书面陈述并在听证会中进行口头陈述。哟与第三方的参与只能是全部或部分地支持某一争端放的主张，而不能提出自己的主张，故第三方不具有独立的请求权。\n合并仲裁制度 #  合并仲裁是商事仲裁中常用的程序，其在国际投资仲裁中也应有用武之地。1合并仲裁制度已有立法依据，在NAFTA中，以及美国加拿大、墨西哥缔结的自由贸易协定中几乎都对合并仲裁做了规定。2合并仲裁制度已经有了实践经验，尤其是阿根廷经济危机发生后，投资者提起了众多针对阿根廷的投资仲裁请求，ICSID在受理仲裁请求时，将多起仲裁案件合并审理，取得了很好的成效，能够提高办案效率。\n第三方资助（略讲） #  第三方资助（third party funding）一般是指由与案件争议没有利益关系的第三方对一方当事人参加诉讼或仲裁提供资助的安排，实际上就是负担仲裁费用以及其他相关费用。第三方资助现象是国际仲裁领域近年来的重要新发展，虽然绝大多数第三方资助都在幕后进行，目前不可能有关于投资仲裁案件当事人受到第三方资助的统计数据，但是在一些发达国家如澳大利亚、德国等，第三方资助已形成产业。（引用待补5）\n日益增多 #   多个案件向我们展示了第三方资助在国际投资仲裁中占到了相应比例（第一个责令申请人缴纳仲裁费用担保的命令、第一个要求当事人披露第三方资助在isds中运用及其实践的具体清康） 国际上存在完全以第三方资助为业的相关公司（Burford投资回报率达到70%） 隐蔽性（不披露甚至签订保密条款）、产业化专业化、投资对象一般仅限于投资者  积极影响：接近司法access to justice #   提供资助：帮助陷入财务困境的投资者也能进行费用高昂的isds，拓宽权利救济途径 盈利行为：促使其会做相应请求的禁止掉擦汗，增加胜诉可能性 但具有立场，出发点仅在投资者的片面利益上。  消极影响：商业行为 #   增加无理的不充分的诉讼请求 存在利益关联影响公正性 其追求高额的赔偿而不像投资者单纯为了解决争议，而非更倾向于金钱  规制困境 #  有人甚至认为：国际投资仲裁中第三方资助事实上游离在无人监管的”法律真空地带“\n 对第三方资助的规制缺乏法律基础：视为国际合同，第三方可以选择更有利的法律并仲裁地免受规制 仲裁庭权力不够、动力不足 规制在实践中难以保证实施  对于弊端的作用 #   正当性和透明性：东道国基于本国的公共利益而采取的”合法行为“要被外国投资者诉诸仲裁，并通过私密的三个人决定支付巨额赔偿，针对东道国和东道国民众来说，显得非常不公平（奇怪，派员参加为何还是不公平）；缺乏正当性和透明性为第三方资助提供了空间：仲裁费用的负担往往是取决于仲裁员的自由裁量权的，而仲裁员更主张倾向投资者，并且无论如何东道国都是需要支付法律费用的。第三方资助加剧正当性和透明度缺失：从第三方资助本身而言，其就是针对投资者的，东道国本身即使胜诉也仅是无需赔偿，仍旧需要支付仲裁费用，因而其不可能在此种情况下还愿意向第三方在支付；其具有营利目的；其本身是私密的。 缺乏判决一致性：存在同案不同判的可能，第三方更敢于资助可能滥诉的行为；第三方资助会加剧不一致。 裁决的矫正机制缺失：能够使第三方更快地收回成本和营利，第三方因此也会积极地捍卫现在的制度。 第三方资助机构已经和国际仲裁员群体建立了千丝万缕的联系，第三方资助在这一点上对及gu投资仲裁制度的伤害最大，其会直接对被资助人委托什么律师、制定什么仲裁员进行干预。 高昂的时间成本和经济成本：刺激了第三方资助实践的产生和发展，对于经济上陷入困境的投资者来说，国际投资仲裁不仅花费高，耗费的时间成本也大，由此对于第三方资助的需求扩张；另外，由于第三方能够从中获利，其必然尽可能仲裁请求的金额，而仲裁请求的金额越大，自然仲裁费用越高。（5）  仲裁员 #  仲裁员由正义双方逐案挑选，且仅是投资者这一方有权提起诉讼。\n"},{"id":15,"href":"/docs/example/table-of-contents/","title":"Table of Contents","section":"Example Site","content":"Ubi loqui #  Mentem genus facietque salire tempus bracchia #  Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice #  Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non #  Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":16,"href":"/docs/example/collapsed/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":"4th Level of Menu #  Caesorum illa tu sentit micat vestes papyriferi #  Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":17,"href":"/docs/example/collapsed/3rd-level/","title":"3rd Level","section":"Collapsed","content":"3rd Level of Menu #  Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "},{"id":18,"href":"/docs/example/hidden/","title":"Hidden","section":"Example Site","content":"This page is hidden in menu #  Quondam non pater est dignior ille Eurotas #  Latent te facies #  Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona #  O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris #  Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":19,"href":"/docs/other/%E6%9E%97%E6%AF%85%E5%A4%AB%E8%A7%A3%E8%AF%BB%E4%B8%AD%E5%9B%BD%E7%BB%8F%E6%B5%8E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"林毅夫《解读中国经济》读书笔记","section":"非法类","content":"林毅夫《解读中国经济》读书笔记 #  粗浅读之，即便对于传统的经济学理论没有甚至初级的了解，从零开始，也通过林老师的介绍，收获颇多。简单归纳，以求在知识图谱中扎上这么一段清晰而博大的中国经济知识。\n我将从《解读中国经济》得到的知识分为三类。一是有关中国经济的过去、现在和未来；二是新结构经济学是什么；三是新结构经济学理论将是什么。\n中国经济的过去、现在和未来 #  中国经济的过去、现在和未来是极具代表性的发展中国家的过去、现在和可能的未来。\n过去，中国经济带着和其他发展中经济体的共同共性，寻求可以逐渐发展和现代化的方法。几乎全部的发展中国家一开始选择的是追赶和超过发达国家，一切资源都集中在资本集中型和技术集中型，由政府统一调配。此项政策施行之后，经济发展缓慢，虽然现代化进程有所前进，但是GDP却没有很大的增长。\n经济危机频发后，发达国家主张新自由主义，即鼓吹政府退出干涉，由市场自由调节。于是，又几乎所有的发展中国家直接摒弃之前的政府调配政策，这样的后果是经济危机加剧而发展更加缓慢。 反倒是中国，采用政府调配与市场竞争并行，既有有为政府又有有为市场，反倒是这个开始被大家公认为“两不像”的政策取得了最后的胜利。\n新结构经济学是什么 #  循着这条历史路径，林老师向我们揭开了新结构经济学的序幕。\n新结构经济学，即研究结构的经济学，采用亚当斯密的“原因、本质”的研究方法，探究构成结构的原因与本质，由此构建适合各个国家自己的经济理论。\n新结构经济学的出发点是要素禀赋，由要素禀赋到比较优势，由比较优势决定了产业，以上均围绕最低要素生产成本，并辅之以合适的硬的基础设施和软的制度安排。\n要素禀赋，要素只主要以生产要素为主的一个国家的要素，禀赋指决策者在做决策时考虑的全部东西。决定一个国家发展的因素有很多，但起决定性因素的是要素禀赋，要素禀赋可以简单理解成当一个国家发展经济时，其能够依靠的好与不好的物质因素。\n比较优势，典型的即发展中国家对比发达国家，其特点就是劳动力资源充足，而资本及技术资源劣后，因此，发展中国家的核心优势即是劳动密集型产业。同时，通过从发达国家进口技术与资本，发展中国家能够利用极少的风险和成本，获得产业升级等。而发达国家要进行技术与资本的革新，需要承担极高的成本风险。\n产业，建立于要素禀赋之下。在发展中国家可以分为两类，一类是劳动密集型产业，劳动力成本廉价，会引得市场争相投入，商人有足够的动力，只需要考虑与经济发展方向适合的引导；一类是技术、资本密集型产业，发展国家在该种产业中劣后，动力不足，一旦离开政府的补贴扶持，很容易倾覆，而这一类产业通常是与民生相关的基础产业。\n深入要素禀赋，即是要建立符合各国家自己产业结构的经济发展政策，将各国不同的结构要素考虑在内，而不同于发达国家略去此类因素的二维经济学，是适应各国家的三维经济学。\n新结构经济学将是什么 #  在此基础上，深入对重要结构要素的具体探究，并以中国现在的经济政策作为例子，进一步构建宏观新结构经济理论。\n“这是一个需要理论而且一定能够产生理论的时代，这是一个需要思想而且一定能够产生思想的时代。我们不能辜负了这个时代。”\n经济理论的发展中心往往是世界经济中心，因为经济理论的发展需要素材，而今，发达国家缺的是素材，因为它们的经济已经趋向稳定，大多只是脚注性的研究，而中国经济学家有最新的素材。这是时代赋予我们的使命。\n"},{"id":20,"href":"/docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":"Buttons #  Buttons are styled links that can lead to local page or external link.\nExample #  {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Get Home  Contribute  "},{"id":21,"href":"/docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":"Columns #  Columns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne...  \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt;  # Mid Content Lorem markdownum insigne...  \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt;  # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example #  Left Content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   "},{"id":22,"href":"/docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":"Details #  Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample #  {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title Markdown content #  Lorem markdownum insigne\u0026hellip;   "},{"id":23,"href":"/docs/shortcodes/expand/","title":"Expand","section":"Shortcodes","content":"Expand #  Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample #  Default #  {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Expand ↕  Markdown content #  Lorem markdownum insigne\u0026hellip;    With Custom Label #  {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Custom Label ...  Markdown content #  Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.    "},{"id":24,"href":"/docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":"Hints #  Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example #  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  "},{"id":25,"href":"/docs/shortcodes/katex/","title":"Katex","section":"Shortcodes","content":"KaTeX #  KaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample #  {{\u0026lt; katex [display] [class=\u0026#34;text-center\u0026#34;] \u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt; /katex \u0026gt;}}     Display Mode Example #  Here is some inline example:  \\(\\pi(x)\\)  , rendered in the same line. And below is display example, having display: block  \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\]  Text continues here.\n"},{"id":26,"href":"/docs/shortcodes/mermaid/","title":"Mermaid","section":"Shortcodes","content":"Mermaid Chart #  MermaidJS is library for generating svg charts and diagrams from text.\nOverride Mermaid Initialization Config\nTo override the initialization config for Mermaid, create a mermaid.json file in your assets folder!\n Example #  {{\u0026lt; mermaid [class=\u0026#34;text-center\u0026#34;]\u0026gt;}} stateDiagram-v2  State1: The state with a note  note right of State1  Important information! You can write  notes.  end note  State1 --\u0026gt; State2  note left of State2 : This is the note to the left. {{\u0026lt; /mermaid \u0026gt;}}     "},{"id":27,"href":"/docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":"Section #  Section renders pages in section as definition list, using title and description.\nExample #  {{\u0026lt; section \u0026gt;}}   First Page  First page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.   Second Page  Second Page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.   "},{"id":28,"href":"/docs/shortcodes/section/first-page/","title":"First Page","section":"Section","content":"First page #  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":29,"href":"/docs/shortcodes/section/second-page/","title":"Second Page","section":"Section","content":"Second Page #  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":30,"href":"/docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":"Tabs #  Tabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example #  MacOS MacOS #  This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux Linux #  This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows Windows #  This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n "}]