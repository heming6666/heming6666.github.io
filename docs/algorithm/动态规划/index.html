<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="动态规划 #   确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组  509. 斐波那契数 #  题目地址：https://leetcode-cn.com/problems/fibonacci-number/
解法1：递归
解法2：动态规划，一维数组
解法3：动态规划，状态压缩缩
70. 爬楼梯 #  题目地址：https://leetcode-cn.com/problems/climbing-stairs/
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
746. 使用最小花费爬楼梯 #  题目链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/
数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
62.不同路径 #  题目链接：https://leetcode-cn.com/problems/unique-paths/
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
63. 不同路径 II #  题目链接：https://leetcode-cn."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="动态规划 #   确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组  509. 斐波那契数 #  题目地址：https://leetcode-cn.com/problems/fibonacci-number/
解法1：递归
解法2：动态规划，一维数组
解法3：动态规划，状态压缩缩
70. 爬楼梯 #  题目地址：https://leetcode-cn.com/problems/climbing-stairs/
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
746. 使用最小花费爬楼梯 #  题目链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/
数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
62.不同路径 #  题目链接：https://leetcode-cn.com/problems/unique-paths/
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
63. 不同路径 II #  题目链接：https://leetcode-cn."><meta property="og:type" content="article"><meta property="og:url" content="https://heming6666.github.io/docs/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><meta property="article:section" content="docs"><title>动态规划 | 8898 写字的地方</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.b18103671534b629928bdd3a834c8e4d5cc10bf82debcfeb0f56f3c729b9eb4e.js integrity="sha256-sYEDZxU0timSi906g0yOTVzBC/gt68/rD1bzxym5604=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>8898 写字的地方</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>法类</span><ul><li><span>系统</span><ul><li><a href=/docs/law/system/%E4%BD%95%E4%B8%BA%E5%80%BA/>何为债</a></li><li><a href=/docs/law/system/%E5%95%86%E5%85%A5%E5%85%AC%E5%8F%B8%E6%B3%95/>商入公司法</a></li><li><a href=/docs/law/system/%E5%9B%BD%E9%99%85%E6%8A%95%E8%B5%84%E4%BB%B2%E8%A3%81%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E6%94%B9%E9%9D%A9/>国际投资仲裁的发展与改革</a></li></ul></li><li><span>实务</span><ul><li><a href=/docs/law/practice/%E8%B7%A8%E5%A2%83%E5%B9%B6%E8%B4%AD%E4%BA%A4%E6%98%93%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E5%AE%9E%E6%93%8D%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/>跨境并购交易方案设计实操案例解析</a></li></ul></li></ul></li><li><input type=checkbox id=section-df0032c292233614eb120498739e8356 class=toggle>
<label for=section-df0032c292233614eb120498739e8356 class="flex justify-between"><a role=button>非法类</a></label><ul><li><a href=/docs/other/%E4%B8%80%E7%AF%87%E8%AF%BB%E7%BD%A2%E5%A4%B4%E9%A3%9E%E9%9B%AA%E9%87%8D%E8%AF%BB%E9%A9%AC%E5%85%8B%E6%80%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>《一篇读罢头飞雪，重读马克思》读书笔记</a></li><li><a href=/docs/other/%E8%92%8B%E5%BB%B7%E9%BB%BB%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>蒋廷黻《中国近代史》读书笔记</a></li><li><a href=/docs/other/%E6%9E%97%E6%AF%85%E5%A4%AB%E8%A7%A3%E8%AF%BB%E4%B8%AD%E5%9B%BD%E7%BB%8F%E6%B5%8E%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>林毅夫《解读中国经济》读书笔记</a></li></ul></li><li class=book-section-flat><span>计算机</span><ul><li><input type=checkbox id=section-1ff518ef89fb33a66175c6f5ee4603d4 class=toggle>
<label for=section-1ff518ef89fb33a66175c6f5ee4603d4 class="flex justify-between"><a role=button>Linux 内核设计的艺术</a></label><ul><li><a href=/docs/cs/linux-kernel/%E4%BB%8E%E5%BC%80%E6%9C%BA%E5%88%B0main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C/>从开机 main 函数执行</a></li></ul></li><li><a href=/docs/cs/linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/>Linux 进程调度</a></li><li><a href=/docs/cs/the-clean-coder/>The Clean Coder</a></li><li><input type=checkbox id=section-502ed6acb8574537a63e2babb4b7f460 class=toggle>
<label for=section-502ed6acb8574537a63e2babb4b7f460 class="flex justify-between"><a role=button>开源</a></label><ul><li><input type=checkbox id=section-5a6f45863cb185be208ef662ae3ca1a9 class=toggle>
<label for=section-5a6f45863cb185be208ef662ae3ca1a9 class="flex justify-between"><a href=/docs/cs/open-source/%E6%9D%82%E8%B0%88/>杂谈</a></label><ul><li><a href=/docs/cs/open-source/%E6%9D%82%E8%B0%88/%E5%BC%80%E6%BA%90%E5%A4%A7%E5%AE%B6%E8%B0%88/>开源大家谈</a></li></ul></li></ul></li><li><input type=checkbox id=section-ae26baa9a7dae41463cd502e449389c6 class=toggle>
<label for=section-ae26baa9a7dae41463cd502e449389c6 class="flex justify-between"><a role=button>计算机基础知识</a></label><ul><li><a href=/docs/cs/basic/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/>进程与线程</a></li><li><a href=/docs/cs/basic/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>C++内存管理</a></li><li><a href=/docs/cs/basic/c++%E5%9F%BA%E7%A1%80/>C++基础</a></li><li><a href=/docs/cs/basic/http/>HTTP/HTTPS</a></li><li><a href=/docs/cs/basic/stl/>STL</a></li><li><a href=/docs/cs/basic/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>内存管理</a></li><li><a href=/docs/cs/basic/%E6%AD%BB%E9%94%81/>死锁</a></li><li><a href=/docs/cs/basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络</a></li><li><a href=/docs/cs/basic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></li></ul></li></ul></li><li class=book-section-flat><span>算法</span><ul><li><input type=checkbox id=section-73294e4445b3669a47dedbccf2c73bc4 class=toggle>
<label for=section-73294e4445b3669a47dedbccf2c73bc4 class="flex justify-between"><a href=/docs/algorithm/tree/>二叉树</a></label><ul><li><a href=/docs/algorithm/tree/1/>二叉树 - 子树分解题</a></li><li><a href=/docs/algorithm/tree/3/>二叉树 - 构造题</a></li><li><a href=/docs/algorithm/tree/2/>二叉树 - 遍历题</a></li></ul></li><li><input type=checkbox id=section-148636b2d70f343fb870f163a5972625 class=toggle>
<label for=section-148636b2d70f343fb870f163a5972625 class="flex justify-between"><a role=button>搜索查找算法</a></label><ul><li><a href=/docs/algorithm/search/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/>二分查找</a></li><li><a href=/docs/algorithm/search/bfs/>BFS广度优先搜索</a></li></ul></li><li><a href=/docs/algorithm/lru/>Lru</a></li><li><a href=/docs/algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/>位运算技巧</a></li><li><a href=/docs/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/ class=active>动态规划</a></li><li><a href=/docs/algorithm/%E5%8F%8C%E6%8C%87%E9%92%88/>双指针</a></li><li><a href=/docs/algorithm/%E6%8E%92%E5%BA%8F/>排序</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>动态规划</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#509-斐波那契数>509. 斐波那契数</a></li><li><a href=#70-爬楼梯>70. 爬楼梯</a></li><li><a href=#746-使用最小花费爬楼梯>746. 使用最小花费爬楼梯</a></li><li><a href=#62不同路径>62.不同路径</a></li><li><a href=#63-不同路径-ii>63. 不同路径 II</a></li><li><a href=#343-整数拆分>343. 整数拆分</a></li><li><a href=#494-目标和>494. 目标和</a></li><li><a href=#474一和零>474.一和零</a></li><li><a href=#96不同的二叉搜索树>96.不同的二叉搜索树</a></li></ul></li><li><a href=#子序列问题>子序列问题</a></li><li><a href=#背包问题>背包问题</a><ul><li><a href=#0-1背包问题>0-1背包问题</a></li><li><a href=#子集背包问题>子集背包问题</a></li><li><a href=#完全背包问题>完全背包问题</a></li></ul></li><li><a href=#贪心算法>贪心算法</a></li></ul></nav></aside></header><article class=markdown><h1 id=动态规划>动态规划
<a class=anchor href=#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92>#</a></h1><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h3 id=509-斐波那契数>509. 斐波那契数
<a class=anchor href=#509-%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0>#</a></h3><p>题目地址：https://leetcode-cn.com/problems/fibonacci-number/</p><p>解法1：递归</p><p>解法2：动态规划，一维数组</p><p>解法3：动态规划，状态压缩缩</p><h3 id=70-爬楼梯>70. 爬楼梯
<a class=anchor href=#70-%e7%88%ac%e6%a5%bc%e6%a2%af>#</a></h3><p>题目地址：https://leetcode-cn.com/problems/climbing-stairs/</p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><h3 id=746-使用最小花费爬楼梯>746. 使用最小花费爬楼梯
<a class=anchor href=#746-%e4%bd%bf%e7%94%a8%e6%9c%80%e5%b0%8f%e8%8a%b1%e8%b4%b9%e7%88%ac%e6%a5%bc%e6%a2%af>#</a></h3><p>题目链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/</p><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><h3 id=62不同路径>62.不同路径
<a class=anchor href=#62%e4%b8%8d%e5%90%8c%e8%b7%af%e5%be%84>#</a></h3><p>题目链接：https://leetcode-cn.com/problems/unique-paths/</p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><h3 id=63-不同路径-ii>63. 不同路径 II
<a class=anchor href=#63-%e4%b8%8d%e5%90%8c%e8%b7%af%e5%be%84-ii>#</a></h3><p>题目链接：https://leetcode-cn.com/problems/unique-paths-ii/</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><ul><li>条件：遇到障碍dp[i][j]保持0就可以了。</li></ul><h3 id=343-整数拆分>343. 整数拆分
<a class=anchor href=#343-%e6%95%b4%e6%95%b0%e6%8b%86%e5%88%86>#</a></h3><p>题目链接：https://leetcode-cn.com/problems/integer-break/</p><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><ul><li>dp[i]: 分拆数字i，可以得到的最大乘积为dp[i]。</li><li>dp[i] = max(j * (i-j), j * dp[i-j])</li></ul><h3 id=494-目标和>494. 目标和
<a class=anchor href=#494-%e7%9b%ae%e6%a0%87%e5%92%8c>#</a></h3><p>题目链接：https://leetcode-cn.com/problems/target-sum/</p><p>给定一个非负整数数组，a1, a2, &mldr;, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><h3 id=474一和零>474.一和零
<a class=anchor href=#474%e4%b8%80%e5%92%8c%e9%9b%b6>#</a></h3><p>题目链接：https://leetcode-cn.com/problems/ones-and-zeroes/</p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><h3 id=96不同的二叉搜索树>96.不同的二叉搜索树
<a class=anchor href=#96%e4%b8%8d%e5%90%8c%e7%9a%84%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91>#</a></h3><p>题目链接：https://leetcode-cn.com/problems/unique-binary-search-trees/</p><p>给定一个整数 n，求以 1 &mldr; n 为节点组成的二叉搜索树有多少种？</p><ul><li><p>解法一：递归</p><ul><li>递归函数参数：是一个区间[1,n]</li><li>以 i 为根节点的数量 = [lo, i -1]的数量 * [i+1, hi]的数量</li><li>结束条件：为空！没有元素</li></ul></li><li><p>解法二：动态规划</p><ul><li>dp[i]: 给定i,能组成的不同二叉搜索树的个数</li><li>涉及到累加：需要 j 循环</li><li>dp[i] = 以 j 为头节点，左子树的数量（即dp[j-1]) * 以 j 为头节点，右子树的数量（即dp[i - j])， 即：dp[i] += dp[j-1] * dp[i - j]</li><li>dp[0] = 1的含义：没有元素的时候，也是一种</li></ul></li><li><p>重叠子问题、最优子结构（子问题互相独立）、状态转移方程</p><ul><li>明确「状态」</li><li>定义 dp 数组/函数的含义</li><li>明确「选择」</li><li>明确 base case。</li></ul></li></ul><p>最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。</p><p>动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，不断以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。</p><p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的朋友应该能体会。</p><ol><li><p>遍历的过程中，所需的状态必须是已经计算出来的。看 base case</p></li><li><p>遍历的终点必须是存储结果的那个位置</p></li></ol><h2 id=子序列问题>子序列问题
<a class=anchor href=#%e5%ad%90%e5%ba%8f%e5%88%97%e9%97%ae%e9%a2%98>#</a></h2><ul><li>一维dp数组<ul><li>最长递增子序列<ul><li>dp[i]: 以nums[i]为结尾的最长递增子序列的长度</li><li>算出所有dp[i]后，再选最大的就好了。即两次选择</li><li>有时间看nlgn的解法</li><li>二维递增子序列：信封嵌套问题 - labuladong的算法小抄 (gitbook.io)</li></ul></li><li>最大子序和：具有最大和的连续子数组<ul><li>dp数组：dp[i] = 以nums[i]为结尾的最大子数组和/最长递增子序列</li><li>将dp[i+1]与dp[i]建立联系</li></ul></li></ul></li><li>二维 dp 数组<ul><li>涉及两个字符串/数组<ul><li>最长公共子序列<ul><li>dp函数：dp(s1, i, s2, j)计算s1[i..]和s2[j..]的最长公共子序列长度</li><li>base case: i == s1.length() || j == s2.length() 空串 0</li><li>如果相等/不等几种情况</li><li>备忘录</li><li>变1：给定字符串s1和s2，使它们相同所需最小步数 - m - lcs + n - lcs</li><li>变2：给定字符串s1和s2，使它们相同所需删除字符ascii值最小和<ul><li>修改base case</li><li>修改状态转移部分</li></ul></li></ul></li><li>编辑距离<ul><li>dp函数：返回子的最小编辑距离</li><li>base case: i走完或者j走完，直接返回另一个剩下的长度</li><li>如果相等，左上角。否则，三选1，三个角</li></ul></li><li>最小路径和<ul><li>dp[i][j] 取决于 dp[i-1][j] dp[i][j-1]</li></ul></li></ul></li><li>只涉及一个字符串/数组<ul><li>最长回文子序列的长度<ul><li>分析要求的结果，想：怎么从已知的结果推出来</li><li>dp数组定义：在子串s[i..j]中，最长回文子序列的长度为dp[i][j]</li><li>得出状态转移</li><li>分析base case</li><li>画出dp表，确认遍历方向写for循环</li></ul></li></ul></li></ul></li></ul><h2 id=背包问题>背包问题
<a class=anchor href=#%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98>#</a></h2><h3 id=0-1背包问题>0-1背包问题
<a class=anchor href=#0-1%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98>#</a></h3><ol><li>dp[i][j] : 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</li><li>dp[i] = 不放物品i（dp[i - 1][j]） + 放物品i （dp[i - 1][j - weight[i]]）。即：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</li><li>初始化：dp[0][j] = 0； j &lt; weight[0]时，dp[0][j] = 0，else value[0]</li></ol><p>一维滚动数组解法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dp(bagWeight <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);<span style=color:#75715e>// 初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> weight.size(); i<span style=color:#f92672>++</span>) { <span style=color:#75715e>// 遍历物品
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> bagWeight; j <span style=color:#f92672>&gt;=</span> weight[i]; j<span style=color:#f92672>--</span>) { <span style=color:#75715e>// 遍历背包容量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        dp[j] <span style=color:#f92672>=</span> max(dp[j], dp[j <span style=color:#f92672>-</span> weight[i]] <span style=color:#f92672>+</span> value[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=1049-最后一块石头的重量-ii>1049. 最后一块石头的重量 II
<a class=anchor href=#1049-%e6%9c%80%e5%90%8e%e4%b8%80%e5%9d%97%e7%9f%b3%e5%a4%b4%e7%9a%84%e9%87%8d%e9%87%8f-ii>#</a></h4><p>题目链接：https://leetcode-cn.com/problems/last-stone-weight-ii/</p><p>题目难度：中等</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><ul><li>返回值处理：在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</li></ul><h3 id=子集背包问题>子集背包问题
<a class=anchor href=#%e5%ad%90%e9%9b%86%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98>#</a></h3><ol><li>dp[i][j] : 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，为true则刚好装满</li><li>dp[i] = 不放物品i（dp[i - 1][j] else 放物品i （dp[i - 1][j - weight[i]]）。即：dp[i][j] = if dp[i - 1][j] else dp[i - 1][j - weight[i]] + value[i])</li><li>初始化：dp[&mldr;][0] = false，dp[0][..] = true. ？</li></ol><h3 id=完全背包问题>完全背包问题
<a class=anchor href=#%e5%ae%8c%e5%85%a8%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98>#</a></h3><ul><li>dp数组定义：使用前i种物品，当前背包容量为j，有dp[i][j]种方法可以装满<ul><li>要求的 dp[N][amount]</li><li>base case: dp[0][..] = 0. dp[&mldr;][0] = 1</li></ul></li><li>状态转移逻辑（索引i-1表示第i个物品）<ol><li>不装：dp[i][j] = dp[i-1][j]</li><li>装：dp[i][j] = dp[i][j-coins[i-1]]</li></ol></li></ul><h4 id=518-零钱兑换-ii>518. 零钱兑换 II
<a class=anchor href=#518-%e9%9b%b6%e9%92%b1%e5%85%91%e6%8d%a2-ii>#</a></h4><p>链接：https://leetcode-cn.com/problems/coin-change-2/</p><p>难度：中等</p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><ul><li><p>dp[j]：凑成总金额j的组合数为dp[j]</p></li><li><p>dp[j] += dp[j - coins[i]];</p></li><li><p>初始化：dp[0] = 1</p></li></ul><h2 id=贪心算法>贪心算法
<a class=anchor href=#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95>#</a></h2><p>暴力：指数级</p><p>动态规划：多项式</p><p>贪心：线性</p><ul><li>最多有多少个无重叠区间<ul><li>有空看下动归的解法
状态压缩技巧</li></ul></li><li>本质就是投影 - 用于base case</li><li>直接去掉i维，然后分析对应原来的哪一个。分析外层/内层for循环。本质也是投影</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#509-斐波那契数>509. 斐波那契数</a></li><li><a href=#70-爬楼梯>70. 爬楼梯</a></li><li><a href=#746-使用最小花费爬楼梯>746. 使用最小花费爬楼梯</a></li><li><a href=#62不同路径>62.不同路径</a></li><li><a href=#63-不同路径-ii>63. 不同路径 II</a></li><li><a href=#343-整数拆分>343. 整数拆分</a></li><li><a href=#494-目标和>494. 目标和</a></li><li><a href=#474一和零>474.一和零</a></li><li><a href=#96不同的二叉搜索树>96.不同的二叉搜索树</a></li></ul></li><li><a href=#子序列问题>子序列问题</a></li><li><a href=#背包问题>背包问题</a><ul><li><a href=#0-1背包问题>0-1背包问题</a></li><li><a href=#子集背包问题>子集背包问题</a></li><li><a href=#完全背包问题>完全背包问题</a></li></ul></li><li><a href=#贪心算法>贪心算法</a></li></ul></nav></div></aside></main></body></html>