<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法 on 8898 写字的地方</title><link>https://heming6666.github.io/docs/algorithm/</link><description>Recent content in 算法 on 8898 写字的地方</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://heming6666.github.io/docs/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://heming6666.github.io/docs/algorithm/lru/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/lru/</guid><description>LRU # 要用哈希表 + 双向链表 哈希表：快速查找节点 双向链表 队头：最近访问的，或新加入的 队尾：最久未被访问 题目要求两个方法：
get（） 如果不存在，返回-1 如果存在： 通过key找哈希表，得到节点 moveToHead 将该节点移到队头 返回节点的值 put（） cache.count(key)不存在的话 new新链表节点 加到哈希表 addToHead 添加到头部 size++判断是否超出容量，如果超出： removeTail 删除尾部 删除哈希表cache.erase size&amp;ndash; delete链表节点 否则就是已经存在： cache[key] 拿到节点 更新node-&amp;gt;value为新的值 moveToHead 将该节点移到队头 主要方法：
查找由哈希表负责 插入：要插哈希表，要插链表头,size++ 删除：要删哈希表，要删链表尾，size&amp;ndash; 变更：链表先删再插 注意:
用双向链表，且带伪头节点和伪尾节点 每次要注意是不是要同时操作链表和哈希表</description></item><item><title/><link>https://heming6666.github.io/docs/algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/</guid><description>位运算技巧 # 1、转换操作 # 转小写 (&amp;#39;a&amp;#39; | &amp;#39; &amp;#39;) = &amp;#39;a&amp;#39; (&amp;#39;A&amp;#39; | &amp;#39; &amp;#39;) = &amp;#39;a&amp;#39; 转大写 (&amp;#39;b&amp;#39; &amp;amp; &amp;#39;_&amp;#39;) = &amp;#39;B&amp;#39; (&amp;#39;B&amp;#39; &amp;amp; &amp;#39;_&amp;#39;) = &amp;#39;B&amp;#39; 互换 (&amp;#39;d&amp;#39; ^ &amp;#39; &amp;#39;) = &amp;#39;D&amp;#39; (&amp;#39;D&amp;#39; ^ &amp;#39; &amp;#39;) = &amp;#39;d&amp;#39; 2、正负号一样？ # int x = -1, y = 2; bool f = ((x ^ y) &amp;lt; 0); // true int x = 3, y = 2; bool f = ((x ^ y) &amp;lt; 0); // false 3、n&amp;amp;(n-1) 的应用 # 用于消除n的二进制表示中的最后一个1。</description></item><item><title/><link>https://heming6666.github.io/docs/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>动态规划 # 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 509. 斐波那契数 # 题目地址：https://leetcode-cn.com/problems/fibonacci-number/
解法1：递归
解法2：动态规划，一维数组
解法3：动态规划，状态压缩缩
70. 爬楼梯 # 题目地址：https://leetcode-cn.com/problems/climbing-stairs/
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
746. 使用最小花费爬楼梯 # 题目链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/
数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
62.不同路径 # 题目链接：https://leetcode-cn.com/problems/unique-paths/
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
63. 不同路径 II # 题目链接：https://leetcode-cn.</description></item><item><title/><link>https://heming6666.github.io/docs/algorithm/%E5%8F%8C%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/%E5%8F%8C%E6%8C%87%E9%92%88/</guid><description>双指针 # 1、数组 # 27. 移除元素 # 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
删除数组里的元素，只能覆盖！
fast: 遇到对应元素就略过；遇到最终留下来的，赋值给slow.
slow: 这个坑是填最终要留下来的数的
26. 删除有序数组中的重复项 # 给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
fast与slow. 记得更新 val. 283. 移动零 # 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
fast：遇到0就略过；不是0就往前填 swap slow 977. 有序数组的平方给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 # 平方的最大值就在数组的两端，不是最左边就是最右边。</description></item><item><title/><link>https://heming6666.github.io/docs/algorithm/%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/%E6%8E%92%E5%BA%8F/</guid><description>排序算法 # 快速排序 # 1、快速排序的基本过程？ # 用分治的思想。 选一个基准元素。把比这个元素小的放左边，大的放右边。这时候基准元素所处的即为最终的位置。 递归对左右两边都采取一样的方法，直到没有元素或只有一个元素。 void quickSort(vector&amp;lt;int&amp;gt;&amp;amp; nums, intleft, intright) { if (left &amp;gt;= right) { return; } int index = partition(nums, left, right); quickSort(nums, left, index - 1); quickSort(nums, index + 1, right); } void quickSort(vector&amp;lt;int&amp;gt;&amp;amp; nums) { quickSort(nums, 0, nums.size() - 1); } 2、分割的过程是什么样的？ # 假设 pivot 作为基准元素。 从数组的右端向左扫描找到第一个小于它的元素。 再从数组的左端向右扫描直到找到第一个大于它的元素。 交换这两个元素。 不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，把基准元素和相遇的这个位置交换。</description></item></channel></rss>