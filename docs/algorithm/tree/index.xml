<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>二叉树 on 8898 写字的地方</title><link>https://heming6666.github.io/docs/algorithm/tree/</link><description>Recent content in 二叉树 on 8898 写字的地方</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://heming6666.github.io/docs/algorithm/tree/index.xml" rel="self" type="application/rss+xml"/><item><title>二叉树 - 子树分解题</title><link>https://heming6666.github.io/docs/algorithm/tree/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/tree/1/</guid><description>二叉树 - 子树分解题 # 基础 # https://leetcode-cn.com/problems/diameter-of-binary-tree/ https://leetcode-cn.com/problems/invert-binary-tree/submissions/ https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/ 构造题 # https://leetcode-cn.com/problems/maximum-binary-tree/</description></item><item><title>二叉树 - 构造题</title><link>https://heming6666.github.io/docs/algorithm/tree/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/tree/3/</guid><description>二叉树 - 构造题 # https://leetcode-cn.com/problems/maximum-binary-tree/ https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</description></item><item><title>二叉树 - 遍历题</title><link>https://heming6666.github.io/docs/algorithm/tree/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/tree/2/</guid><description>二叉树 - 遍历题 # https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</description></item><item><title>二叉搜索树</title><link>https://heming6666.github.io/docs/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>二叉搜索树 # 一、基本操作 # 1、合法性 # 98. 验证二叉搜索树
当前节点的值必须大于左子树所有的值（即左子树的最大值） 借助辅助函数，传递信息/约束 Expand ↕ class Solution { public: bool isValidBST(TreeNode* root) { return isValidBST(root, nullptr, nullptr); } bool isValidBST(TreeNode* root, TreeNode* leftMax, TreeNode* rightMin) { if (root == nullptr) return true; // 当前节点的值必须大于左子树所有的值（即左子树的最大值） if (leftMax != nullptr &amp;amp;&amp;amp; root-&amp;gt;val &amp;lt;= leftMax-&amp;gt;val) return false; // 必须小于右子树所有的值（即右子树的最小值） if (rightMin !</description></item></channel></rss>