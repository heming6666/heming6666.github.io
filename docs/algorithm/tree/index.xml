<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>二叉树 on 8898 写字的地方</title><link>https://heming6666.github.io/docs/algorithm/tree/</link><description>Recent content in 二叉树 on 8898 写字的地方</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://heming6666.github.io/docs/algorithm/tree/index.xml" rel="self" type="application/rss+xml"/><item><title>二叉树 - 子树分解题</title><link>https://heming6666.github.io/docs/algorithm/tree/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/tree/1/</guid><description>二叉树 - 子树分解题 # 基础 # https://leetcode-cn.com/problems/diameter-of-binary-tree/ https://leetcode-cn.com/problems/invert-binary-tree/submissions/ https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/ 构造题 # https://leetcode-cn.com/problems/maximum-binary-tree/</description></item><item><title>二叉树 - 构造题</title><link>https://heming6666.github.io/docs/algorithm/tree/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/tree/3/</guid><description>二叉树 - 构造题 # https://leetcode-cn.com/problems/maximum-binary-tree/ https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</description></item><item><title>二叉树 - 遍历题</title><link>https://heming6666.github.io/docs/algorithm/tree/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/tree/2/</guid><description>二叉树 - 遍历题 # https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</description></item><item><title>二叉搜索树</title><link>https://heming6666.github.io/docs/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/algorithm/tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>二叉搜索树 # 230. 二叉搜索树中第K小的元素
直观的：
二叉搜索树，所以中序遍历就是升序的； 所以中序遍历，记录当前遍历到第几个，和 k 比较。 Expand ↕ class Solution { public: int kthSmallest(TreeNode* root, int k) { traverse(root, k); return res; } private: int res = 0; int rank = 0; void traverse(TreeNode *root, int k) { if (root == nullptr) return; traverse(root-&amp;gt;left, k); rank++; if (k == rank) { res = root-&amp;gt;val; return; } traverse(root-&amp;gt;right, k); } }; 优化：</description></item></channel></rss>