<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux 内核设计的艺术 on 8898 写字的地方</title><link>https://heming6666.github.io/docs/cs/linux-kernel/</link><description>Recent content in Linux 内核设计的艺术 on 8898 写字的地方</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://heming6666.github.io/docs/cs/linux-kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>从开机 main 函数执行</title><link>https://heming6666.github.io/docs/cs/linux-kernel/%E4%BB%8E%E5%BC%80%E6%9C%BA%E5%88%B0main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/linux-kernel/%E4%BB%8E%E5%BC%80%E6%9C%BA%E5%88%B0main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C/</guid><description>Linux 从开机到加电执行 main 函数之前的过程 # mermaid.initialize({ "flowchart": { "useMaxWidth":true }, "theme": "default" } ) flowchart LR bootsect[执行 bootsect]-- setup[执行 setup]-- head[执行 head.s]-- main[main 函数] 1.1 启动 BIOS，准备中断向量表和中断服务程序 # 加电时，内存 RAM 是空的 BIOS 负责把操作系统内核程序加载到内存中 具体过程：
靠硬件完成，将 CPU 的硬件逻辑设计为加电瞬间 CS:IP 指向 0xFFFF0, 即 BIOS 程序入口地址。 BIOS 在内存中建立中断向量表和中断服务程序。利用中断，才能加载内核程序。 1.2 加载内核程序 # 产生 int 0x19 中断，找到并加载启动扇区，从而 bootsecct 程序被拷贝到内存。 BIOS 负责找到并加载第一扇区，与具体的Linux内核无关，即两头约定 + 定位识别。 bootsecct 程序复制自身到另一个地方，并调整CS:IP、DS(数据段寄存器)、ES(附加段寄存器)、SS(栈基址寄存器)+SP(栈顶指针).</description></item></channel></rss>