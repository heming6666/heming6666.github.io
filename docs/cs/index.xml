<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>计算机 on 8898 写字的地方</title><link>https://heming6666.github.io/docs/cs/</link><description>Recent content in 计算机 on 8898 写字的地方</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://heming6666.github.io/docs/cs/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 进程调度</title><link>https://heming6666.github.io/docs/cs/linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid><description>Linux 进程调度 # 前言 # 在计算机科学中，调度就是一种将任务（Work）分配给资源的方法。任务可能是虚拟的计算任务，例如线程、进程或者数据流，这些任务会被调度到硬件资源上执行，例如：处理器 CPU 等设备。调度器或调度算法的设计与实现最终都会归结到一个问题上，即如何对有限的资源进行分配以实现资源利用率的最大化并满足特定的需求。
调度器是操作系统中的重要组件，操作系统中有进程调度器（Process Scheduler）、网络调度器（Network Scheduler）和 I/O 调度器（I/O Scheduler）等组件，本文介绍的是进程调度器。
进程调度器负责给系统中的所有进程分配有限的 CPU 时间资源。只有通过合理的调度算法，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。
进程调度算法总是追求达到以下目标：
公平：保证每个进程得到合理的 CPU 时间，避免进程的饥饿现象。 高效：尽量充分使用 CPU，使 CPU 保持忙碌状态。 快速的响应时间：使交互用户的响应时间应尽可能短。 周转时间：使批处理用户等待输出的时间尽可能短。 吞吐量：单位时间内处理的进程数量尽可能多。 但是很显然，这几个目标是相互冲突的，不可能同时达到。因此只能在这几个方面进行取舍，从而确定自己的调度算法。
进程调度器将进程分为三类：
交互式进程(Interactive process)：这些进程经常与用户进行交互，因此进程不断地处于睡眠状态，等待用户输入。典型的应用比如命令行 shell、文本编辑程序。此类进程对系统响应时间要求比较高，否则用户会感觉系统反应迟缓。
批处理进程(Batch process)：这些进程一般在后台运行，不必与用户交互，需要占用大量的系统资源。但是能够忍受响应延迟。典型的批处理程序如编译程序、数据库搜索引擎等。
实时进程(Real-time process)：这些进程对调度延迟的要求最高，往往执行非常重要的操作，要求立即响应并执行。典型的实时程序比如视频播放软件、或飞机飞行控制系统，很明显这类程序不能容忍长时间的调度延迟。
根据进程的不同分类 Linux 采用不同的调度策略。
对于实时进程，采用 FIFO 或者 Round Robin 的调度策略。
对于普通进程，则需要区分交互式和批处理式的不同。传统 Linux 调度器提高交互式应用的优先级，使得它们能更快地被调度。而 CFS 和 RSDL 等新的调度器的核心思想是“完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持。
以下列出了 Linux 不同版本调度器的历史：
初始调度器 · v0.</description></item><item><title>The Clean Coder</title><link>https://heming6666.github.io/docs/cs/the-clean-coder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/the-clean-coder/</guid><description>《The Clean Coder》 阅读记录 # 术道结合，这本书不教术，更多的传道。尽管是只可意会的道，依然可以通过娓娓道来的叙述与提炼，使读者联系自身经历，揣摩体悟，习得自己心中的哈姆莱特，纳为己用。
0、关于职业素养 # 如何体现职业素养？
从自身出发，回答一个问题：在过去的工作中，遇到过哪些印象深刻的困难，最后是怎么解决的？ 问题不在于问题的难度，而在于反思的程度：怎么分析问题、查阅什么资料、采取解决问题的方式步骤、采取什么措施避免和改进。
从外部出发，是否对外展示了专业精神获得外部人员的信任？是否需要对你进行微观管理才能令人放心？
总结起来，职业素养 = 能力（技术） + 素质（价值观、原则、态度）+ 持续的积累和养成。
关于价值观，可阅读前言部分 “挑战者”号航天飞机工程师的故事。 13、团队与项目 # 有凝聚力的团队：团队组建、克服差异（一起搞定一切）、多个项目中整体移动 给足时间，成为引擎，军团 14、辅导、学徒期与职业素养 # 导师很重要，可以更好、更加顺利地跨过一些坎。 可以有多种形式的辅导。 软件学徒期是必要的，类比医学生（人命关天） 职业素养：能力（技术）和素质（价值观、原则、态度），以及持续的积累和养成。 非理性决策，非感情用事，只要能被人观察到，便具有传染性：成为表率，向人展示即可。 15、工具 # 使用工具，不再是思考下一步要键入什么字符或代码，而是思考接下来要对代码进行什么样的变换。</description></item></channel></rss>