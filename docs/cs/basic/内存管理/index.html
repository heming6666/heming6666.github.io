<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="内存管理 #  一、虚拟内存思想 #  我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套虚拟地址，人人都有，大家自己玩自己的地址就行，互不干涉。虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了（MMU）。
二、内存分段 #  1、机制 #  虚拟地址和物理地址之间通过段表（段基地址+段大小）来映射。
分段机制会把程序的虚拟地址分成 4 个段：代码分段、数据分段、堆段、栈段。
2、不足 #  内存碎片问题（不连续的小物理内存，浪费） -> 并因此有内存交换的效率低的问题。
三、内存分页 #  1、分页机制 #  分页是把整个虚拟和物理内存空间切分成一页一页，固定尺寸，Linux下一页是4KB。
虚拟地址与物理地址之间通过页表来映射。
2、多级页表 #  页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项。（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。
3、缺页异常 #  而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。
 最近最久未使用 LRU 先进先出 第二次机会算法  4、快表 #  局部性原理。
 根据逻辑地址，得到页号+页内偏移，去快表里面，看是否命中。 如果命中，取出对应的内存块号，和页内偏移拼接得到物理地址。即：只需一次访存。 如果没命中，访问内存中的页表，找到对应表项，最后得到物理地址，访问内存。即：两次访存。同时，还要存入快表，如果满了，就进行替换。  5、好处和优点 #   解决了内存碎片问题 交换效率也更高 不需要一次性全部加载到物理内存  四、段页式内存管理 #    先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="内存管理"><meta property="og:description" content="内存管理 #  一、虚拟内存思想 #  我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套虚拟地址，人人都有，大家自己玩自己的地址就行，互不干涉。虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了（MMU）。
二、内存分段 #  1、机制 #  虚拟地址和物理地址之间通过段表（段基地址+段大小）来映射。
分段机制会把程序的虚拟地址分成 4 个段：代码分段、数据分段、堆段、栈段。
2、不足 #  内存碎片问题（不连续的小物理内存，浪费） -> 并因此有内存交换的效率低的问题。
三、内存分页 #  1、分页机制 #  分页是把整个虚拟和物理内存空间切分成一页一页，固定尺寸，Linux下一页是4KB。
虚拟地址与物理地址之间通过页表来映射。
2、多级页表 #  页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项。（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。
3、缺页异常 #  而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。
 最近最久未使用 LRU 先进先出 第二次机会算法  4、快表 #  局部性原理。
 根据逻辑地址，得到页号+页内偏移，去快表里面，看是否命中。 如果命中，取出对应的内存块号，和页内偏移拼接得到物理地址。即：只需一次访存。 如果没命中，访问内存中的页表，找到对应表项，最后得到物理地址，访问内存。即：两次访存。同时，还要存入快表，如果满了，就进行替换。  5、好处和优点 #   解决了内存碎片问题 交换效率也更高 不需要一次性全部加载到物理内存  四、段页式内存管理 #    先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；"><meta property="og:type" content="article"><meta property="og:url" content="https://heming6666.github.io/docs/cs/basic/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><meta property="article:section" content="docs"><title>内存管理 | 8898 写字的地方</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.74221c09f7473c52529074947b2169fadc81c30ebb73c43e480e90a0b075e9b9.js integrity="sha256-dCIcCfdHPFJSkHSUeyFp+tyBww67c8Q+SA6QoLB16bk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>8898 写字的地方</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>法类</span><ul><li><span>系统</span><ul><li><a href=/docs/law/system/%E4%BD%95%E4%B8%BA%E5%80%BA/>何为债</a></li><li><a href=/docs/law/system/%E5%95%86%E5%85%A5%E5%85%AC%E5%8F%B8%E6%B3%95/>商入公司法</a></li><li><a href=/docs/law/system/%E5%9B%BD%E9%99%85%E6%8A%95%E8%B5%84%E4%BB%B2%E8%A3%81%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E6%94%B9%E9%9D%A9/>国际投资仲裁的发展与改革</a></li><li><a href=/docs/law/system/%E4%BB%A5%E5%85%AC%E5%8F%B8%E6%8B%85%E4%BF%9D%E4%B8%BA%E4%BE%8B/>以公司担保为例</a></li></ul></li><li><span>实务</span><ul><li><a href=/docs/law/practice/%E8%B7%A8%E5%A2%83%E5%B9%B6%E8%B4%AD%E4%BA%A4%E6%98%93%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E5%AE%9E%E6%93%8D%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/>跨境并购交易方案设计实操案例解析</a></li></ul></li></ul></li><li><input type=checkbox id=section-df0032c292233614eb120498739e8356 class=toggle>
<label for=section-df0032c292233614eb120498739e8356 class="flex justify-between"><a role=button>非法类</a></label><ul><li><a href=/docs/other/%E4%B8%AD%E5%9B%BD%E6%94%BF%E5%BA%9C%E4%B8%8E%E7%BB%8F%E6%B5%8E%E5%8F%91%E5%B1%95%E5%85%B0%E5%B0%8F%E6%AC%A2/>《中国政府与经济发展》</a></li><li><a href=/docs/other/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E8%92%8B%E5%BB%B7%E9%BB%BB/>《中国近代史》</a></li><li><a href=/docs/other/%E8%A7%A3%E8%AF%BB%E4%B8%AD%E5%9B%BD%E7%BB%8F%E6%B5%8E%E6%9E%97%E6%AF%85%E5%A4%AB/>《解读中国经济》</a></li><li><a href=/docs/other/%E9%87%8D%E8%AF%BB%E9%A9%AC%E5%85%8B%E6%80%9D%E9%9F%A9%E6%AF%93%E6%B5%B7/>《重读马克思》</a></li></ul></li><li class=book-section-flat><span>计算机</span><ul><li><input type=checkbox id=section-1ff518ef89fb33a66175c6f5ee4603d4 class=toggle>
<label for=section-1ff518ef89fb33a66175c6f5ee4603d4 class="flex justify-between"><a role=button>Linux 内核设计的艺术</a></label><ul><li><a href=/docs/cs/linux-kernel/%E4%BB%8E%E5%BC%80%E6%9C%BA%E5%88%B0main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C/>从开机 main 函数执行</a></li></ul></li><li><a href=/docs/cs/linux-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/>Linux 进程调度</a></li><li><a href=/docs/cs/the-clean-coder/>The Clean Coder</a></li><li><input type=checkbox id=section-502ed6acb8574537a63e2babb4b7f460 class=toggle>
<label for=section-502ed6acb8574537a63e2babb4b7f460 class="flex justify-between"><a role=button>开源</a></label><ul><li><input type=checkbox id=section-5a6f45863cb185be208ef662ae3ca1a9 class=toggle>
<label for=section-5a6f45863cb185be208ef662ae3ca1a9 class="flex justify-between"><a href=/docs/cs/open-source/%E6%9D%82%E8%B0%88/>杂谈</a></label><ul><li><a href=/docs/cs/open-source/%E6%9D%82%E8%B0%88/%E5%BC%80%E6%BA%90%E5%A4%A7%E5%AE%B6%E8%B0%88/>开源大家谈</a></li></ul></li></ul></li><li><input type=checkbox id=section-ae26baa9a7dae41463cd502e449389c6 class=toggle checked>
<label for=section-ae26baa9a7dae41463cd502e449389c6 class="flex justify-between"><a role=button>计算机基础知识</a></label><ul><li><a href=/docs/cs/basic/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/>进程与线程</a></li><li><a href=/docs/cs/basic/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>C++内存管理</a></li><li><a href=/docs/cs/basic/c++%E5%9F%BA%E7%A1%80/>C++基础</a></li><li><a href=/docs/cs/basic/http/>HTTP/HTTPS</a></li><li><a href=/docs/cs/basic/stl/>STL</a></li><li><a href=/docs/cs/basic/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ class=active>内存管理</a></li><li><a href=/docs/cs/basic/%E6%AD%BB%E9%94%81/>死锁</a></li><li><a href=/docs/cs/basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络</a></li><li><a href=/docs/cs/basic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></li></ul></li></ul></li><li class=book-section-flat><span>算法</span><ul><li><input type=checkbox id=section-73294e4445b3669a47dedbccf2c73bc4 class=toggle>
<label for=section-73294e4445b3669a47dedbccf2c73bc4 class="flex justify-between"><a href=/docs/algorithm/tree/>二叉树</a></label><ul><li><a href=/docs/algorithm/tree/1/>二叉树 - 子树分解题</a></li><li><a href=/docs/algorithm/tree/3/>二叉树 - 构造题</a></li><li><a href=/docs/algorithm/tree/2/>二叉树 - 遍历题</a></li></ul></li><li><input type=checkbox id=section-148636b2d70f343fb870f163a5972625 class=toggle>
<label for=section-148636b2d70f343fb870f163a5972625 class="flex justify-between"><a role=button>搜索查找算法</a></label><ul><li><a href=/docs/algorithm/search/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/>二分查找</a></li><li><a href=/docs/algorithm/search/bfs/>BFS广度优先搜索</a></li></ul></li><li><a href=/docs/algorithm/lru/>Lru</a></li><li><a href=/docs/algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/>位运算技巧</a></li><li><a href=/docs/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/>动态规划</a></li><li><a href=/docs/algorithm/%E5%8F%8C%E6%8C%87%E9%92%88/>双指针</a></li><li><a href=/docs/algorithm/%E6%8E%92%E5%BA%8F/>排序</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>内存管理</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#一虚拟内存思想>一、虚拟内存思想</a></li><li><a href=#二内存分段>二、内存分段</a><ul><li><a href=#1机制>1、机制</a></li><li><a href=#2不足>2、不足</a></li></ul></li><li><a href=#三内存分页>三、内存分页</a><ul><li><a href=#1分页机制>1、分页机制</a></li><li><a href=#2多级页表>2、多级页表</a></li><li><a href=#3缺页异常>3、缺页异常</a></li><li><a href=#4快表>4、快表</a></li><li><a href=#5好处和优点>5、好处和优点</a></li></ul></li><li><a href=#四段页式内存管理>四、段页式内存管理</a><ul><li><a href=#五linux-内存管理>五、Linux 内存管理</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=内存管理>内存管理
<a class=anchor href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86>#</a></h1><h2 id=一虚拟内存思想>一、虚拟内存思想
<a class=anchor href=#%e4%b8%80%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e6%80%9d%e6%83%b3>#</a></h2><p>我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套虚拟地址，人人都有，大家自己玩自己的地址就行，互不干涉。虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了（MMU）。</p><h2 id=二内存分段>二、内存分段
<a class=anchor href=#%e4%ba%8c%e5%86%85%e5%ad%98%e5%88%86%e6%ae%b5>#</a></h2><h3 id=1机制>1、机制
<a class=anchor href=#1%e6%9c%ba%e5%88%b6>#</a></h3><p>虚拟地址和物理地址之间通过段表（段基地址+段大小）来映射。</p><p>分段机制会把程序的虚拟地址分成 4 个段：代码分段、数据分段、堆段、栈段。</p><p><img src=/images/neicunfenduan.png alt=1></p><h3 id=2不足>2、不足
<a class=anchor href=#2%e4%b8%8d%e8%b6%b3>#</a></h3><p>内存碎片问题（不连续的小物理内存，浪费） -> 并因此有内存交换的效率低的问题。</p><h2 id=三内存分页>三、内存分页
<a class=anchor href=#%e4%b8%89%e5%86%85%e5%ad%98%e5%88%86%e9%a1%b5>#</a></h2><h3 id=1分页机制>1、分页机制
<a class=anchor href=#1%e5%88%86%e9%a1%b5%e6%9c%ba%e5%88%b6>#</a></h3><p>分页是把整个虚拟和物理内存空间切分成一页一页，固定尺寸，Linux下一页是4KB。</p><p>虚拟地址与物理地址之间通过页表来映射。</p><h3 id=2多级页表>2、多级页表
<a class=anchor href=#2%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8>#</a></h3><p>页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项。（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p><p><img src=/images/duojiyebiao.png alt=2></p><h3 id=3缺页异常>3、缺页异常
<a class=anchor href=#3%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8>#</a></h3><p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><ul><li>最近最久未使用 LRU</li><li>先进先出</li><li>第二次机会算法</li></ul><h3 id=4快表>4、快表
<a class=anchor href=#4%e5%bf%ab%e8%a1%a8>#</a></h3><p>局部性原理。</p><ol><li>根据逻辑地址，得到页号+页内偏移，去快表里面，看是否命中。</li><li>如果命中，取出对应的内存块号，和页内偏移拼接得到物理地址。即：只需一次访存。</li><li>如果没命中，访问内存中的页表，找到对应表项，最后得到物理地址，访问内存。即：两次访存。同时，还要存入快表，如果满了，就进行替换。</li></ol><h3 id=5好处和优点>5、好处和优点
<a class=anchor href=#5%e5%a5%bd%e5%a4%84%e5%92%8c%e4%bc%98%e7%82%b9>#</a></h3><ul><li>解决了内存碎片问题</li><li>交换效率也更高</li><li>不需要一次性全部加载到物理内存</li></ul><h2 id=四段页式内存管理>四、段页式内存管理
<a class=anchor href=#%e5%9b%9b%e6%ae%b5%e9%a1%b5%e5%bc%8f%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86>#</a></h2><ul><li><p>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</p></li><li><p>接着再把每个段划分为多个页。</p></li></ul><p>这样，地址结构就由段号、段内页号和页内位移三部分组成。</p><p>段页式地址变换中要得到物理地址须经过三次内存访问：</p><ul><li><p>第一次访问段表，得到页表起始地址；</p></li><li><p>第二次访问页表，得到物理页号；</p></li><li><p>第三次将物理页号与页内位移组合，得到物理地址。</p></li></ul><h3 id=五linux-内存管理>五、Linux 内存管理
<a class=anchor href=#%e4%ba%94linux-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86>#</a></h3><p>内核空间 和 用户空间两部分：</p><p><img src=/images/xunineicunkongjian.png alt=4></p><p>虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。且所有段的起始地址都一样。（共享和保护）</p><p>通过这张图你可以看到，用户空间内存，从低到高分别是 7 种不同的内存段：</p><ul><li><p>程序文件段，包括二进制可执行代码；</p></li><li><p>已初始化数据段，包括静态常量；</p></li><li><p>未初始化数据段，包括未初始化的静态变量；</p></li><li><p>堆段，包括动态分配的内存，从低地址开始向上增长；</p></li><li><p>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</p></li><li><p>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；</p></li></ul><p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 malloc() 或者 mmap() ，就可以分别在堆和文件映射段动态分配内存。</p><p><img src=/images/neicunguanlizongjie.png alt=5></p><ul><li>比较<ul><li>对程序员的透明姓</li><li>地址空间的维度</li><li>大小是否可改变</li><li>作用：虚拟内存更大空间；逻辑独立共享保护</li></ul></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#一虚拟内存思想>一、虚拟内存思想</a></li><li><a href=#二内存分段>二、内存分段</a><ul><li><a href=#1机制>1、机制</a></li><li><a href=#2不足>2、不足</a></li></ul></li><li><a href=#三内存分页>三、内存分页</a><ul><li><a href=#1分页机制>1、分页机制</a></li><li><a href=#2多级页表>2、多级页表</a></li><li><a href=#3缺页异常>3、缺页异常</a></li><li><a href=#4快表>4、快表</a></li><li><a href=#5好处和优点>5、好处和优点</a></li></ul></li><li><a href=#四段页式内存管理>四、段页式内存管理</a><ul><li><a href=#五linux-内存管理>五、Linux 内存管理</a></li></ul></li></ul></nav></div></aside></main></body></html>