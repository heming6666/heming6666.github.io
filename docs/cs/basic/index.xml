<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>计算机基础知识 on 8898 写字的地方</title><link>https://heming6666.github.io/docs/cs/basic/</link><description>Recent content in 计算机基础知识 on 8898 写字的地方</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://heming6666.github.io/docs/cs/basic/index.xml" rel="self" type="application/rss+xml"/><item><title>进程与线程</title><link>https://heming6666.github.io/docs/cs/basic/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid><description>进程和线程 # 进程 # No.1、线程和进程的区别 # 可以从1、概念，2、所拥有的资源，3、开销 三个方面考虑。
从概念上来说，进程是资源分配的基本单位，线程是 CPU 调度的基本单位； 从资源的角度来讲， 一个进程可以有多个线程，线程间可以共享该进程的资源。比如说，进程有自己的独立地址空间，而这一个进程内的线程是共享这一份相同的地址空间的。这就意味着线程切换快，因为不需要切换页表。但同时，要是有一个线程挂掉了，整个进程也会挂掉。相比较之下，进程之间就不会有这种影响，也就是会比较健壮。 当然，除了共享的资源以外，线程也会有私有的一些资源，比如寄存器和栈。 从开销的角度来讲： 我们使用线程的时候，一方面是想要提高它的并发性，可以用多个线程去执行一个进程的不同部分，这样能充分发挥多CPU的功能。 另一方面是可以减少开销，比如 线程的创建时间比进程快，因为进程在创建的过程中，还需要分配内存、文件管理信息，而线程直接共享就可以了； 线程的终止会比进程快，同样的道理，它需要释放的资源会比较少； 线程切换快，因为同一个进程里面的线程都具有同一个页表，在切换的时候就不需要切换页表。 通信问题。线程因为会共享一些全局变量、静态变量等数据，因此线程间通信会方便一些，但也会带来同步和互斥的问题。进程间要通信就需要借助IPC。 共享的有：堆、全局变量、静态变量、指针，引用、文件 线程私有的有栈、寄存器等。 1. 概念:进程是操作系统资源分配的基本单位。 # 进程就是运行起来的可执行程序。我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个运行中的程序，就被称为「进程」。
2. 进程的状态：运行态、就绪态、阻塞态 # 运行状态：该进程正在 CPU上跑； 就绪状态：已经就绪，可运行，但还没有占有CPU，比如时间片用完了； 阻塞状态：该进程暂停运行，等待某一事件发生（比如等待键盘输入），即使给它CPU控制权，它也无法运行；如果完成了，就变成就绪态。 还有：创建状态、结束状态、挂起状态（表示进程没有占有内存空间，在硬盘上） 3. 进程的控制结构PCB # 是一个结构体，用来描述进程。也是进程存在的唯一标识。多个进程的PCCB通过链表的方式连接在一起。 包括：
进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程当前状态、进程优先级 CPU 相关信息：CPU 中各个寄存器的值 资源：内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。 4.</description></item><item><title>C++内存管理</title><link>https://heming6666.github.io/docs/cs/basic/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/c++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>C++内存管理 # 1、new/delete 和 malloc/free 有什么区别？ # new 的步骤分两步：调用 malloc 申请空间、调用构造函数。释放空间的时候一样。 new 不需要头文件， malloc 要 stdlib.h new 是类型安全的，比如 int *p = new float[2]就会报错；malloc 不是，编译时可以通过。 2、malloc和free的原理 # 2.1 进程的地址空间 # 3 - 4G 内核空间 0 - 3G 用户空间 栈（↓)：局部变量、函数参数、返回地址 内存映射段（↓）：动态库/匿名映射 堆（↑）： BSS段：未初始化/初始为0的.. 数据段：初始化的全局变量和局部静态变量 代码段：可执行二进制代码 2.2 进程控制块里的mm_struct # start_brk：堆的起始地址 brk：终止地址 可以增大brk的值，但需要系统调用 2.3 malloc 实现方案 # 系统调用开销 + 内存碎片 =&amp;gt; 采用内存池。</description></item><item><title>C++基础</title><link>https://heming6666.github.io/docs/cs/basic/c++%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/c++%E5%9F%BA%E7%A1%80/</guid><description>C++ 基础 # 一、基本语法 # 1、指针和引用有什么区别？ # 指针有自己的空间，引用只是别名 sizeof(指针) = 4；sizeof(引用) = 对象的大小 指针可以指向其他对象，引用不行。 2、const 的作用是什么？ # 作用：（在 const 后面）的值不可改变。
变量； 指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 成员函数，说明该成员函数内不能修改成员变量。 3、const 和 volatile 一起修饰变量？ # 表示变量是不可改变的，并且编译器不会优化这个变量。
4、static 的作用是什么？ # 普通变量：修改存储区域（静态区）、生命周期（main运行前分配空间），初始值 普通函数：作用范围。仅在定义该函数的文件内才能使用。多人开发场景，为了防止与他人命名空间里的函数重名，可以将函数定义为 static。 成员变量：不需要实例化对象就能访问。多个对象只一份 成员函数：同。但不能访问非静态成员 5、Lambda 表达式 # sort(vec.begin(), vec.end(), [](int a, int b) -&amp;gt; bool { return a &amp;lt; b })</description></item><item><title>HTTP/HTTPS</title><link>https://heming6666.github.io/docs/cs/basic/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/http/</guid><description>HTTP/HTTPS # 一、状态码 # 1、有哪些常见的状态码？ # 1xx - 正在处理 100 - 正常 101 - 切换请求协议 2- 成功 200 - 请求成功 201 - 已创建 202 - 已接受 204 - 无内容 3- 重定向 301 - 永久性重定向 302 - 临时重定向 4- 服务端无法处理请求（客户端错误 400 - Bad Request 语法错误 401 - Unauthorized 403 - Forbidden 拒绝 404 - not found 405 - method not allowd 406 - Not Acceptable 408 - Request Time-out 5- 服务端处理请求出错（服务端错误 500 - Internal Server Error 内部错误 501 - Not Implemented 502 - Bad Gateway 服务器无效响无效响应 503 - 服务器过载，稍后重试 504 - Gateway Timeout 请求超时，nginx 配置不对 2、301和302的区别是什么？ # 301是页面或资源永久性地移到了另一个位置。应用场景：网站移到了新的地址 / 或多个域名跳转到同一个域名，有利于URL权重的集中。 302是暂时性转移，常被用作网址劫持，搜索引擎会抓新的内容，但保存旧的网址。 二、HTTP 报文 # http请求报文</description></item><item><title>STL</title><link>https://heming6666.github.io/docs/cs/basic/stl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/stl/</guid><description>STL # 零、STL总体 # 1、STL包含什么？ # 容器 迭代器：不暴露容器内部结构，对容器遍历。 算法：排序等常用算法。 2、常用的STL/容器？ # 顺序容器 array - 固定大小 vector - 动态数组 list - 双向链表 forward_list - 单向链表 deque - 双端队列 关联型 map、multimap、unordered_map、unordered_multimap set、multiset、unordered_set、unordered_multiset 容器适配器 stack - 栈 queue - 队列 priority_queue - 优先队列 3、容器内部怎么删除一个元素？ # 顺序型：it = erase(it) 返回下一个有效的it 关联型：erase(it++) 返回 void 一、vector # 1、底层原理是什么？ # 是一个动态数组，装不下的时候-&amp;gt;自动申请一片更大地空间，VS 下 1.</description></item><item><title>内存管理</title><link>https://heming6666.github.io/docs/cs/basic/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid><description>内存管理 # 一、虚拟内存思想 # 我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套虚拟地址，人人都有，大家自己玩自己的地址就行，互不干涉。虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了（MMU）。
二、内存分段 # 1、机制 # 虚拟地址和物理地址之间通过段表（段基地址+段大小）来映射。
分段机制会把程序的虚拟地址分成 4 个段：代码分段、数据分段、堆段、栈段。
2、不足 # 内存碎片问题（不连续的小物理内存，浪费） -&amp;gt; 并因此有内存交换的效率低的问题。
三、内存分页 # 1、分页机制 # 分页是把整个虚拟和物理内存空间切分成一页一页，固定尺寸，Linux下一页是4KB。
虚拟地址与物理地址之间通过页表来映射。
2、多级页表 # 页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项。（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。
3、缺页异常 # 而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。
最近最久未使用 LRU 先进先出 第二次机会算法 4、快表 # 局部性原理。
根据逻辑地址，得到页号+页内偏移，去快表里面，看是否命中。 如果命中，取出对应的内存块号，和页内偏移拼接得到物理地址。即：只需一次访存。 如果没命中，访问内存中的页表，找到对应表项，最后得到物理地址，访问内存。即：两次访存。同时，还要存入快表，如果满了，就进行替换。 5、好处和优点 # 解决了内存碎片问题 交换效率也更高 不需要一次性全部加载到物理内存 四、段页式内存管理 # 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</description></item><item><title>死锁</title><link>https://heming6666.github.io/docs/cs/basic/%E6%AD%BB%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/%E6%AD%BB%E9%94%81/</guid><description>死锁 # 1、死锁怎么产生的？ # 两个或者多个进程相互等待对方资源，导致死锁。比如：
系统资源不足 资源分配不合理 进程运行推进顺序不合理 2、必要条件 ？&amp;mdash;&amp;gt; 预防方法？ # 一般来说，发生死锁有四个必要条件：
互斥：资源要么已经分配给了一个进程，要么就是可用的。&amp;ndash; A唯一拥有B 占有和等待：已经得到了某个资源的进程可以再请求新的资源。&amp;ndash; 开始前就把所有需要的资源都申请好 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或多个进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 &amp;ndash; 给资源统一编号 3、处理方法 # 鸵鸟策略：因为代价太高了，所以如果影响不大或概率低 死锁预防：运行之前破坏4个条件 死锁检测与死锁恢复：有向图是否存在环、抢占、回滚、杀死进程 死锁避免：运行时 安全状态：就算所有进程突然请求对资源的最大需求，也存在 单个资源的银行家算法：如果满足请求，状态是否安全，拒绝进入不安全状态 多个资源的银行家算法：拒绝进入不安全状态 检测一个状态是否安全： 还需要分配的矩阵是否存在一行小于等于向量A?没有的话就是不安全的 找到一行，就标记终止，并计入已分配资源 知道所有进程都被标记终止，则状态安全。</description></item><item><title>计算机网络</title><link>https://heming6666.github.io/docs/cs/basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid><description>计算机网络 # 一、网络体系结构 # 分层原因：独立（更容易实现和维护）、标准化的制定 表示层的作用：数据转化，比如加解密、压缩和解压缩。如视频 会话层的作用：会话控制 二、传输层 TCP、UDP # 1-1、三次握手 # 服务端首先处于LISTEN状态，等待客户端的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x，发送完毕后，客户端就进入SYN_SENT状态 B 收到连接请求报文，进行第二次握手，向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。然后服务端进入SYN-RCVD. A 收到以后，进行第三次握手，向 B 发出确认报文，ACK=1，确认号为 y+1，序号为 x+1。然后进入ESTABLISHED状态，当服务器端收到以后，也进入ESTABLISHED状态。 1-2、为什么是三次握手，不是两次？ # 为了防止已失效的连接请求报文段突然又传送到了服务端，从而产生错误。
第一次握手请求，滞留，连接释放以后的某个时间到达。 服务端以为是新的连接请求，发确认报文，同意建立连接。 假设不采用“三次握手”，只要服务端确认了，新的连接就建立了。 但事实上客户端并没有，因此不会管服务端。但服务端一直等待数据，资源白白浪费。 从另外一个角度看，这个问题的本质是信道是不可靠的，但是通信的双方为了保证传输是可靠的，三次通信是理论上的最小值。例如TCP的可靠连接核心就是靠seq序列号来完成的。A会向B同步自己的初始序列号，B也会反过来向A同步自己的初始序列号，并且TCP规定，必须经过确认，也就是&amp;hellip;
1-3、如果第三次握手报文丢了，会怎么样？ # 如果第三次握手报文丢了，A发完后就进入Established状态，但B还是SYN-RCVD：
如果双方都没有数据要发送，则B会周期性超时重传； 如果A有数据要发给B，会发送 Data + ACK, B就会进入Established状态，并接受数据； 如果B有数据要发给A，发不了。同1. 2-1、四次挥手 # 第一次挥手。客户端向服务器端发送一个FIN报文，通知服务器，我已经没有数据要发送了，进入FIN_WAIT_1状态。 第二次挥手。服务端返回一个ACK报文，告诉客户端，我知道你已经没有东西要发送了，但我还要再确认一下我是不是还有东西要给你。然后服务器端进入CLOSE_WAIT状态。客户端接收到确认包之后进入FIN_WAIT_2状态。此时TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 第三次挥手。服务器判断自己也没有数据需要发送给客户端，就向客户端发送ACK和FIN消息，告诉客户端，好了，我也没有东西要给你了，你可以关掉这个连接了。然后服务器端就进入了LAST_ACK状态。 最后是第四次挥手。客户端发送确认报文。发送完以后，进入TIME_WAIT状态，等待 2 MSL以后，关闭连接，进入CLOSED状态。服务器端接收到确认包以后，也关闭连接，进入CLOSED状态。 2-2、为什么要四次挥手？ # 是为了确保客户端和服务端双方都能通知对方释放连接。</description></item><item><title>设计模式</title><link>https://heming6666.github.io/docs/cs/basic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>设计模式 # 零、反射 # 含义 # 在程序运行时，动态获取对象信息以及调用对象方法的能力。
要解决的问题 # 在程序运行时，通过类的名称字符串来生成类的对象。
一、简单工厂模式 # 含义 # 把实例化的操作单独放到一个类中，即：工厂负责生产对象。
要解决的问题 # 让使用者不需要知道内部细节，就能创建对象，实现解耦。
组成 # 抽象的Product，描述接口。 具体Product, 创建的目标类。 工厂类，被外界调用，根据传入不同参数从而创建不同类的实例。 实际代码 # 工厂类有个静态方法，可以用switch case控制返回哪个类的实例。外界只要调用并传入参数即可。
改进：通过反射机制，去掉switch case，添加新Product不用修改。
应用场景 # 当外界/客户端只关心传入参数，不关心内部逻辑时，解耦 缺点 # 处于中心位置，需要知道所有创建细节，职责过于繁重； 要加新的产品时，要修改工厂类。 二、工厂方法模式 # 含义 # 定义一个用于创建对象的接口，由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。
要解决的问题 # 让使用者不需要知道内部细节，就能创建对象，实现解耦。 新加产品时，只要添加具体产品和具体工厂就可以。 组成 # 抽象的Product：描述接口。 具体Product：具体产品。 抽象工厂类 具体工厂类 实际代码 # 客户端怎么调用？</description></item></channel></rss>