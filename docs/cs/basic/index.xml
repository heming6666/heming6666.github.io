<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>计算机基础知识 on 8898 写字的地方</title><link>https://heming6666.github.io/docs/cs/basic/</link><description>Recent content in 计算机基础知识 on 8898 写字的地方</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://heming6666.github.io/docs/cs/basic/index.xml" rel="self" type="application/rss+xml"/><item><title>进程与线程</title><link>https://heming6666.github.io/docs/cs/basic/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid><description>进程和线程 # 进程 # No.1、线程和进程的区别 # 可以从1、概念，2、所拥有的资源，3、开销 三个方面考虑。
从概念上来说，进程是资源分配的基本单位，线程是 CPU 调度的基本单位； 从资源的角度来讲， 一个进程可以有多个线程，线程间可以共享该进程的资源。比如说，进程有自己的独立地址空间，而这一个进程内的线程是共享这一份相同的地址空间的。这就意味着线程切换快，因为不需要切换页表。但同时，要是有一个线程挂掉了，整个进程也会挂掉。相比较之下，进程之间就不会有这种影响，也就是会比较健壮。 当然，除了共享的资源以外，线程也会有私有的一些资源，比如寄存器和栈。 从开销的角度来讲： 我们使用线程的时候，一方面是想要提高它的并发性，可以用多个线程去执行一个进程的不同部分，这样能充分发挥多CPU的功能。 另一方面是可以减少开销，比如 线程的创建时间比进程快，因为进程在创建的过程中，还需要分配内存、文件管理信息，而线程直接共享就可以了； 线程的终止会比进程快，同样的道理，它需要释放的资源会比较少； 线程切换快，因为同一个进程里面的线程都具有同一个页表，在切换的时候就不需要切换页表。 通信问题。线程因为会共享一些全局变量、静态变量等数据，因此线程间通信会方便一些，但也会带来同步和互斥的问题。进程间要通信就需要借助IPC。 共享的有：堆、全局变量、静态变量、指针，引用、文件 线程私有的有栈、寄存器等。 1. 概念:进程是操作系统资源分配的基本单位。 # 进程就是运行起来的可执行程序。我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个运行中的程序，就被称为「进程」。
2. 进程的状态：运行态、就绪态、阻塞态 # 运行状态：该进程正在 CPU上跑； 就绪状态：已经就绪，可运行，但还没有占有CPU，比如时间片用完了； 阻塞状态：该进程暂停运行，等待某一事件发生（比如等待键盘输入），即使给它CPU控制权，它也无法运行；如果完成了，就变成就绪态。 还有：创建状态、结束状态、挂起状态（表示进程没有占有内存空间，在硬盘上） 3. 进程的控制结构PCB # 是一个结构体，用来描述进程。也是进程存在的唯一标识。多个进程的PCCB通过链表的方式连接在一起。 包括：
进程描述信息：进程标识符、用户标识符 进程控制和管理信息：进程当前状态、进程优先级 CPU 相关信息：CPU 中各个寄存器的值 资源：内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。 4.</description></item><item><title/><link>https://heming6666.github.io/docs/cs/basic/http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/http/</guid><description>HTTP/HTTPS # 一、状态码 # 1、有哪些常见的状态码？ # 1xx - 正在处理 100 - 正常 101 - 切换请求协议 2- 成功 200 - 请求成功 201 - 已创建 202 - 已接受 204 - 无内容 3- 重定向 301 - 永久性重定向 302 - 临时重定向 4- 服务端无法处理请求（客户端错误 400 - Bad Request 语法错误 401 - Unauthorized 403 - Forbidden 拒绝 404 - not found 405 - method not allowd 406 - Not Acceptable 408 - Request Time-out 5- 服务端处理请求出错（服务端错误 500 - Internal Server Error 内部错误 501 - Not Implemented 502 - Bad Gateway 服务器无效响无效响应 503 - 服务器过载，稍后重试 504 - Gateway Timeout 请求超时，nginx 配置不对 2、301和302的区别是什么？ # 301是页面或资源永久性地移到了另一个位置。应用场景：网站移到了新的地址 / 或多个域名跳转到同一个域名，有利于URL权重的集中。 302是暂时性转移，常被用作网址劫持，搜索引擎会抓新的内容，但保存旧的网址。 二、HTTP 报文 # http请求报文</description></item><item><title/><link>https://heming6666.github.io/docs/cs/basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heming6666.github.io/docs/cs/basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid><description>计算机网络 # 一、网络体系结构 # 分层原因：独立（更容易实现和维护）、标准化的制定 表示层的作用：数据转化，比如加解密、压缩和解压缩。如视频 会话层的作用：会话控制 二、传输层 TCP、UDP # 1-1、三次握手 # 服务端首先处于LISTEN状态，等待客户端的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x，发送完毕后，客户端就进入SYN_SENT状态 B 收到连接请求报文，进行第二次握手，向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。然后服务端进入SYN-RCVD. A 收到以后，进行第三次握手，向 B 发出确认报文，ACK=1，确认号为 y+1，序号为 x+1。然后进入ESTABLISHED状态，当服务器端收到以后，也进入ESTABLISHED状态。 1-2、为什么是三次握手，不是两次？ # 为了防止已失效的连接请求报文段突然又传送到了服务端，从而产生错误。
第一次握手请求，滞留，连接释放以后的某个时间到达。 服务端以为是新的连接请求，发确认报文，同意建立连接。 假设不采用“三次握手”，只要服务端确认了，新的连接就建立了。 但事实上客户端并没有，因此不会管服务端。但服务端一直等待数据，资源白白浪费。 从另外一个角度看，这个问题的本质是信道是不可靠的，但是通信的双方为了保证传输是可靠的，三次通信是理论上的最小值。例如TCP的可靠连接核心就是靠seq序列号来完成的。A会向B同步自己的初始序列号，B也会反过来向A同步自己的初始序列号，并且TCP规定，必须经过确认，也就是&amp;hellip;
1-3、如果第三次握手报文丢了，会怎么样？ # 如果第三次握手报文丢了，A发完后就进入Established状态，但B还是SYN-RCVD：
如果双方都没有数据要发送，则B会周期性超时重传； 如果A有数据要发给B，会发送 Data + ACK, B就会进入Established状态，并接受数据； 如果B有数据要发给A，发不了。同1. 2-1、四次挥手 # 第一次挥手。客户端向服务器端发送一个FIN报文，通知服务器，我已经没有数据要发送了，进入FIN_WAIT_1状态。 第二次挥手。服务端返回一个ACK报文，告诉客户端，我知道你已经没有东西要发送了，但我还要再确认一下我是不是还有东西要给你。然后服务器端进入CLOSE_WAIT状态。客户端接收到确认包之后进入FIN_WAIT_2状态。此时TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 第三次挥手。服务器判断自己也没有数据需要发送给客户端，就向客户端发送ACK和FIN消息，告诉客户端，好了，我也没有东西要给你了，你可以关掉这个连接了。然后服务器端就进入了LAST_ACK状态。 最后是第四次挥手。客户端发送确认报文。发送完以后，进入TIME_WAIT状态，等待 2 MSL以后，关闭连接，进入CLOSED状态。服务器端接收到确认包以后，也关闭连接，进入CLOSED状态。 2-2、为什么要四次挥手？ # 是为了确保客户端和服务端双方都能通知对方释放连接。</description></item></channel></rss>